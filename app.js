!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], ["73","75","76","4","74","77","72","78"], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('3', ['4', '2'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    /*! 
     * angular-loading-bar v0.8.0
     * https://chieffancypants.github.io/angular-loading-bar
     * Copyright (c) 2015 Wes Cruver
     * License: MIT
     */
    /*
     * angular-loading-bar
     *
     * intercepts XHR requests and creates a loading bar.
     * Based on the excellent nprogress work by rstacruz (more info in readme)
     *
     * (c) 2013 Wes Cruver
     * License: MIT
     */

    (function () {

      'use strict';

      // Alias the loading bar for various backwards compatibilities since the project has matured:

      angular.module('angular-loading-bar', ['cfp.loadingBarInterceptor']);
      angular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);

      /**
       * loadingBarInterceptor service
       *
       * Registers itself as an Angular interceptor and listens for XHR requests.
       */
      angular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar']).config(['$httpProvider', function ($httpProvider) {

        var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {

          /**
           * The total number of requests made
           */
          var reqsTotal = 0;

          /**
           * The number of requests completed (either successfully or not)
           */
          var reqsCompleted = 0;

          /**
           * The amount of time spent fetching before showing the loading bar
           */
          var latencyThreshold = cfpLoadingBar.latencyThreshold;

          /**
           * $timeout handle for latencyThreshold
           */
          var startTimeout;

          /**
           * calls cfpLoadingBar.complete() which removes the
           * loading bar from the DOM.
           */
          function setComplete() {
            $timeout.cancel(startTimeout);
            cfpLoadingBar.complete();
            reqsCompleted = 0;
            reqsTotal = 0;
          }

          /**
           * Determine if the response has already been cached
           * @param  {Object}  config the config option from the request
           * @return {Boolean} retrns true if cached, otherwise false
           */
          function isCached(config) {
            var cache;
            var defaultCache = $cacheFactory.get('$http');
            var defaults = $httpProvider.defaults;

            // Choose the proper cache source. Borrowed from angular: $http service
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache;
            }

            var cached = cache !== undefined ? cache.get(config.url) !== undefined : false;

            if (config.cached !== undefined && cached !== config.cached) {
              return config.cached;
            }
            config.cached = cached;
            return cached;
          }

          return {
            'request': function (config) {
              // Check to make sure this request hasn't already been cached and that
              // the requester didn't explicitly ask us to ignore this request:
              if (!config.ignoreLoadingBar && !isCached(config)) {
                $rootScope.$broadcast('cfpLoadingBar:loading', { url: config.url });
                if (reqsTotal === 0) {
                  startTimeout = $timeout(function () {
                    cfpLoadingBar.start();
                  }, latencyThreshold);
                }
                reqsTotal++;
                cfpLoadingBar.set(reqsCompleted / reqsTotal);
              }
              return config;
            },

            'response': function (response) {
              if (!response || !response.config) {
                $log.error('Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return response;
              }

              if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', { url: response.config.url, result: response });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return response;
            },

            'responseError': function (rejection) {
              if (!rejection || !rejection.config) {
                $log.error('Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return $q.reject(rejection);
              }

              if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', { url: rejection.config.url, result: rejection });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return $q.reject(rejection);
            }
          };
        }];

        $httpProvider.interceptors.push(interceptor);
      }]);

      /**
       * Loading Bar
       *
       * This service handles adding and removing the actual element in the DOM.
       * Generally, best practices for DOM manipulation is to take place in a
       * directive, but because the element itself is injected in the DOM only upon
       * XHR requests, and it's likely needed on every view, the best option is to
       * use a service.
       */
      angular.module('cfp.loadingBar', []).provider('cfpLoadingBar', function () {

        this.autoIncrement = true;
        this.includeSpinner = true;
        this.includeBar = true;
        this.latencyThreshold = 100;
        this.startSize = 0.02;
        this.parentSelector = 'body';
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';

        this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {
          var $animate;
          var $parentSelector = this.parentSelector,
              loadingBarContainer = angular.element(this.loadingBarTemplate),
              loadingBar = loadingBarContainer.find('div').eq(0),
              spinner = angular.element(this.spinnerTemplate);

          var incTimeout,
              completeTimeout,
              started = false,
              status = 0;

          var autoIncrement = this.autoIncrement;
          var includeSpinner = this.includeSpinner;
          var includeBar = this.includeBar;
          var startSize = this.startSize;

          /**
           * Inserts the loading bar element into the dom, and sets it to 2%
           */
          function _start() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }

            var $parent = $document.find($parentSelector).eq(0);
            $timeout.cancel(completeTimeout);

            // do not continually broadcast the started event:
            if (started) {
              return;
            }

            $rootScope.$broadcast('cfpLoadingBar:started');
            started = true;

            if (includeBar) {
              $animate.enter(loadingBarContainer, $parent, angular.element($parent[0].lastChild));
            }

            if (includeSpinner) {
              $animate.enter(spinner, $parent, angular.element($parent[0].lastChild));
            }

            _set(startSize);
          }

          /**
           * Set the loading bar's width to a certain percent.
           *
           * @param n any value between 0 and 1
           */
          function _set(n) {
            if (!started) {
              return;
            }
            var pct = n * 100 + '%';
            loadingBar.css('width', pct);
            status = n;

            // increment loadingbar to give the illusion that there is always
            // progress but make sure to cancel the previous timeouts so we don't
            // have multiple incs running at the same time.
            if (autoIncrement) {
              $timeout.cancel(incTimeout);
              incTimeout = $timeout(function () {
                _inc();
              }, 250);
            }
          }

          /**
           * Increments the loading bar by a random amount
           * but slows down as it progresses
           */
          function _inc() {
            if (_status() >= 1) {
              return;
            }

            var rnd = 0;

            // TODO: do this mathmatically instead of through conditions

            var stat = _status();
            if (stat >= 0 && stat < 0.25) {
              // Start out between 3 - 6% increments
              rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
            } else if (stat >= 0.25 && stat < 0.65) {
              // increment between 0 - 3%
              rnd = Math.random() * 3 / 100;
            } else if (stat >= 0.65 && stat < 0.9) {
              // increment between 0 - 2%
              rnd = Math.random() * 2 / 100;
            } else if (stat >= 0.9 && stat < 0.99) {
              // finally, increment it .5 %
              rnd = 0.005;
            } else {
              // after 99%, don't increment:
              rnd = 0;
            }

            var pct = _status() + rnd;
            _set(pct);
          }

          function _status() {
            return status;
          }

          function _completeAnimation() {
            status = 0;
            started = false;
          }

          function _complete() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }

            $rootScope.$broadcast('cfpLoadingBar:completed');
            _set(1);

            $timeout.cancel(completeTimeout);

            // Attempt to aggregate any start/complete calls within 500ms:
            completeTimeout = $timeout(function () {
              var promise = $animate.leave(loadingBarContainer, _completeAnimation);
              if (promise && promise.then) {
                promise.then(_completeAnimation);
              }
              $animate.leave(spinner);
            }, 500);
          }

          return {
            start: _start,
            set: _set,
            status: _status,
            inc: _inc,
            complete: _complete,
            autoIncrement: this.autoIncrement,
            includeSpinner: this.includeSpinner,
            latencyThreshold: this.latencyThreshold,
            parentSelector: this.parentSelector,
            startSize: this.startSize
          };
        }]; //
      }); // wtf javascript. srsly
    })(); //
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('5', [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // HumanizeDuration.js - http://git.io/j0HgmQ

    ;(function () {
      var languages = {
        ar: {
          y: function (c) {
            return c === 1 ? 'سنة' : 'سنوات';
          },
          mo: function (c) {
            return c === 1 ? 'شهر' : 'أشهر';
          },
          w: function (c) {
            return c === 1 ? 'أسبوع' : 'أسابيع';
          },
          d: function (c) {
            return c === 1 ? 'يوم' : 'أيام';
          },
          h: function (c) {
            return c === 1 ? 'ساعة' : 'ساعات';
          },
          m: function (c) {
            return c === 1 ? 'دقيقة' : 'دقائق';
          },
          s: function (c) {
            return c === 1 ? 'ثانية' : 'ثواني';
          },
          ms: function (c) {
            return c === 1 ? 'جزء من الثانية' : 'أجزاء من الثانية';
          },
          decimal: ','
        },
        ca: {
          y: function (c) {
            return 'any' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'os' : '');
          },
          w: function (c) {
            return 'setman' + (c !== 1 ? 'es' : 'a');
          },
          d: function (c) {
            return 'di' + (c !== 1 ? 'es' : 'a');
          },
          h: function (c) {
            return 'hor' + (c !== 1 ? 'es' : 'a');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segon' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milisegon' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        cs: {
          y: function (c) {
            return ['rok', 'roku', 'roky', 'let'][getCzechForm(c)];
          },
          mo: function (c) {
            return ['měsíc', 'měsíce', 'měsíce', 'měsíců'][getCzechForm(c)];
          },
          w: function (c) {
            return ['týden', 'týdne', 'týdny', 'týdnů'][getCzechForm(c)];
          },
          d: function (c) {
            return ['den', 'dne', 'dny', 'dní'][getCzechForm(c)];
          },
          h: function (c) {
            return ['hodina', 'hodiny', 'hodiny', 'hodin'][getCzechForm(c)];
          },
          m: function (c) {
            return ['minuta', 'minuty', 'minuty', 'minut'][getCzechForm(c)];
          },
          s: function (c) {
            return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getCzechForm(c)];
          },
          ms: function (c) {
            return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getCzechForm(c)];
          },
          decimal: ','
        },
        da: {
          y: 'år',
          mo: function (c) {
            return 'måned' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'uge' + (c !== 1 ? 'r' : '');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'e' : '');
          },
          h: function (c) {
            return 'time' + (c !== 1 ? 'r' : '');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'ter' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        de: {
          y: function (c) {
            return 'Jahr' + (c !== 1 ? 'e' : '');
          },
          mo: function (c) {
            return 'Monat' + (c !== 1 ? 'e' : '');
          },
          w: function (c) {
            return 'Woche' + (c !== 1 ? 'n' : '');
          },
          d: function (c) {
            return 'Tag' + (c !== 1 ? 'e' : '');
          },
          h: function (c) {
            return 'Stunde' + (c !== 1 ? 'n' : '');
          },
          m: function (c) {
            return 'Minute' + (c !== 1 ? 'n' : '');
          },
          s: function (c) {
            return 'Sekunde' + (c !== 1 ? 'n' : '');
          },
          ms: function (c) {
            return 'Millisekunde' + (c !== 1 ? 'n' : '');
          },
          decimal: ','
        },
        en: {
          y: function (c) {
            return 'year' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'month' + (c !== 1 ? 's' : '');
          },
          w: function (c) {
            return 'week' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'day' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hour' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minute' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'second' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'millisecond' + (c !== 1 ? 's' : '');
          },
          decimal: '.'
        },
        es: {
          y: function (c) {
            return 'año' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'es' : '');
          },
          w: function (c) {
            return 'semana' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'día' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hora' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minuto' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segundo' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milisegundo' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        fi: {
          y: function (c) {
            return c === 1 ? 'vuosi' : 'vuotta';
          },
          mo: function (c) {
            return c === 1 ? 'kuukausi' : 'kuukautta';
          },
          w: function (c) {
            return 'viikko' + (c !== 1 ? 'a' : '');
          },
          d: function (c) {
            return 'päivä' + (c !== 1 ? 'ä' : '');
          },
          h: function (c) {
            return 'tunti' + (c !== 1 ? 'a' : '');
          },
          m: function (c) {
            return 'minuutti' + (c !== 1 ? 'a' : '');
          },
          s: function (c) {
            return 'sekunti' + (c !== 1 ? 'a' : '');
          },
          ms: function (c) {
            return 'millisekunti' + (c !== 1 ? 'a' : '');
          },
          decimal: ','
        },
        fr: {
          y: function (c) {
            return 'an' + (c !== 1 ? 's' : '');
          },
          mo: 'mois',
          w: function (c) {
            return 'semaine' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'jour' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'heure' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minute' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'seconde' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milliseconde' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        gr: {
          y: function (c) {
            return c === 1 ? 'χρόνος' : 'χρόνια';
          },
          mo: function (c) {
            return c === 1 ? 'μήνας' : 'μήνες';
          },
          w: function (c) {
            return c === 1 ? 'εβδομάδα' : 'εβδομάδες';
          },
          d: function (c) {
            return c === 1 ? 'μέρα' : 'μέρες';
          },
          h: function (c) {
            return c === 1 ? 'ώρα' : 'ώρες';
          },
          m: function (c) {
            return c === 1 ? 'λεπτό' : 'λεπτά';
          },
          s: function (c) {
            return c === 1 ? 'δευτερόλεπτο' : 'δευτερόλεπτα';
          },
          ms: function (c) {
            return c === 1 ? 'χιλιοστό του δευτερολέπτου' : 'χιλιοστά του δευτερολέπτου';
          },
          decimal: ','
        },
        hu: {
          y: 'év',
          mo: 'hónap',
          w: 'hét',
          d: 'nap',
          h: 'óra',
          m: 'perc',
          s: 'másodperc',
          ms: 'ezredmásodperc',
          decimal: ','
        },
        id: {
          y: 'tahun',
          mo: 'bulan',
          w: 'minggu',
          d: 'hari',
          h: 'jam',
          m: 'menit',
          s: 'detik',
          ms: 'milidetik',
          decimal: '.'
        },
        it: {
          y: function (c) {
            return 'ann' + (c !== 1 ? 'i' : 'o');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'i' : 'e');
          },
          w: function (c) {
            return 'settiman' + (c !== 1 ? 'e' : 'a');
          },
          d: function (c) {
            return 'giorn' + (c !== 1 ? 'i' : 'o');
          },
          h: function (c) {
            return 'or' + (c !== 1 ? 'e' : 'a');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'i' : 'o');
          },
          s: function (c) {
            return 'second' + (c !== 1 ? 'i' : 'o');
          },
          ms: function (c) {
            return 'millisecond' + (c !== 1 ? 'i' : 'o');
          },
          decimal: ','
        },
        ja: {
          y: '年',
          mo: '月',
          w: '週',
          d: '日',
          h: '時間',
          m: '分',
          s: '秒',
          ms: 'ミリ秒',
          decimal: '.'
        },
        ko: {
          y: '년',
          mo: '개월',
          w: '주일',
          d: '일',
          h: '시간',
          m: '분',
          s: '초',
          ms: '밀리 초',
          decimal: '.'
        },
        lt: {
          y: function (c) {
            return c % 10 === 0 || c % 100 >= 10 && c % 100 <= 20 ? 'metų' : 'metai';
          },
          mo: function (c) {
            return ['mėnuo', 'mėnesiai', 'mėnesių'][getLithuanianForm(c)];
          },
          w: function (c) {
            return ['savaitė', 'savaitės', 'savaičių'][getLithuanianForm(c)];
          },
          d: function (c) {
            return ['diena', 'dienos', 'dienų'][getLithuanianForm(c)];
          },
          h: function (c) {
            return ['valanda', 'valandos', 'valandų'][getLithuanianForm(c)];
          },
          m: function (c) {
            return ['minutė', 'minutės', 'minučių'][getLithuanianForm(c)];
          },
          s: function (c) {
            return ['sekundė', 'sekundės', 'sekundžių'][getLithuanianForm(c)];
          },
          ms: function (c) {
            return ['milisekundė', 'milisekundės', 'milisekundžių'][getLithuanianForm(c)];
          },
          decimal: ','
        },
        ms: {
          y: 'tahun',
          mo: 'bulan',
          w: 'minggu',
          d: 'hari',
          h: 'jam',
          m: 'minit',
          s: 'saat',
          ms: 'milisaat',
          decimal: '.'
        },
        nl: {
          y: 'jaar',
          mo: function (c) {
            return c === 1 ? 'maand' : 'maanden';
          },
          w: function (c) {
            return c === 1 ? 'week' : 'weken';
          },
          d: function (c) {
            return c === 1 ? 'dag' : 'dagen';
          },
          h: 'uur',
          m: function (c) {
            return c === 1 ? 'minuut' : 'minuten';
          },
          s: function (c) {
            return c === 1 ? 'seconde' : 'seconden';
          },
          ms: function (c) {
            return c === 1 ? 'milliseconde' : 'milliseconden';
          },
          decimal: ','
        },
        no: {
          y: 'år',
          mo: function (c) {
            return 'måned' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'uke' + (c !== 1 ? 'r' : '');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'er' : '');
          },
          h: function (c) {
            return 'time' + (c !== 1 ? 'r' : '');
          },
          m: function (c) {
            return 'minutt' + (c !== 1 ? 'er' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        pl: {
          y: function (c) {
            return ['rok', 'roku', 'lata', 'lat'][getPolishForm(c)];
          },
          mo: function (c) {
            return ['miesiąc', 'miesiąca', 'miesiące', 'miesięcy'][getPolishForm(c)];
          },
          w: function (c) {
            return ['tydzień', 'tygodnia', 'tygodnie', 'tygodni'][getPolishForm(c)];
          },
          d: function (c) {
            return ['dzień', 'dnia', 'dni', 'dni'][getPolishForm(c)];
          },
          h: function (c) {
            return ['godzina', 'godziny', 'godziny', 'godzin'][getPolishForm(c)];
          },
          m: function (c) {
            return ['minuta', 'minuty', 'minuty', 'minut'][getPolishForm(c)];
          },
          s: function (c) {
            return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getPolishForm(c)];
          },
          ms: function (c) {
            return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getPolishForm(c)];
          },
          decimal: ','
        },
        pt: {
          y: function (c) {
            return 'ano' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return c !== 1 ? 'meses' : 'mês';
          },
          w: function (c) {
            return 'semana' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'dia' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hora' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minuto' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segundo' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milissegundo' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        ru: {
          y: function (c) {
            return ['лет', 'год', 'года'][getSlavicForm(c)];
          },
          mo: function (c) {
            return ['месяцев', 'месяц', 'месяца'][getSlavicForm(c)];
          },
          w: function (c) {
            return ['недель', 'неделя', 'недели'][getSlavicForm(c)];
          },
          d: function (c) {
            return ['дней', 'день', 'дня'][getSlavicForm(c)];
          },
          h: function (c) {
            return ['часов', 'час', 'часа'][getSlavicForm(c)];
          },
          m: function (c) {
            return ['минут', 'минута', 'минуты'][getSlavicForm(c)];
          },
          s: function (c) {
            return ['секунд', 'секунда', 'секунды'][getSlavicForm(c)];
          },
          ms: function (c) {
            return ['миллисекунд', 'миллисекунда', 'миллисекунды'][getSlavicForm(c)];
          },
          decimal: ','
        },
        uk: {
          y: function (c) {
            return ['років', 'рік', 'роки'][getSlavicForm(c)];
          },
          mo: function (c) {
            return ['місяців', 'місяць', 'місяці'][getSlavicForm(c)];
          },
          w: function (c) {
            return ['неділь', 'неділя', 'неділі'][getSlavicForm(c)];
          },
          d: function (c) {
            return ['днів', 'день', 'дні'][getSlavicForm(c)];
          },
          h: function (c) {
            return ['годин', 'година', 'години'][getSlavicForm(c)];
          },
          m: function (c) {
            return ['хвилин', 'хвилина', 'хвилини'][getSlavicForm(c)];
          },
          s: function (c) {
            return ['секунд', 'секунда', 'секунди'][getSlavicForm(c)];
          },
          ms: function (c) {
            return ['мілісекунд', 'мілісекунда', 'мілісекунди'][getSlavicForm(c)];
          },
          decimal: ','
        },
        sv: {
          y: 'år',
          mo: function (c) {
            return 'månad' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'veck' + (c !== 1 ? 'or' : 'a');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'ar' : '');
          },
          h: function (c) {
            return 'timm' + (c !== 1 ? 'ar' : 'e');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'er' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        tr: {
          y: 'yıl',
          mo: 'ay',
          w: 'hafta',
          d: 'gün',
          h: 'saat',
          m: 'dakika',
          s: 'saniye',
          ms: 'milisaniye',
          decimal: ','
        },
        vi: {
          y: 'năm',
          mo: 'tháng',
          w: 'tuần',
          d: 'ngày',
          h: 'giờ',
          m: 'phút',
          s: 'giây',
          ms: 'mili giây',
          decimal: ','
        },
        zh_CN: {
          y: '年',
          mo: '个月',
          w: '周',
          d: '天',
          h: '小时',
          m: '分钟',
          s: '秒',
          ms: '毫秒',
          decimal: '.'
        },
        zh_TW: {
          y: '年',
          mo: '個月',
          w: '周',
          d: '天',
          h: '小時',
          m: '分鐘',
          s: '秒',
          ms: '毫秒',
          decimal: '.'
        }
      };

      // You can create a humanizer, which returns a function with default
      // parameters.
      function humanizer(passedOptions) {
        var result = function humanizer(ms, humanizerOptions) {
          var options = extend({}, result, humanizerOptions || {});
          return doHumanization(ms, options);
        };

        return extend(result, {
          language: 'en',
          delimiter: ', ',
          spacer: ' ',
          conjunction: '',
          serialComma: true,
          units: ['y', 'mo', 'w', 'd', 'h', 'm', 's'],
          languages: {},
          round: false,
          unitMeasures: {
            y: 31557600000,
            mo: 2629800000,
            w: 604800000,
            d: 86400000,
            h: 3600000,
            m: 60000,
            s: 1000,
            ms: 1
          }
        }, passedOptions);
      }

      // The main function is just a wrapper around a default humanizer.
      var humanizeDuration = humanizer({});

      // doHumanization does the bulk of the work.
      function doHumanization(ms, options) {
        var i, len, piece;

        // Make sure we have a positive number.
        // Has the nice sideffect of turning Number objects into primitives.
        ms = Math.abs(ms);

        var dictionary = options.languages[options.language] || languages[options.language];
        if (!dictionary) {
          throw new Error('No language ' + dictionary + '.');
        }

        var pieces = [];

        // Start at the top and keep removing units, bit by bit.
        var unitName, unitMS, unitCount;
        for (i = 0, len = options.units.length; i < len; i++) {
          unitName = options.units[i];
          unitMS = options.unitMeasures[unitName];

          // What's the number of full units we can fit?
          if (i + 1 === len) {
            unitCount = ms / unitMS;
          } else {
            unitCount = Math.floor(ms / unitMS);
          }

          // Add the string.
          pieces.push({
            unitCount: unitCount,
            unitName: unitName
          });

          // Remove what we just figured out.
          ms -= unitCount * unitMS;
        }

        var firstOccupiedUnitIndex = 0;
        for (i = 0; i < pieces.length; i++) {
          if (pieces[i].unitCount) {
            firstOccupiedUnitIndex = i;
            break;
          }
        }

        if (options.round) {
          var ratioToLargerUnit, previousPiece;
          for (i = pieces.length - 1; i >= 0; i--) {
            piece = pieces[i];
            piece.unitCount = Math.round(piece.unitCount);

            if (i === 0) {
              break;
            }

            previousPiece = pieces[i - 1];

            ratioToLargerUnit = options.unitMeasures[previousPiece.unitName] / options.unitMeasures[piece.unitName];
            if (piece.unitCount % ratioToLargerUnit === 0 || options.largest && options.largest - 1 < i - firstOccupiedUnitIndex) {
              previousPiece.unitCount += piece.unitCount / ratioToLargerUnit;
              piece.unitCount = 0;
            }
          }
        }

        var result = [];
        for (i = 0, pieces.length; i < len; i++) {
          piece = pieces[i];
          if (piece.unitCount) {
            result.push(render(piece.unitCount, piece.unitName, dictionary, options));
          }

          if (result.length === options.largest) {
            break;
          }
        }

        if (result.length) {
          if (!options.conjunction || result.length === 1) {
            return result.join(options.delimiter);
          } else if (result.length === 2) {
            return result.join(options.conjunction);
          } else if (result.length > 2) {
            return result.slice(0, -1).join(options.delimiter) + (options.serialComma ? ',' : '') + options.conjunction + result.slice(-1);
          }
        } else {
          return render(0, options.units[options.units.length - 1], dictionary, options);
        }
      }

      function render(count, type, dictionary, options) {
        var decimal;
        if (options.decimal === void 0) {
          decimal = dictionary.decimal;
        } else {
          decimal = options.decimal;
        }

        var countStr = count.toString().replace('.', decimal);

        var dictionaryValue = dictionary[type];
        var word;
        if (typeof dictionaryValue === 'function') {
          word = dictionaryValue(count);
        } else {
          word = dictionaryValue;
        }

        return countStr + options.spacer + word;
      }

      function extend(destination) {
        var source;
        for (var i = 1; i < arguments.length; i++) {
          source = arguments[i];
          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              destination[prop] = source[prop];
            }
          }
        }
        return destination;
      }

      // Internal helper function for Czech language.
      function getCzechForm(c) {
        if (c === 1) {
          return 0;
        } else if (Math.floor(c) !== c) {
          return 1;
        } else if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {
          return 2;
        } else {
          return 3;
        }
      }

      // Internal helper function for Polish language.
      function getPolishForm(c) {
        if (c === 1) {
          return 0;
        } else if (Math.floor(c) !== c) {
          return 1;
        } else if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {
          return 2;
        } else {
          return 3;
        }
      }

      // Internal helper function for Russian and Ukranian languages.
      function getSlavicForm(c) {
        if (Math.floor(c) !== c) {
          return 2;
        } else if (c % 100 >= 5 && c % 100 <= 20 || c % 10 >= 5 && c % 10 <= 9 || c % 10 === 0) {
          return 0;
        } else if (c % 10 === 1) {
          return 1;
        } else if (c > 1) {
          return 2;
        } else {
          return 0;
        }
      }

      // Internal helper function for Lithuanian language.
      function getLithuanianForm(c) {
        if (c === 1 || c % 10 === 1 && c % 100 > 20) {
          return 0;
        } else if (Math.floor(c) !== c || c % 10 >= 2 && c % 100 > 20 || c % 10 >= 2 && c % 100 < 10) {
          return 1;
        } else {
          return 2;
        }
      }

      humanizeDuration.getSupportedLanguages = function getSupportedLanguages() {
        var result = [];
        for (var language in languages) {
          if (languages.hasOwnProperty(language)) {
            result.push(language);
          }
        }
        return result;
      };

      humanizeDuration.humanizer = humanizer;

      if (typeof define === 'function' && define.amd) {
        define(function () {
          return humanizeDuration;
        });
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = humanizeDuration;
      } else {
        this.humanizeDuration = humanizeDuration;
      }
    })(); // eslint-disable-line semi
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('6', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'moment', null);

    (function ($__global) {
        //! moment.js
        //! version : 2.15.1
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        ;(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
        })(this, function () {
            'use strict';

            var hookCallback;

            function utils_hooks__hooks() {
                return hookCallback.apply(null, arguments);
            }

            // This is done to register the method called with moment()
            // without creating circular dependencies.
            function setHookCallback(callback) {
                hookCallback = callback;
            }

            function isArray(input) {
                return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
            }

            function isObject(input) {
                // IE8 will treat undefined and null as object if it wasn't for
                // input != null
                return input != null && Object.prototype.toString.call(input) === '[object Object]';
            }

            function isObjectEmpty(obj) {
                var k;
                for (k in obj) {
                    // even if its not own property I'd still call it non-empty
                    return false;
                }
                return true;
            }

            function isDate(input) {
                return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
            }

            function map(arr, fn) {
                var res = [],
                    i;
                for (i = 0; i < arr.length; ++i) {
                    res.push(fn(arr[i], i));
                }
                return res;
            }

            function hasOwnProp(a, b) {
                return Object.prototype.hasOwnProperty.call(a, b);
            }

            function extend(a, b) {
                for (var i in b) {
                    if (hasOwnProp(b, i)) {
                        a[i] = b[i];
                    }
                }

                if (hasOwnProp(b, 'toString')) {
                    a.toString = b.toString;
                }

                if (hasOwnProp(b, 'valueOf')) {
                    a.valueOf = b.valueOf;
                }

                return a;
            }

            function create_utc__createUTC(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, true).utc();
            }

            function defaultParsingFlags() {
                // We need to deep clone this object.
                return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    meridiem: null
                };
            }

            function getParsingFlags(m) {
                if (m._pf == null) {
                    m._pf = defaultParsingFlags();
                }
                return m._pf;
            }

            var some;
            if (Array.prototype.some) {
                some = Array.prototype.some;
            } else {
                some = function (fun) {
                    var t = Object(this);
                    var len = t.length >>> 0;

                    for (var i = 0; i < len; i++) {
                        if (i in t && fun.call(this, t[i], i, t)) {
                            return true;
                        }
                    }

                    return false;
                };
            }

            function valid__isValid(m) {
                if (m._isValid == null) {
                    var flags = getParsingFlags(m);
                    var parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    });
                    var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

                    if (m._strict) {
                        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
                    }

                    if (Object.isFrozen == null || !Object.isFrozen(m)) {
                        m._isValid = isNowValid;
                    } else {
                        return isNowValid;
                    }
                }
                return m._isValid;
            }

            function valid__createInvalid(flags) {
                var m = create_utc__createUTC(NaN);
                if (flags != null) {
                    extend(getParsingFlags(m), flags);
                } else {
                    getParsingFlags(m).userInvalidated = true;
                }

                return m;
            }

            function isUndefined(input) {
                return input === void 0;
            }

            // Plugins that add properties should also add the key here (null value),
            // so we can properly clone ourselves.
            var momentProperties = utils_hooks__hooks.momentProperties = [];

            function copyConfig(to, from) {
                var i, prop, val;

                if (!isUndefined(from._isAMomentObject)) {
                    to._isAMomentObject = from._isAMomentObject;
                }
                if (!isUndefined(from._i)) {
                    to._i = from._i;
                }
                if (!isUndefined(from._f)) {
                    to._f = from._f;
                }
                if (!isUndefined(from._l)) {
                    to._l = from._l;
                }
                if (!isUndefined(from._strict)) {
                    to._strict = from._strict;
                }
                if (!isUndefined(from._tzm)) {
                    to._tzm = from._tzm;
                }
                if (!isUndefined(from._isUTC)) {
                    to._isUTC = from._isUTC;
                }
                if (!isUndefined(from._offset)) {
                    to._offset = from._offset;
                }
                if (!isUndefined(from._pf)) {
                    to._pf = getParsingFlags(from);
                }
                if (!isUndefined(from._locale)) {
                    to._locale = from._locale;
                }

                if (momentProperties.length > 0) {
                    for (i in momentProperties) {
                        prop = momentProperties[i];
                        val = from[prop];
                        if (!isUndefined(val)) {
                            to[prop] = val;
                        }
                    }
                }

                return to;
            }

            var updateInProgress = false;

            // Moment prototype object
            function Moment(config) {
                copyConfig(this, config);
                this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                // Prevent infinite loop in case updateOffset creates new moment
                // objects.
                if (updateInProgress === false) {
                    updateInProgress = true;
                    utils_hooks__hooks.updateOffset(this);
                    updateInProgress = false;
                }
            }

            function isMoment(obj) {
                return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
            }

            function absFloor(number) {
                if (number < 0) {
                    // -0 -> 0
                    return Math.ceil(number) || 0;
                } else {
                    return Math.floor(number);
                }
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion,
                    value = 0;

                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                }

                return value;
            }

            // compare two arrays, return the number of differences
            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0,
                    i;
                for (i = 0; i < len; i++) {
                    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }

            function warn(msg) {
                if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
                    console.warn('Deprecation warning: ' + msg);
                }
            }

            function deprecate(msg, fn) {
                var firstTime = true;

                return extend(function () {
                    if (utils_hooks__hooks.deprecationHandler != null) {
                        utils_hooks__hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                        var args = [];
                        var arg;
                        for (var i = 0; i < arguments.length; i++) {
                            arg = '';
                            if (typeof arguments[i] === 'object') {
                                arg += '\n[' + i + '] ';
                                for (var key in arguments[0]) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                                arg = arg.slice(0, -2); // Remove trailing comma and space
                            } else {
                                arg = arguments[i];
                            }
                            args.push(arg);
                        }
                        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
                        firstTime = false;
                    }
                    return fn.apply(this, arguments);
                }, fn);
            }

            var deprecations = {};

            function deprecateSimple(name, msg) {
                if (utils_hooks__hooks.deprecationHandler != null) {
                    utils_hooks__hooks.deprecationHandler(name, msg);
                }
                if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                }
            }

            utils_hooks__hooks.suppressDeprecationWarnings = false;
            utils_hooks__hooks.deprecationHandler = null;

            function isFunction(input) {
                return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
            }

            function locale_set__set(config) {
                var prop, i;
                for (i in config) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
                this._config = config;
                // Lenient ordinal parsing accepts just a number in addition to
                // number + (possibly) stuff coming from _ordinalParseLenient.
                this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
            }

            function mergeConfigs(parentConfig, childConfig) {
                var res = extend({}, parentConfig),
                    prop;
                for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                            res[prop] = {};
                            extend(res[prop], parentConfig[prop]);
                            extend(res[prop], childConfig[prop]);
                        } else if (childConfig[prop] != null) {
                            res[prop] = childConfig[prop];
                        } else {
                            delete res[prop];
                        }
                    }
                }
                for (prop in parentConfig) {
                    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                        // make sure changes to properties don't modify parent config
                        res[prop] = extend({}, res[prop]);
                    }
                }
                return res;
            }

            function Locale(config) {
                if (config != null) {
                    this.set(config);
                }
            }

            var keys;

            if (Object.keys) {
                keys = Object.keys;
            } else {
                keys = function (obj) {
                    var i,
                        res = [];
                    for (i in obj) {
                        if (hasOwnProp(obj, i)) {
                            res.push(i);
                        }
                    }
                    return res;
                };
            }

            var defaultCalendar = {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            };

            function locale_calendar__calendar(key, mom, now) {
                var output = this._calendar[key] || this._calendar['sameElse'];
                return isFunction(output) ? output.call(mom, now) : output;
            }

            var defaultLongDateFormat = {
                LTS: 'h:mm:ss A',
                LT: 'h:mm A',
                L: 'MM/DD/YYYY',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY h:mm A',
                LLLL: 'dddd, MMMM D, YYYY h:mm A'
            };

            function longDateFormat(key) {
                var format = this._longDateFormat[key],
                    formatUpper = this._longDateFormat[key.toUpperCase()];

                if (format || !formatUpper) {
                    return format;
                }

                this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });

                return this._longDateFormat[key];
            }

            var defaultInvalidDate = 'Invalid date';

            function invalidDate() {
                return this._invalidDate;
            }

            var defaultOrdinal = '%d';
            var defaultOrdinalParse = /\d{1,2}/;

            function ordinal(number) {
                return this._ordinal.replace('%d', number);
            }

            var defaultRelativeTime = {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years'
            };

            function relative__relativeTime(number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
            }

            function pastFuture(diff, output) {
                var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                return isFunction(format) ? format(output) : format.replace(/%s/i, output);
            }

            var aliases = {};

            function addUnitAlias(unit, shorthand) {
                var lowerCase = unit.toLowerCase();
                aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
            }

            function normalizeUnits(units) {
                return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {},
                    normalizedProp,
                    prop;

                for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop];
                        }
                    }
                }

                return normalizedInput;
            }

            var priorities = {};

            function addUnitPriority(unit, priority) {
                priorities[unit] = priority;
            }

            function getPrioritizedUnits(unitsObj) {
                var units = [];
                for (var u in unitsObj) {
                    units.push({ unit: u, priority: priorities[u] });
                }
                units.sort(function (a, b) {
                    return a.priority - b.priority;
                });
                return units;
            }

            function makeGetSet(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        get_set__set(this, unit, value);
                        utils_hooks__hooks.updateOffset(this, keepTime);
                        return this;
                    } else {
                        return get_set__get(this, unit);
                    }
                };
            }

            function get_set__get(mom, unit) {
                return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
            }

            function get_set__set(mom, unit, value) {
                if (mom.isValid()) {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }

            // MOMENTS

            function stringGet(units) {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units]();
                }
                return this;
            }

            function stringSet(units, value) {
                if (typeof units === 'object') {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units);
                    for (var i = 0; i < prioritized.length; i++) {
                        this[prioritized[i].unit](units[prioritized[i].unit]);
                    }
                } else {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units](value);
                    }
                }
                return this;
            }

            function zeroFill(number, targetLength, forceSign) {
                var absNumber = '' + Math.abs(number),
                    zerosToFill = targetLength - absNumber.length,
                    sign = number >= 0;
                return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
            }

            var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

            var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

            var formatFunctions = {};

            var formatTokenFunctions = {};

            // token:    'M'
            // padded:   ['MM', 2]
            // ordinal:  'Mo'
            // callback: function () { this.month() + 1 }
            function addFormatToken(token, padded, ordinal, callback) {
                var func = callback;
                if (typeof callback === 'string') {
                    func = function () {
                        return this[callback]();
                    };
                }
                if (token) {
                    formatTokenFunctions[token] = func;
                }
                if (padded) {
                    formatTokenFunctions[padded[0]] = function () {
                        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                }
                if (ordinal) {
                    formatTokenFunctions[ordinal] = function () {
                        return this.localeData().ordinal(func.apply(this, arguments), token);
                    };
                }
            }

            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, '');
                }
                return input.replace(/\\/g, '');
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens),
                    i,
                    length;

                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]];
                    } else {
                        array[i] = removeFormattingTokens(array[i]);
                    }
                }

                return function (mom) {
                    var output = '',
                        i;
                    for (i = 0; i < length; i++) {
                        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                    }
                    return output;
                };
            }

            // format date using native date object
            function formatMoment(m, format) {
                if (!m.isValid()) {
                    return m.localeData().invalidDate();
                }

                format = expandFormat(format, m.localeData());
                formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

                return formatFunctions[format](m);
            }

            function expandFormat(format, locale) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return locale.longDateFormat(input) || input;
                }

                localFormattingTokens.lastIndex = 0;
                while (i >= 0 && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                }

                return format;
            }

            var match1 = /\d/; //       0 - 9
            var match2 = /\d\d/; //      00 - 99
            var match3 = /\d{3}/; //     000 - 999
            var match4 = /\d{4}/; //    0000 - 9999
            var match6 = /[+-]?\d{6}/; // -999999 - 999999
            var match1to2 = /\d\d?/; //       0 - 99
            var match3to4 = /\d\d\d\d?/; //     999 - 9999
            var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
            var match1to3 = /\d{1,3}/; //       0 - 999
            var match1to4 = /\d{1,4}/; //       0 - 9999
            var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

            var matchUnsigned = /\d+/; //       0 - inf
            var matchSigned = /[+-]?\d+/; //    -inf - inf

            var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
            var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

            var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

            var regexes = {};

            function addRegexToken(token, regex, strictRegex) {
                regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
            }

            function getParseRegexForToken(token, config) {
                if (!hasOwnProp(regexes, token)) {
                    return new RegExp(unescapeFormat(token));
                }

                return regexes[token](config._strict, config._locale);
            }

            // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
            function unescapeFormat(s) {
                return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                }));
            }

            function regexEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            }

            var tokens = {};

            function addParseToken(token, callback) {
                var i,
                    func = callback;
                if (typeof token === 'string') {
                    token = [token];
                }
                if (typeof callback === 'number') {
                    func = function (input, array) {
                        array[callback] = toInt(input);
                    };
                }
                for (i = 0; i < token.length; i++) {
                    tokens[token[i]] = func;
                }
            }

            function addWeekParseToken(token, callback) {
                addParseToken(token, function (input, array, config, token) {
                    config._w = config._w || {};
                    callback(input, config._w, config, token);
                });
            }

            function addTimeToArrayFromToken(token, input, config) {
                if (input != null && hasOwnProp(tokens, token)) {
                    tokens[token](input, config._a, config, token);
                }
            }

            var YEAR = 0;
            var MONTH = 1;
            var DATE = 2;
            var HOUR = 3;
            var MINUTE = 4;
            var SECOND = 5;
            var MILLISECOND = 6;
            var WEEK = 7;
            var WEEKDAY = 8;

            var indexOf;

            if (Array.prototype.indexOf) {
                indexOf = Array.prototype.indexOf;
            } else {
                indexOf = function (o) {
                    // I know
                    var i;
                    for (i = 0; i < this.length; ++i) {
                        if (this[i] === o) {
                            return i;
                        }
                    }
                    return -1;
                };
            }

            function daysInMonth(year, month) {
                return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
            }

            // FORMATTING

            addFormatToken('M', ['MM', 2], 'Mo', function () {
                return this.month() + 1;
            });

            addFormatToken('MMM', 0, 0, function (format) {
                return this.localeData().monthsShort(this, format);
            });

            addFormatToken('MMMM', 0, 0, function (format) {
                return this.localeData().months(this, format);
            });

            // ALIASES

            addUnitAlias('month', 'M');

            // PRIORITY

            addUnitPriority('month', 8);

            // PARSING

            addRegexToken('M', match1to2);
            addRegexToken('MM', match1to2, match2);
            addRegexToken('MMM', function (isStrict, locale) {
                return locale.monthsShortRegex(isStrict);
            });
            addRegexToken('MMMM', function (isStrict, locale) {
                return locale.monthsRegex(isStrict);
            });

            addParseToken(['M', 'MM'], function (input, array) {
                array[MONTH] = toInt(input) - 1;
            });

            addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
                var month = config._locale.monthsParse(input, token, config._strict);
                // if we didn't find a month name, mark the date as invalid.
                if (month != null) {
                    array[MONTH] = month;
                } else {
                    getParsingFlags(config).invalidMonth = input;
                }
            });

            // LOCALES

            var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
            var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
            function localeMonths(m, format) {
                if (!m) {
                    return this._months;
                }
                return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
            }

            var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
            function localeMonthsShort(m, format) {
                if (!m) {
                    return this._monthsShort;
                }
                return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
            }

            function units_month__handleStrictParse(monthName, format, strict) {
                var i,
                    ii,
                    mom,
                    llc = monthName.toLocaleLowerCase();
                if (!this._monthsParse) {
                    // this is not used
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i = 0; i < 12; ++i) {
                        mom = create_utc__createUTC([2000, i]);
                        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeMonthsParse(monthName, format, strict) {
                var i, mom, regex;

                if (this._monthsParseExact) {
                    return units_month__handleStrictParse.call(this, monthName, format, strict);
                }

                if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                }

                // TODO: add sorting
                // Sorting makes sure if one month (or abbr) is a prefix of another
                // see sorting in computeMonthsParse
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, i]);
                    if (strict && !this._longMonthsParse[i]) {
                        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                    }
                    if (!strict && !this._monthsParse[i]) {
                        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (!strict && this._monthsParse[i].test(monthName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function setMonth(mom, value) {
                var dayOfMonth;

                if (!mom.isValid()) {
                    // No op
                    return mom;
                }

                if (typeof value === 'string') {
                    if (/^\d+$/.test(value)) {
                        value = toInt(value);
                    } else {
                        value = mom.localeData().monthsParse(value);
                        // TODO: Another silent failure?
                        if (typeof value !== 'number') {
                            return mom;
                        }
                    }
                }

                dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                return mom;
            }

            function getSetMonth(value) {
                if (value != null) {
                    setMonth(this, value);
                    utils_hooks__hooks.updateOffset(this, true);
                    return this;
                } else {
                    return get_set__get(this, 'Month');
                }
            }

            function getDaysInMonth() {
                return daysInMonth(this.year(), this.month());
            }

            var defaultMonthsShortRegex = matchWord;
            function monthsShortRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsShortStrictRegex;
                    } else {
                        return this._monthsShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsShortRegex')) {
                        this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                }
            }

            var defaultMonthsRegex = matchWord;
            function monthsRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsStrictRegex;
                    } else {
                        return this._monthsRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                }
            }

            function computeMonthsParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i,
                    mom;
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, i]);
                    shortPieces.push(this.monthsShort(mom, ''));
                    longPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.monthsShort(mom, ''));
                }
                // Sorting makes sure if one month (or abbr) is a prefix of another it
                // will match the longer piece.
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 12; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                }
                for (i = 0; i < 24; i++) {
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._monthsShortRegex = this._monthsRegex;
                this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
            }

            // FORMATTING

            addFormatToken('Y', 0, 0, function () {
                var y = this.year();
                return y <= 9999 ? '' + y : '+' + y;
            });

            addFormatToken(0, ['YY', 2], 0, function () {
                return this.year() % 100;
            });

            addFormatToken(0, ['YYYY', 4], 0, 'year');
            addFormatToken(0, ['YYYYY', 5], 0, 'year');
            addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

            // ALIASES

            addUnitAlias('year', 'y');

            // PRIORITIES

            addUnitPriority('year', 1);

            // PARSING

            addRegexToken('Y', matchSigned);
            addRegexToken('YY', match1to2, match2);
            addRegexToken('YYYY', match1to4, match4);
            addRegexToken('YYYYY', match1to6, match6);
            addRegexToken('YYYYYY', match1to6, match6);

            addParseToken(['YYYYY', 'YYYYYY'], YEAR);
            addParseToken('YYYY', function (input, array) {
                array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
            });
            addParseToken('YY', function (input, array) {
                array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
            });
            addParseToken('Y', function (input, array) {
                array[YEAR] = parseInt(input, 10);
            });

            // HELPERS

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }

            function isLeapYear(year) {
                return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
            }

            // HOOKS

            utils_hooks__hooks.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            };

            // MOMENTS

            var getSetYear = makeGetSet('FullYear', true);

            function getIsLeapYear() {
                return isLeapYear(this.year());
            }

            function createDate(y, m, d, h, M, s, ms) {
                //can't just apply() to create a date:
                //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
                var date = new Date(y, m, d, h, M, s, ms);

                //the date constructor remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
                return date;
            }

            function createUTCDate(y) {
                var date = new Date(Date.UTC.apply(null, arguments));

                //the Date.UTC function remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
                return date;
            }

            // start-of-first-week - start-of-year
            function firstWeekOffset(year, dow, doy) {
                var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,

                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

                return -fwdlw + fwd - 1;
            }

            //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
            function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                var localWeekday = (7 + weekday - dow) % 7,
                    weekOffset = firstWeekOffset(year, dow, doy),
                    dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                    resYear,
                    resDayOfYear;

                if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                }

                return {
                    year: resYear,
                    dayOfYear: resDayOfYear
                };
            }

            function weekOfYear(mom, dow, doy) {
                var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                    resWeek,
                    resYear;

                if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                } else {
                    resYear = mom.year();
                    resWeek = week;
                }

                return {
                    week: resWeek,
                    year: resYear
                };
            }

            function weeksInYear(year, dow, doy) {
                var weekOffset = firstWeekOffset(year, dow, doy),
                    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
            }

            // FORMATTING

            addFormatToken('w', ['ww', 2], 'wo', 'week');
            addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

            // ALIASES

            addUnitAlias('week', 'w');
            addUnitAlias('isoWeek', 'W');

            // PRIORITIES

            addUnitPriority('week', 5);
            addUnitPriority('isoWeek', 5);

            // PARSING

            addRegexToken('w', match1to2);
            addRegexToken('ww', match1to2, match2);
            addRegexToken('W', match1to2);
            addRegexToken('WW', match1to2, match2);

            addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
                week[token.substr(0, 1)] = toInt(input);
            });

            // HELPERS

            // LOCALES

            function localeWeek(mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week;
            }

            var defaultLocaleWeek = {
                dow: 0, // Sunday is the first day of the week.
                doy: 6 // The week that contains Jan 1st is the first week of the year.
            };

            function localeFirstDayOfWeek() {
                return this._week.dow;
            }

            function localeFirstDayOfYear() {
                return this._week.doy;
            }

            // MOMENTS

            function getSetWeek(input) {
                var week = this.localeData().week(this);
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            function getSetISOWeek(input) {
                var week = weekOfYear(this, 1, 4).week;
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            // FORMATTING

            addFormatToken('d', 0, 'do', 'day');

            addFormatToken('dd', 0, 0, function (format) {
                return this.localeData().weekdaysMin(this, format);
            });

            addFormatToken('ddd', 0, 0, function (format) {
                return this.localeData().weekdaysShort(this, format);
            });

            addFormatToken('dddd', 0, 0, function (format) {
                return this.localeData().weekdays(this, format);
            });

            addFormatToken('e', 0, 0, 'weekday');
            addFormatToken('E', 0, 0, 'isoWeekday');

            // ALIASES

            addUnitAlias('day', 'd');
            addUnitAlias('weekday', 'e');
            addUnitAlias('isoWeekday', 'E');

            // PRIORITY
            addUnitPriority('day', 11);
            addUnitPriority('weekday', 11);
            addUnitPriority('isoWeekday', 11);

            // PARSING

            addRegexToken('d', match1to2);
            addRegexToken('e', match1to2);
            addRegexToken('E', match1to2);
            addRegexToken('dd', function (isStrict, locale) {
                return locale.weekdaysMinRegex(isStrict);
            });
            addRegexToken('ddd', function (isStrict, locale) {
                return locale.weekdaysShortRegex(isStrict);
            });
            addRegexToken('dddd', function (isStrict, locale) {
                return locale.weekdaysRegex(isStrict);
            });

            addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
                var weekday = config._locale.weekdaysParse(input, token, config._strict);
                // if we didn't get a weekday name, mark the date as invalid
                if (weekday != null) {
                    week.d = weekday;
                } else {
                    getParsingFlags(config).invalidWeekday = input;
                }
            });

            addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
                week[token] = toInt(input);
            });

            // HELPERS

            function parseWeekday(input, locale) {
                if (typeof input !== 'string') {
                    return input;
                }

                if (!isNaN(input)) {
                    return parseInt(input, 10);
                }

                input = locale.weekdaysParse(input);
                if (typeof input === 'number') {
                    return input;
                }

                return null;
            }

            function parseIsoWeekday(input, locale) {
                if (typeof input === 'string') {
                    return locale.weekdaysParse(input) % 7 || 7;
                }
                return isNaN(input) ? null : input;
            }

            // LOCALES

            var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
            function localeWeekdays(m, format) {
                if (!m) {
                    return this._weekdays;
                }
                return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
            }

            var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
            function localeWeekdaysShort(m) {
                return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
            }

            var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
            function localeWeekdaysMin(m) {
                return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
            }

            function day_of_week__handleStrictParse(weekdayName, format, strict) {
                var i,
                    ii,
                    mom,
                    llc = weekdayName.toLocaleLowerCase();
                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];

                    for (i = 0; i < 7; ++i) {
                        mom = create_utc__createUTC([2000, 1]).day(i);
                        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeWeekdaysParse(weekdayName, format, strict) {
                var i, mom, regex;

                if (this._weekdaysParseExact) {
                    return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
                }

                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                }

                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already

                    mom = create_utc__createUTC([2000, 1]).day(i);
                    if (strict && !this._fullWeekdaysParse[i]) {
                        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
                    }
                    if (!this._weekdaysParse[i]) {
                        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function getSetDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, 'd');
                } else {
                    return day;
                }
            }

            function getSetLocaleDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return input == null ? weekday : this.add(input - weekday, 'd');
            }

            function getSetISODayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }

                // behaves the same as moment#day except
                // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                // as a setter, sunday should belong to the previous week.

                if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                } else {
                    return this.day() || 7;
                }
            }

            var defaultWeekdaysRegex = matchWord;
            function weekdaysRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysStrictRegex;
                    } else {
                        return this._weekdaysRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                }
            }

            var defaultWeekdaysShortRegex = matchWord;
            function weekdaysShortRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysShortStrictRegex;
                    } else {
                        return this._weekdaysShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                }
            }

            var defaultWeekdaysMinRegex = matchWord;
            function weekdaysMinRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysMinStrictRegex;
                    } else {
                        return this._weekdaysMinRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                }
            }

            function computeWeekdaysParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var minPieces = [],
                    shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i,
                    mom,
                    minp,
                    shortp,
                    longp;
                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, 1]).day(i);
                    minp = this.weekdaysMin(mom, '');
                    shortp = this.weekdaysShort(mom, '');
                    longp = this.weekdays(mom, '');
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                }
                // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                // will match the longer piece.
                minPieces.sort(cmpLenRev);
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 7; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._weekdaysShortRegex = this._weekdaysRegex;
                this._weekdaysMinRegex = this._weekdaysRegex;

                this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
            }

            // FORMATTING

            function hFormat() {
                return this.hours() % 12 || 12;
            }

            function kFormat() {
                return this.hours() || 24;
            }

            addFormatToken('H', ['HH', 2], 0, 'hour');
            addFormatToken('h', ['hh', 2], 0, hFormat);
            addFormatToken('k', ['kk', 2], 0, kFormat);

            addFormatToken('hmm', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
            });

            addFormatToken('hmmss', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
            });

            addFormatToken('Hmm', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2);
            });

            addFormatToken('Hmmss', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
            });

            function meridiem(token, lowercase) {
                addFormatToken(token, 0, 0, function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                });
            }

            meridiem('a', true);
            meridiem('A', false);

            // ALIASES

            addUnitAlias('hour', 'h');

            // PRIORITY
            addUnitPriority('hour', 13);

            // PARSING

            function matchMeridiem(isStrict, locale) {
                return locale._meridiemParse;
            }

            addRegexToken('a', matchMeridiem);
            addRegexToken('A', matchMeridiem);
            addRegexToken('H', match1to2);
            addRegexToken('h', match1to2);
            addRegexToken('HH', match1to2, match2);
            addRegexToken('hh', match1to2, match2);

            addRegexToken('hmm', match3to4);
            addRegexToken('hmmss', match5to6);
            addRegexToken('Hmm', match3to4);
            addRegexToken('Hmmss', match5to6);

            addParseToken(['H', 'HH'], HOUR);
            addParseToken(['a', 'A'], function (input, array, config) {
                config._isPm = config._locale.isPM(input);
                config._meridiem = input;
            });
            addParseToken(['h', 'hh'], function (input, array, config) {
                array[HOUR] = toInt(input);
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('Hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
            });
            addParseToken('Hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
            });

            // LOCALES

            function localeIsPM(input) {
                // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                // Using charAt should be more compatible.
                return (input + '').toLowerCase().charAt(0) === 'p';
            }

            var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
            function localeMeridiem(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'pm' : 'PM';
                } else {
                    return isLower ? 'am' : 'AM';
                }
            }

            // MOMENTS

            // Setting the hour should keep the time, because the user explicitly
            // specified which hour he wants. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            var getSetHour = makeGetSet('Hours', true);

            var baseConfig = {
                calendar: defaultCalendar,
                longDateFormat: defaultLongDateFormat,
                invalidDate: defaultInvalidDate,
                ordinal: defaultOrdinal,
                ordinalParse: defaultOrdinalParse,
                relativeTime: defaultRelativeTime,

                months: defaultLocaleMonths,
                monthsShort: defaultLocaleMonthsShort,

                week: defaultLocaleWeek,

                weekdays: defaultLocaleWeekdays,
                weekdaysMin: defaultLocaleWeekdaysMin,
                weekdaysShort: defaultLocaleWeekdaysShort,

                meridiemParse: defaultLocaleMeridiemParse
            };

            // internal storage for locale config files
            var locales = {};
            var globalLocale;

            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace('_', '-') : key;
            }

            // pick the locale from the array
            // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
            // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
            function chooseLocale(names) {
                var i = 0,
                    j,
                    next,
                    locale,
                    split;

                while (i < names.length) {
                    split = normalizeLocale(names[i]).split('-');
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split('-') : null;
                    while (j > 0) {
                        locale = loadLocale(split.slice(0, j).join('-'));
                        if (locale) {
                            return locale;
                        }
                        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                            //the next array item is better than a shallower substring of this one
                            break;
                        }
                        j--;
                    }
                    i++;
                }
                return null;
            }

            function loadLocale(name) {
                var oldLocale = null;
                // TODO: Find a better way to register and load all the locales in Node
                if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
                    try {
                        oldLocale = globalLocale._abbr;
                        require('./locale/' + name);
                        // because defineLocale currently also sets the global locale, we
                        // want to undo that for lazy loaded locales
                        locale_locales__getSetGlobalLocale(oldLocale);
                    } catch (e) {}
                }
                return locales[name];
            }

            // This function will load locale and then set the global locale.  If
            // no arguments are passed in, it will simply return the current global
            // locale key.
            function locale_locales__getSetGlobalLocale(key, values) {
                var data;
                if (key) {
                    if (isUndefined(values)) {
                        data = locale_locales__getLocale(key);
                    } else {
                        data = defineLocale(key, values);
                    }

                    if (data) {
                        // moment.duration._locale = moment._locale = data;
                        globalLocale = data;
                    }
                }

                return globalLocale._abbr;
            }

            function defineLocale(name, config) {
                if (config !== null) {
                    var parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                        parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                        if (locales[config.parentLocale] != null) {
                            parentConfig = locales[config.parentLocale]._config;
                        } else {
                            // treat as if there is no base config
                            deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                        }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));

                    // backwards compat for now: also set the locale
                    locale_locales__getSetGlobalLocale(name);

                    return locales[name];
                } else {
                    // useful for testing
                    delete locales[name];
                    return null;
                }
            }

            function updateLocale(name, config) {
                if (config != null) {
                    var locale,
                        parentConfig = baseConfig;
                    // MERGE
                    if (locales[name] != null) {
                        parentConfig = locales[name]._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;

                    // backwards compat for now: also set the locale
                    locale_locales__getSetGlobalLocale(name);
                } else {
                    // pass null for config to unupdate, useful for tests
                    if (locales[name] != null) {
                        if (locales[name].parentLocale != null) {
                            locales[name] = locales[name].parentLocale;
                        } else if (locales[name] != null) {
                            delete locales[name];
                        }
                    }
                }
                return locales[name];
            }

            // returns locale data
            function locale_locales__getLocale(key) {
                var locale;

                if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                }

                if (!key) {
                    return globalLocale;
                }

                if (!isArray(key)) {
                    //short-circuit everything else
                    locale = loadLocale(key);
                    if (locale) {
                        return locale;
                    }
                    key = [key];
                }

                return chooseLocale(key);
            }

            function locale_locales__listLocales() {
                return keys(locales);
            }

            function checkOverflow(m) {
                var overflow;
                var a = m._a;

                if (a && getParsingFlags(m).overflow === -2) {
                    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

                    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                        overflow = DATE;
                    }
                    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                        overflow = WEEK;
                    }
                    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                        overflow = WEEKDAY;
                    }

                    getParsingFlags(m).overflow = overflow;
                }

                return m;
            }

            // iso 8601 regex
            // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
            var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
            var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

            var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

            var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
            // YYYYMM is NOT allowed by the standard
            ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

            // iso time formats and regexes
            var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

            var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

            // date from iso format
            function configFromISO(config) {
                var i,
                    l,
                    string = config._i,
                    match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                    allowTime,
                    dateFormat,
                    timeFormat,
                    tzFormat;

                if (match) {
                    getParsingFlags(config).iso = true;

                    for (i = 0, l = isoDates.length; i < l; i++) {
                        if (isoDates[i][1].exec(match[1])) {
                            dateFormat = isoDates[i][0];
                            allowTime = isoDates[i][2] !== false;
                            break;
                        }
                    }
                    if (dateFormat == null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[3]) {
                        for (i = 0, l = isoTimes.length; i < l; i++) {
                            if (isoTimes[i][1].exec(match[3])) {
                                // match[2] should be 'T' or space
                                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                                break;
                            }
                        }
                        if (timeFormat == null) {
                            config._isValid = false;
                            return;
                        }
                    }
                    if (!allowTime && timeFormat != null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[4]) {
                        if (tzRegex.exec(match[4])) {
                            tzFormat = 'Z';
                        } else {
                            config._isValid = false;
                            return;
                        }
                    }
                    config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                    configFromStringAndFormat(config);
                } else {
                    config._isValid = false;
                }
            }

            // date from iso format or fallback
            function configFromString(config) {
                var matched = aspNetJsonRegex.exec(config._i);

                if (matched !== null) {
                    config._d = new Date(+matched[1]);
                    return;
                }

                configFromISO(config);
                if (config._isValid === false) {
                    delete config._isValid;
                    utils_hooks__hooks.createFromInputFallback(config);
                }
            }

            utils_hooks__hooks.createFromInputFallback = deprecate('value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            });

            // Pick the first defined of two or three arguments.
            function defaults(a, b, c) {
                if (a != null) {
                    return a;
                }
                if (b != null) {
                    return b;
                }
                return c;
            }

            function currentDateArray(config) {
                // hooks is actually the exported moment object
                var nowValue = new Date(utils_hooks__hooks.now());
                if (config._useUTC) {
                    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                }
                return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
            }

            // convert an array to a date.
            // the array should mirror the parameters below
            // note: all values past the year are optional and will default to the lowest possible value.
            // [year, month, day , hour, minute, second, millisecond]
            function configFromArray(config) {
                var i,
                    date,
                    input = [],
                    currentDate,
                    yearToUse;

                if (config._d) {
                    return;
                }

                currentDate = currentDateArray(config);

                //compute day of the year from weeks and weekdays
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                }

                //if the day of the year is set, figure out what it is
                if (config._dayOfYear) {
                    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                    if (config._dayOfYear > daysInYear(yearToUse)) {
                        getParsingFlags(config)._overflowDayOfYear = true;
                    }

                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                }

                // Default to current date.
                // * if no year, month, day of month are given, default to today
                // * if day of month is given, default month and year
                // * if month is given, default only year
                // * if year is given, don't default anything
                for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                }

                // Zero out whatever was not defaulted, including time
                for (; i < 7; i++) {
                    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
                }

                // Check for 24:00:00.000
                if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                }

                config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                // Apply timezone offset from input. The actual utcOffset can be changed
                // with parseZone.
                if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                }

                if (config._nextDay) {
                    config._a[HOUR] = 24;
                }
            }

            function dayOfYearFromWeekInfo(config) {
                var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

                w = config._w;
                if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;

                    // TODO: We need to take the current isoWeekYear, but that depends on
                    // how we interpret now (local, utc, fixed offset). So create
                    // a now version of current config (take local/utc/offset flags, and
                    // create now).
                    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
                    week = defaults(w.W, 1);
                    weekday = defaults(w.E, 1);
                    if (weekday < 1 || weekday > 7) {
                        weekdayOverflow = true;
                    }
                } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;

                    weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
                    week = defaults(w.w, 1);

                    if (w.d != null) {
                        // weekday -- low day numbers are considered next week
                        weekday = w.d;
                        if (weekday < 0 || weekday > 6) {
                            weekdayOverflow = true;
                        }
                    } else if (w.e != null) {
                        // local weekday -- counting starts from begining of week
                        weekday = w.e + dow;
                        if (w.e < 0 || w.e > 6) {
                            weekdayOverflow = true;
                        }
                    } else {
                        // default to begining of week
                        weekday = dow;
                    }
                }
                if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }
            }

            // constant that refers to the ISO standard
            utils_hooks__hooks.ISO_8601 = function () {};

            // date from string and format string
            function configFromStringAndFormat(config) {
                // TODO: Move this to another part of the creation flow to prevent circular deps
                if (config._f === utils_hooks__hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                }

                config._a = [];
                getParsingFlags(config).empty = true;

                // This array is used to make a Date, either with `new Date` or `Date.UTC`
                var string = '' + config._i,
                    i,
                    parsedInput,
                    tokens,
                    token,
                    skipped,
                    stringLength = string.length,
                    totalParsedInputLength = 0;

                tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                    // console.log('token', token, 'parsedInput', parsedInput,
                    //         'regex', getParseRegexForToken(token, config));
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            getParsingFlags(config).unusedInput.push(skipped);
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length;
                    }
                    // don't parse if it's not a known token
                    if (formatTokenFunctions[token]) {
                        if (parsedInput) {
                            getParsingFlags(config).empty = false;
                        } else {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                        addTimeToArrayFromToken(token, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                }

                // add remaining unparsed input length to the string
                getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                }

                // clear _12h flag if hour is <= 12
                if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
                    getParsingFlags(config).bigHour = undefined;
                }

                getParsingFlags(config).parsedDateParts = config._a.slice(0);
                getParsingFlags(config).meridiem = config._meridiem;
                // handle meridiem
                config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

                configFromArray(config);
                checkOverflow(config);
            }

            function meridiemFixWrap(locale, hour, meridiem) {
                var isPm;

                if (meridiem == null) {
                    // nothing to do
                    return hour;
                }
                if (locale.meridiemHour != null) {
                    return locale.meridiemHour(hour, meridiem);
                } else if (locale.isPM != null) {
                    // Fallback
                    isPm = locale.isPM(meridiem);
                    if (isPm && hour < 12) {
                        hour += 12;
                    }
                    if (!isPm && hour === 12) {
                        hour = 0;
                    }
                    return hour;
                } else {
                    // this is not supposed to happen
                    return hour;
                }
            }

            // date from string and array of format strings
            function configFromStringAndArray(config) {
                var tempConfig, bestMoment, scoreToBeat, i, currentScore;

                if (config._f.length === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = new Date(NaN);
                    return;
                }

                for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                        tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i];
                    configFromStringAndFormat(tempConfig);

                    if (!valid__isValid(tempConfig)) {
                        continue;
                    }

                    // if there is any input that was not parsed add a penalty for that format
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;

                    //or tokens
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                    getParsingFlags(tempConfig).score = currentScore;

                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }

                extend(config, bestMoment || tempConfig);
            }

            function configFromObject(config) {
                if (config._d) {
                    return;
                }

                var i = normalizeObjectUnits(config._i);
                config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                    return obj && parseInt(obj, 10);
                });

                configFromArray(config);
            }

            function createFromConfig(config) {
                var res = new Moment(checkOverflow(prepareConfig(config)));
                if (res._nextDay) {
                    // Adding is smart enough around DST
                    res.add(1, 'd');
                    res._nextDay = undefined;
                }

                return res;
            }

            function prepareConfig(config) {
                var input = config._i,
                    format = config._f;

                config._locale = config._locale || locale_locales__getLocale(config._l);

                if (input === null || format === undefined && input === '') {
                    return valid__createInvalid({ nullInput: true });
                }

                if (typeof input === 'string') {
                    config._i = input = config._locale.preparse(input);
                }

                if (isMoment(input)) {
                    return new Moment(checkOverflow(input));
                } else if (isArray(format)) {
                    configFromStringAndArray(config);
                } else if (isDate(input)) {
                    config._d = input;
                } else if (format) {
                    configFromStringAndFormat(config);
                } else {
                    configFromInput(config);
                }

                if (!valid__isValid(config)) {
                    config._d = null;
                }

                return config;
            }

            function configFromInput(config) {
                var input = config._i;
                if (input === undefined) {
                    config._d = new Date(utils_hooks__hooks.now());
                } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                } else if (typeof input === 'string') {
                    configFromString(config);
                } else if (isArray(input)) {
                    config._a = map(input.slice(0), function (obj) {
                        return parseInt(obj, 10);
                    });
                    configFromArray(config);
                } else if (typeof input === 'object') {
                    configFromObject(config);
                } else if (typeof input === 'number') {
                    // from milliseconds
                    config._d = new Date(input);
                } else {
                    utils_hooks__hooks.createFromInputFallback(config);
                }
            }

            function createLocalOrUTC(input, format, locale, strict, isUTC) {
                var c = {};

                if (typeof locale === 'boolean') {
                    strict = locale;
                    locale = undefined;
                }

                if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
                    input = undefined;
                }
                // object construction must be done this way.
                // https://github.com/moment/moment/issues/1423
                c._isAMomentObject = true;
                c._useUTC = c._isUTC = isUTC;
                c._l = locale;
                c._i = input;
                c._f = format;
                c._strict = strict;

                return createFromConfig(c);
            }

            function local__createLocal(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, false);
            }

            var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
                var other = local__createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return valid__createInvalid();
                }
            });

            var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
                var other = local__createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return valid__createInvalid();
                }
            });

            // Pick a moment m from moments so that m[fn](other) is true for all
            // other. This relies on the function fn to be transitive.
            //
            // moments should either be an array of moment objects or an array, whose
            // first element is an array of moment objects.
            function pickBy(fn, moments) {
                var res, i;
                if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0];
                }
                if (!moments.length) {
                    return local__createLocal();
                }
                res = moments[0];
                for (i = 1; i < moments.length; ++i) {
                    if (!moments[i].isValid() || moments[i][fn](res)) {
                        res = moments[i];
                    }
                }
                return res;
            }

            // TODO: Use [].sort instead?
            function min() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isBefore', args);
            }

            function max() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isAfter', args);
            }

            var now = function () {
                return Date.now ? Date.now() : +new Date();
            };

            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                    years = normalizedInput.year || 0,
                    quarters = normalizedInput.quarter || 0,
                    months = normalizedInput.month || 0,
                    weeks = normalizedInput.week || 0,
                    days = normalizedInput.day || 0,
                    hours = normalizedInput.hour || 0,
                    minutes = normalizedInput.minute || 0,
                    seconds = normalizedInput.second || 0,
                    milliseconds = normalizedInput.millisecond || 0;

                // representation for dateAddRemove
                this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                // Because of dateAddRemove treats 24 hours as different from a
                // day when working around DST, we need to store them separately
                this._days = +days + weeks * 7;
                // It is impossible translate months into days without knowing
                // which months you are are talking about, so we have to store
                // it separately.
                this._months = +months + quarters * 3 + years * 12;

                this._data = {};

                this._locale = locale_locales__getLocale();

                this._bubble();
            }

            function isDuration(obj) {
                return obj instanceof Duration;
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.round(-1 * number) * -1;
                } else {
                    return Math.round(number);
                }
            }

            // FORMATTING

            function offset(token, separator) {
                addFormatToken(token, 0, 0, function () {
                    var offset = this.utcOffset();
                    var sign = '+';
                    if (offset < 0) {
                        offset = -offset;
                        sign = '-';
                    }
                    return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
                });
            }

            offset('Z', ':');
            offset('ZZ', '');

            // PARSING

            addRegexToken('Z', matchShortOffset);
            addRegexToken('ZZ', matchShortOffset);
            addParseToken(['Z', 'ZZ'], function (input, array, config) {
                config._useUTC = true;
                config._tzm = offsetFromString(matchShortOffset, input);
            });

            // HELPERS

            // timezone chunker
            // '+10:00' > ['10',  '00']
            // '-1530'  > ['-15', '30']
            var chunkOffset = /([\+\-]|\d\d)/gi;

            function offsetFromString(matcher, string) {
                var matches = (string || '').match(matcher) || [];
                var chunk = matches[matches.length - 1] || [];
                var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
                var minutes = +(parts[1] * 60) + toInt(parts[2]);

                return parts[0] === '+' ? minutes : -minutes;
            }

            // Return a moment from input, that is local/utc/zone equivalent to model.
            function cloneWithOffset(input, model) {
                var res, diff;
                if (model._isUTC) {
                    res = model.clone();
                    diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
                    // Use low-level api, because this fn is low-level api.
                    res._d.setTime(res._d.valueOf() + diff);
                    utils_hooks__hooks.updateOffset(res, false);
                    return res;
                } else {
                    return local__createLocal(input).local();
                }
            }

            function getDateOffset(m) {
                // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                // https://github.com/moment/moment/pull/1871
                return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
            }

            // HOOKS

            // This function will be called whenever a moment is mutated.
            // It is intended to keep the offset in sync with the timezone.
            utils_hooks__hooks.updateOffset = function () {};

            // MOMENTS

            // keepLocalTime = true means only change the timezone, without
            // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
            // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
            // +0200, so we adjust the time as needed, to be valid.
            //
            // Keeping the time actually adds/subtracts (one hour)
            // from the actual represented time. That is why we call updateOffset
            // a second time. In case it wants us to change the offset again
            // _changeInProgress == true case, then we have to adjust, because
            // there is no such time in the given timezone.
            function getSetOffset(input, keepLocalTime) {
                var offset = this._offset || 0,
                    localAdjust;
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                if (input != null) {
                    if (typeof input === 'string') {
                        input = offsetFromString(matchShortOffset, input);
                    } else if (Math.abs(input) < 16) {
                        input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                        localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                        this.add(localAdjust, 'm');
                    }
                    if (offset !== input) {
                        if (!keepLocalTime || this._changeInProgress) {
                            add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                        } else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            utils_hooks__hooks.updateOffset(this, true);
                            this._changeInProgress = null;
                        }
                    }
                    return this;
                } else {
                    return this._isUTC ? offset : getDateOffset(this);
                }
            }

            function getSetZone(input, keepLocalTime) {
                if (input != null) {
                    if (typeof input !== 'string') {
                        input = -input;
                    }

                    this.utcOffset(input, keepLocalTime);

                    return this;
                } else {
                    return -this.utcOffset();
                }
            }

            function setOffsetToUTC(keepLocalTime) {
                return this.utcOffset(0, keepLocalTime);
            }

            function setOffsetToLocal(keepLocalTime) {
                if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;

                    if (keepLocalTime) {
                        this.subtract(getDateOffset(this), 'm');
                    }
                }
                return this;
            }

            function setOffsetToParsedOffset() {
                if (this._tzm) {
                    this.utcOffset(this._tzm);
                } else if (typeof this._i === 'string') {
                    var tZone = offsetFromString(matchOffset, this._i);

                    if (tZone === 0) {
                        this.utcOffset(0, true);
                    } else {
                        this.utcOffset(offsetFromString(matchOffset, this._i));
                    }
                }
                return this;
            }

            function hasAlignedHourOffset(input) {
                if (!this.isValid()) {
                    return false;
                }
                input = input ? local__createLocal(input).utcOffset() : 0;

                return (this.utcOffset() - input) % 60 === 0;
            }

            function isDaylightSavingTime() {
                return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
            }

            function isDaylightSavingTimeShifted() {
                if (!isUndefined(this._isDSTShifted)) {
                    return this._isDSTShifted;
                }

                var c = {};

                copyConfig(c, this);
                c = prepareConfig(c);

                if (c._a) {
                    var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
                    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                } else {
                    this._isDSTShifted = false;
                }

                return this._isDSTShifted;
            }

            function isLocal() {
                return this.isValid() ? !this._isUTC : false;
            }

            function isUtcOffset() {
                return this.isValid() ? this._isUTC : false;
            }

            function isUtc() {
                return this.isValid() ? this._isUTC && this._offset === 0 : false;
            }

            // ASP.NET json date format regex
            var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

            function create__createDuration(input, key) {
                var duration = input,

                // matching against regexp is expensive, do it on demand
                match = null,
                    sign,
                    ret,
                    diffRes;

                if (isDuration(input)) {
                    duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months
                    };
                } else if (typeof input === 'number') {
                    duration = {};
                    if (key) {
                        duration[key] = input;
                    } else {
                        duration.milliseconds = input;
                    }
                } else if (!!(match = aspNetRegex.exec(input))) {
                    sign = match[1] === '-' ? -1 : 1;
                    duration = {
                        y: 0,
                        d: toInt(match[DATE]) * sign,
                        h: toInt(match[HOUR]) * sign,
                        m: toInt(match[MINUTE]) * sign,
                        s: toInt(match[SECOND]) * sign,
                        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                    };
                } else if (!!(match = isoRegex.exec(input))) {
                    sign = match[1] === '-' ? -1 : 1;
                    duration = {
                        y: parseIso(match[2], sign),
                        M: parseIso(match[3], sign),
                        w: parseIso(match[4], sign),
                        d: parseIso(match[5], sign),
                        h: parseIso(match[6], sign),
                        m: parseIso(match[7], sign),
                        s: parseIso(match[8], sign)
                    };
                } else if (duration == null) {
                    // checks for null or undefined
                    duration = {};
                } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                    diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                }

                ret = new Duration(duration);

                if (isDuration(input) && hasOwnProp(input, '_locale')) {
                    ret._locale = input._locale;
                }

                return ret;
            }

            create__createDuration.fn = Duration.prototype;

            function parseIso(inp, sign) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            }

            function positiveMomentsDifference(base, other) {
                var res = { milliseconds: 0, months: 0 };

                res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                if (base.clone().add(res.months, 'M').isAfter(other)) {
                    --res.months;
                }

                res.milliseconds = +other - +base.clone().add(res.months, 'M');

                return res;
            }

            function momentsDifference(base, other) {
                var res;
                if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                }

                other = cloneWithOffset(other, base);
                if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                }

                return res;
            }

            // TODO: remove 'name' arg after deprecation is removed
            function createAdder(direction, name) {
                return function (val, period) {
                    var dur, tmp;
                    //invert the arguments, but complain about it
                    if (period !== null && !isNaN(+period)) {
                        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                        tmp = val;val = period;period = tmp;
                    }

                    val = typeof val === 'string' ? +val : val;
                    dur = create__createDuration(val, period);
                    add_subtract__addSubtract(this, dur, direction);
                    return this;
                };
            }

            function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds,
                    days = absRound(duration._days),
                    months = absRound(duration._months);

                if (!mom.isValid()) {
                    // No op
                    return;
                }

                updateOffset = updateOffset == null ? true : updateOffset;

                if (milliseconds) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                }
                if (days) {
                    get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
                }
                if (months) {
                    setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
                }
                if (updateOffset) {
                    utils_hooks__hooks.updateOffset(mom, days || months);
                }
            }

            var add_subtract__add = createAdder(1, 'add');
            var add_subtract__subtract = createAdder(-1, 'subtract');

            function getCalendarFormat(myMoment, now) {
                var diff = myMoment.diff(now, 'days', true);
                return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
            }

            function moment_calendar__calendar(time, formats) {
                // We want to compare the start of today, vs this.
                // Getting start-of-today depends on whether we're local/utc/offset or not.
                var now = time || local__createLocal(),
                    sod = cloneWithOffset(now, this).startOf('day'),
                    format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

                var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

                return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
            }

            function clone() {
                return new Moment(this);
            }

            function isAfter(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() > localInput.valueOf();
                } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                }
            }

            function isBefore(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() < localInput.valueOf();
                } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                }
            }

            function isBetween(from, to, units, inclusivity) {
                inclusivity = inclusivity || '()';
                return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
            }

            function isSame(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input),
                    inputMs;
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units || 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() === localInput.valueOf();
                } else {
                    inputMs = localInput.valueOf();
                    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                }
            }

            function isSameOrAfter(input, units) {
                return this.isSame(input, units) || this.isAfter(input, units);
            }

            function isSameOrBefore(input, units) {
                return this.isSame(input, units) || this.isBefore(input, units);
            }

            function diff(input, units, asFloat) {
                var that, zoneDelta, delta, output;

                if (!this.isValid()) {
                    return NaN;
                }

                that = cloneWithOffset(input, this);

                if (!that.isValid()) {
                    return NaN;
                }

                zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                units = normalizeUnits(units);

                if (units === 'year' || units === 'month' || units === 'quarter') {
                    output = monthDiff(this, that);
                    if (units === 'quarter') {
                        output = output / 3;
                    } else if (units === 'year') {
                        output = output / 12;
                    }
                } else {
                    delta = this - that;
                    output = units === 'second' ? delta / 1e3 : // 1000
                    units === 'minute' ? delta / 6e4 : // 1000 * 60
                    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    delta;
                }
                return asFloat ? output : absFloor(output);
            }

            function monthDiff(a, b) {
                // difference in months
                var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),

                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                    anchor2,
                    adjust;

                if (b - anchor < 0) {
                    anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor - anchor2);
                } else {
                    anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor2 - anchor);
                }

                //check for negative zero, return zero if negative zero
                return -(wholeMonthDiff + adjust) || 0;
            }

            utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
            utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

            function toString() {
                return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
            }

            function moment_format__toISOString() {
                var m = this.clone().utc();
                if (0 < m.year() && m.year() <= 9999) {
                    if (isFunction(Date.prototype.toISOString)) {
                        // native implementation is ~50x faster, use it when we can
                        return this.toDate().toISOString();
                    } else {
                        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                    }
                } else {
                    return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            }

            function format(inputString) {
                if (!inputString) {
                    inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
                }
                var output = formatMoment(this, inputString);
                return this.localeData().postformat(output);
            }

            function from(time, withoutSuffix) {
                if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
                    return create__createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function fromNow(withoutSuffix) {
                return this.from(local__createLocal(), withoutSuffix);
            }

            function to(time, withoutSuffix) {
                if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
                    return create__createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function toNow(withoutSuffix) {
                return this.to(local__createLocal(), withoutSuffix);
            }

            // If passed a locale key, it will set the locale for this
            // instance.  Otherwise, it will return the locale configuration
            // variables for this instance.
            function locale(key) {
                var newLocaleData;

                if (key === undefined) {
                    return this._locale._abbr;
                } else {
                    newLocaleData = locale_locales__getLocale(key);
                    if (newLocaleData != null) {
                        this._locale = newLocaleData;
                    }
                    return this;
                }
            }

            var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            });

            function localeData() {
                return this._locale;
            }

            function startOf(units) {
                units = normalizeUnits(units);
                // the following switch intentionally omits break keywords
                // to utilize falling through the cases.
                switch (units) {
                    case 'year':
                        this.month(0);
                    /* falls through */
                    case 'quarter':
                    case 'month':
                        this.date(1);
                    /* falls through */
                    case 'week':
                    case 'isoWeek':
                    case 'day':
                    case 'date':
                        this.hours(0);
                    /* falls through */
                    case 'hour':
                        this.minutes(0);
                    /* falls through */
                    case 'minute':
                        this.seconds(0);
                    /* falls through */
                    case 'second':
                        this.milliseconds(0);
                }

                // weeks are a special case
                if (units === 'week') {
                    this.weekday(0);
                }
                if (units === 'isoWeek') {
                    this.isoWeekday(1);
                }

                // quarters are also special
                if (units === 'quarter') {
                    this.month(Math.floor(this.month() / 3) * 3);
                }

                return this;
            }

            function endOf(units) {
                units = normalizeUnits(units);
                if (units === undefined || units === 'millisecond') {
                    return this;
                }

                // 'date' is an alias for 'day', so it should be considered as such.
                if (units === 'date') {
                    units = 'day';
                }

                return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
            }

            function to_type__valueOf() {
                return this._d.valueOf() - (this._offset || 0) * 60000;
            }

            function unix() {
                return Math.floor(this.valueOf() / 1000);
            }

            function toDate() {
                return new Date(this.valueOf());
            }

            function toArray() {
                var m = this;
                return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
            }

            function toObject() {
                var m = this;
                return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                };
            }

            function toJSON() {
                // new Date(NaN).toJSON() === null
                return this.isValid() ? this.toISOString() : null;
            }

            function moment_valid__isValid() {
                return valid__isValid(this);
            }

            function parsingFlags() {
                return extend({}, getParsingFlags(this));
            }

            function invalidAt() {
                return getParsingFlags(this).overflow;
            }

            function creationData() {
                return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                };
            }

            // FORMATTING

            addFormatToken(0, ['gg', 2], 0, function () {
                return this.weekYear() % 100;
            });

            addFormatToken(0, ['GG', 2], 0, function () {
                return this.isoWeekYear() % 100;
            });

            function addWeekYearFormatToken(token, getter) {
                addFormatToken(0, [token, token.length], 0, getter);
            }

            addWeekYearFormatToken('gggg', 'weekYear');
            addWeekYearFormatToken('ggggg', 'weekYear');
            addWeekYearFormatToken('GGGG', 'isoWeekYear');
            addWeekYearFormatToken('GGGGG', 'isoWeekYear');

            // ALIASES

            addUnitAlias('weekYear', 'gg');
            addUnitAlias('isoWeekYear', 'GG');

            // PRIORITY

            addUnitPriority('weekYear', 1);
            addUnitPriority('isoWeekYear', 1);

            // PARSING

            addRegexToken('G', matchSigned);
            addRegexToken('g', matchSigned);
            addRegexToken('GG', match1to2, match2);
            addRegexToken('gg', match1to2, match2);
            addRegexToken('GGGG', match1to4, match4);
            addRegexToken('gggg', match1to4, match4);
            addRegexToken('GGGGG', match1to6, match6);
            addRegexToken('ggggg', match1to6, match6);

            addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
                week[token.substr(0, 2)] = toInt(input);
            });

            addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
                week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
            });

            // MOMENTS

            function getSetWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
            }

            function getSetISOWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
            }

            function getISOWeeksInYear() {
                return weeksInYear(this.year(), 1, 4);
            }

            function getWeeksInYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
            }

            function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                var weeksTarget;
                if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                        week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                }
            }

            function setWeekAll(weekYear, week, weekday, dow, doy) {
                var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

                this.year(date.getUTCFullYear());
                this.month(date.getUTCMonth());
                this.date(date.getUTCDate());
                return this;
            }

            // FORMATTING

            addFormatToken('Q', 0, 'Qo', 'quarter');

            // ALIASES

            addUnitAlias('quarter', 'Q');

            // PRIORITY

            addUnitPriority('quarter', 7);

            // PARSING

            addRegexToken('Q', match1);
            addParseToken('Q', function (input, array) {
                array[MONTH] = (toInt(input) - 1) * 3;
            });

            // MOMENTS

            function getSetQuarter(input) {
                return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
            }

            // FORMATTING

            addFormatToken('D', ['DD', 2], 'Do', 'date');

            // ALIASES

            addUnitAlias('date', 'D');

            // PRIOROITY
            addUnitPriority('date', 9);

            // PARSING

            addRegexToken('D', match1to2);
            addRegexToken('DD', match1to2, match2);
            addRegexToken('Do', function (isStrict, locale) {
                return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
            });

            addParseToken(['D', 'DD'], DATE);
            addParseToken('Do', function (input, array) {
                array[DATE] = toInt(input.match(match1to2)[0], 10);
            });

            // MOMENTS

            var getSetDayOfMonth = makeGetSet('Date', true);

            // FORMATTING

            addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

            // ALIASES

            addUnitAlias('dayOfYear', 'DDD');

            // PRIORITY
            addUnitPriority('dayOfYear', 4);

            // PARSING

            addRegexToken('DDD', match1to3);
            addRegexToken('DDDD', match3);
            addParseToken(['DDD', 'DDDD'], function (input, array, config) {
                config._dayOfYear = toInt(input);
            });

            // HELPERS

            // MOMENTS

            function getSetDayOfYear(input) {
                var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
                return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
            }

            // FORMATTING

            addFormatToken('m', ['mm', 2], 0, 'minute');

            // ALIASES

            addUnitAlias('minute', 'm');

            // PRIORITY

            addUnitPriority('minute', 14);

            // PARSING

            addRegexToken('m', match1to2);
            addRegexToken('mm', match1to2, match2);
            addParseToken(['m', 'mm'], MINUTE);

            // MOMENTS

            var getSetMinute = makeGetSet('Minutes', false);

            // FORMATTING

            addFormatToken('s', ['ss', 2], 0, 'second');

            // ALIASES

            addUnitAlias('second', 's');

            // PRIORITY

            addUnitPriority('second', 15);

            // PARSING

            addRegexToken('s', match1to2);
            addRegexToken('ss', match1to2, match2);
            addParseToken(['s', 'ss'], SECOND);

            // MOMENTS

            var getSetSecond = makeGetSet('Seconds', false);

            // FORMATTING

            addFormatToken('S', 0, 0, function () {
                return ~~(this.millisecond() / 100);
            });

            addFormatToken(0, ['SS', 2], 0, function () {
                return ~~(this.millisecond() / 10);
            });

            addFormatToken(0, ['SSS', 3], 0, 'millisecond');
            addFormatToken(0, ['SSSS', 4], 0, function () {
                return this.millisecond() * 10;
            });
            addFormatToken(0, ['SSSSS', 5], 0, function () {
                return this.millisecond() * 100;
            });
            addFormatToken(0, ['SSSSSS', 6], 0, function () {
                return this.millisecond() * 1000;
            });
            addFormatToken(0, ['SSSSSSS', 7], 0, function () {
                return this.millisecond() * 10000;
            });
            addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
                return this.millisecond() * 100000;
            });
            addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
                return this.millisecond() * 1000000;
            });

            // ALIASES

            addUnitAlias('millisecond', 'ms');

            // PRIORITY

            addUnitPriority('millisecond', 16);

            // PARSING

            addRegexToken('S', match1to3, match1);
            addRegexToken('SS', match1to3, match2);
            addRegexToken('SSS', match1to3, match3);

            var token;
            for (token = 'SSSS'; token.length <= 9; token += 'S') {
                addRegexToken(token, matchUnsigned);
            }

            function parseMs(input, array) {
                array[MILLISECOND] = toInt(('0.' + input) * 1000);
            }

            for (token = 'S'; token.length <= 9; token += 'S') {
                addParseToken(token, parseMs);
            }
            // MOMENTS

            var getSetMillisecond = makeGetSet('Milliseconds', false);

            // FORMATTING

            addFormatToken('z', 0, 0, 'zoneAbbr');
            addFormatToken('zz', 0, 0, 'zoneName');

            // MOMENTS

            function getZoneAbbr() {
                return this._isUTC ? 'UTC' : '';
            }

            function getZoneName() {
                return this._isUTC ? 'Coordinated Universal Time' : '';
            }

            var momentPrototype__proto = Moment.prototype;

            momentPrototype__proto.add = add_subtract__add;
            momentPrototype__proto.calendar = moment_calendar__calendar;
            momentPrototype__proto.clone = clone;
            momentPrototype__proto.diff = diff;
            momentPrototype__proto.endOf = endOf;
            momentPrototype__proto.format = format;
            momentPrototype__proto.from = from;
            momentPrototype__proto.fromNow = fromNow;
            momentPrototype__proto.to = to;
            momentPrototype__proto.toNow = toNow;
            momentPrototype__proto.get = stringGet;
            momentPrototype__proto.invalidAt = invalidAt;
            momentPrototype__proto.isAfter = isAfter;
            momentPrototype__proto.isBefore = isBefore;
            momentPrototype__proto.isBetween = isBetween;
            momentPrototype__proto.isSame = isSame;
            momentPrototype__proto.isSameOrAfter = isSameOrAfter;
            momentPrototype__proto.isSameOrBefore = isSameOrBefore;
            momentPrototype__proto.isValid = moment_valid__isValid;
            momentPrototype__proto.lang = lang;
            momentPrototype__proto.locale = locale;
            momentPrototype__proto.localeData = localeData;
            momentPrototype__proto.max = prototypeMax;
            momentPrototype__proto.min = prototypeMin;
            momentPrototype__proto.parsingFlags = parsingFlags;
            momentPrototype__proto.set = stringSet;
            momentPrototype__proto.startOf = startOf;
            momentPrototype__proto.subtract = add_subtract__subtract;
            momentPrototype__proto.toArray = toArray;
            momentPrototype__proto.toObject = toObject;
            momentPrototype__proto.toDate = toDate;
            momentPrototype__proto.toISOString = moment_format__toISOString;
            momentPrototype__proto.toJSON = toJSON;
            momentPrototype__proto.toString = toString;
            momentPrototype__proto.unix = unix;
            momentPrototype__proto.valueOf = to_type__valueOf;
            momentPrototype__proto.creationData = creationData;

            // Year
            momentPrototype__proto.year = getSetYear;
            momentPrototype__proto.isLeapYear = getIsLeapYear;

            // Week Year
            momentPrototype__proto.weekYear = getSetWeekYear;
            momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

            // Quarter
            momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

            // Month
            momentPrototype__proto.month = getSetMonth;
            momentPrototype__proto.daysInMonth = getDaysInMonth;

            // Week
            momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
            momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
            momentPrototype__proto.weeksInYear = getWeeksInYear;
            momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

            // Day
            momentPrototype__proto.date = getSetDayOfMonth;
            momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
            momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
            momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
            momentPrototype__proto.dayOfYear = getSetDayOfYear;

            // Hour
            momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

            // Minute
            momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

            // Second
            momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

            // Millisecond
            momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

            // Offset
            momentPrototype__proto.utcOffset = getSetOffset;
            momentPrototype__proto.utc = setOffsetToUTC;
            momentPrototype__proto.local = setOffsetToLocal;
            momentPrototype__proto.parseZone = setOffsetToParsedOffset;
            momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
            momentPrototype__proto.isDST = isDaylightSavingTime;
            momentPrototype__proto.isLocal = isLocal;
            momentPrototype__proto.isUtcOffset = isUtcOffset;
            momentPrototype__proto.isUtc = isUtc;
            momentPrototype__proto.isUTC = isUtc;

            // Timezone
            momentPrototype__proto.zoneAbbr = getZoneAbbr;
            momentPrototype__proto.zoneName = getZoneName;

            // Deprecations
            momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
            momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
            momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
            momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
            momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

            var momentPrototype = momentPrototype__proto;

            function moment__createUnix(input) {
                return local__createLocal(input * 1000);
            }

            function moment__createInZone() {
                return local__createLocal.apply(null, arguments).parseZone();
            }

            function preParsePostFormat(string) {
                return string;
            }

            var prototype__proto = Locale.prototype;

            prototype__proto.calendar = locale_calendar__calendar;
            prototype__proto.longDateFormat = longDateFormat;
            prototype__proto.invalidDate = invalidDate;
            prototype__proto.ordinal = ordinal;
            prototype__proto.preparse = preParsePostFormat;
            prototype__proto.postformat = preParsePostFormat;
            prototype__proto.relativeTime = relative__relativeTime;
            prototype__proto.pastFuture = pastFuture;
            prototype__proto.set = locale_set__set;

            // Month
            prototype__proto.months = localeMonths;
            prototype__proto.monthsShort = localeMonthsShort;
            prototype__proto.monthsParse = localeMonthsParse;
            prototype__proto.monthsRegex = monthsRegex;
            prototype__proto.monthsShortRegex = monthsShortRegex;

            // Week
            prototype__proto.week = localeWeek;
            prototype__proto.firstDayOfYear = localeFirstDayOfYear;
            prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

            // Day of Week
            prototype__proto.weekdays = localeWeekdays;
            prototype__proto.weekdaysMin = localeWeekdaysMin;
            prototype__proto.weekdaysShort = localeWeekdaysShort;
            prototype__proto.weekdaysParse = localeWeekdaysParse;

            prototype__proto.weekdaysRegex = weekdaysRegex;
            prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
            prototype__proto.weekdaysMinRegex = weekdaysMinRegex;

            // Hours
            prototype__proto.isPM = localeIsPM;
            prototype__proto.meridiem = localeMeridiem;

            function lists__get(format, index, field, setter) {
                var locale = locale_locales__getLocale();
                var utc = create_utc__createUTC().set(setter, index);
                return locale[field](utc, format);
            }

            function listMonthsImpl(format, index, field) {
                if (typeof format === 'number') {
                    index = format;
                    format = undefined;
                }

                format = format || '';

                if (index != null) {
                    return lists__get(format, index, field, 'month');
                }

                var i;
                var out = [];
                for (i = 0; i < 12; i++) {
                    out[i] = lists__get(format, i, field, 'month');
                }
                return out;
            }

            // ()
            // (5)
            // (fmt, 5)
            // (fmt)
            // (true)
            // (true, 5)
            // (true, fmt, 5)
            // (true, fmt)
            function listWeekdaysImpl(localeSorted, format, index, field) {
                if (typeof localeSorted === 'boolean') {
                    if (typeof format === 'number') {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                } else {
                    format = localeSorted;
                    index = format;
                    localeSorted = false;

                    if (typeof format === 'number') {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                }

                var locale = locale_locales__getLocale(),
                    shift = localeSorted ? locale._week.dow : 0;

                if (index != null) {
                    return lists__get(format, (index + shift) % 7, field, 'day');
                }

                var i;
                var out = [];
                for (i = 0; i < 7; i++) {
                    out[i] = lists__get(format, (i + shift) % 7, field, 'day');
                }
                return out;
            }

            function lists__listMonths(format, index) {
                return listMonthsImpl(format, index, 'months');
            }

            function lists__listMonthsShort(format, index) {
                return listMonthsImpl(format, index, 'monthsShort');
            }

            function lists__listWeekdays(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
            }

            function lists__listWeekdaysShort(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
            }

            function lists__listWeekdaysMin(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
            }

            locale_locales__getSetGlobalLocale('en', {
                ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
                    return number + output;
                }
            });

            // Side effect imports
            utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
            utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

            var mathAbs = Math.abs;

            function duration_abs__abs() {
                var data = this._data;

                this._milliseconds = mathAbs(this._milliseconds);
                this._days = mathAbs(this._days);
                this._months = mathAbs(this._months);

                data.milliseconds = mathAbs(data.milliseconds);
                data.seconds = mathAbs(data.seconds);
                data.minutes = mathAbs(data.minutes);
                data.hours = mathAbs(data.hours);
                data.months = mathAbs(data.months);
                data.years = mathAbs(data.years);

                return this;
            }

            function duration_add_subtract__addSubtract(duration, input, value, direction) {
                var other = create__createDuration(input, value);

                duration._milliseconds += direction * other._milliseconds;
                duration._days += direction * other._days;
                duration._months += direction * other._months;

                return duration._bubble();
            }

            // supports only 2.0-style add(1, 's') or add(duration)
            function duration_add_subtract__add(input, value) {
                return duration_add_subtract__addSubtract(this, input, value, 1);
            }

            // supports only 2.0-style subtract(1, 's') or subtract(duration)
            function duration_add_subtract__subtract(input, value) {
                return duration_add_subtract__addSubtract(this, input, value, -1);
            }

            function absCeil(number) {
                if (number < 0) {
                    return Math.floor(number);
                } else {
                    return Math.ceil(number);
                }
            }

            function bubble() {
                var milliseconds = this._milliseconds;
                var days = this._days;
                var months = this._months;
                var data = this._data;
                var seconds, minutes, hours, years, monthsFromDays;

                // if we have a mix of positive and negative values, bubble down first
                // check: https://github.com/moment/moment/issues/2166
                if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
                    milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                    days = 0;
                    months = 0;
                }

                // The following code bubbles up values, see the tests for
                // examples of what that means.
                data.milliseconds = milliseconds % 1000;

                seconds = absFloor(milliseconds / 1000);
                data.seconds = seconds % 60;

                minutes = absFloor(seconds / 60);
                data.minutes = minutes % 60;

                hours = absFloor(minutes / 60);
                data.hours = hours % 24;

                days += absFloor(hours / 24);

                // convert days to months
                monthsFromDays = absFloor(daysToMonths(days));
                months += monthsFromDays;
                days -= absCeil(monthsToDays(monthsFromDays));

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;

                data.days = days;
                data.months = months;
                data.years = years;

                return this;
            }

            function daysToMonths(days) {
                // 400 years have 146097 days (taking into account leap year rules)
                // 400 years have 12 months === 4800
                return days * 4800 / 146097;
            }

            function monthsToDays(months) {
                // the reverse of daysToMonths
                return months * 146097 / 4800;
            }

            function as(units) {
                var days;
                var months;
                var milliseconds = this._milliseconds;

                units = normalizeUnits(units);

                if (units === 'month' || units === 'year') {
                    days = this._days + milliseconds / 864e5;
                    months = this._months + daysToMonths(days);
                    return units === 'month' ? months : months / 12;
                } else {
                    // handle milliseconds separately because of floating point math errors (issue #1867)
                    days = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                        case 'week':
                            return days / 7 + milliseconds / 6048e5;
                        case 'day':
                            return days + milliseconds / 864e5;
                        case 'hour':
                            return days * 24 + milliseconds / 36e5;
                        case 'minute':
                            return days * 1440 + milliseconds / 6e4;
                        case 'second':
                            return days * 86400 + milliseconds / 1000;
                        // Math.floor prevents floating point math errors here
                        case 'millisecond':
                            return Math.floor(days * 864e5) + milliseconds;
                        default:
                            throw new Error('Unknown unit ' + units);
                    }
                }
            }

            // TODO: Use this.as('ms')?
            function duration_as__valueOf() {
                return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
            }

            function makeAs(alias) {
                return function () {
                    return this.as(alias);
                };
            }

            var asMilliseconds = makeAs('ms');
            var asSeconds = makeAs('s');
            var asMinutes = makeAs('m');
            var asHours = makeAs('h');
            var asDays = makeAs('d');
            var asWeeks = makeAs('w');
            var asMonths = makeAs('M');
            var asYears = makeAs('y');

            function duration_get__get(units) {
                units = normalizeUnits(units);
                return this[units + 's']();
            }

            function makeGetter(name) {
                return function () {
                    return this._data[name];
                };
            }

            var milliseconds = makeGetter('milliseconds');
            var seconds = makeGetter('seconds');
            var minutes = makeGetter('minutes');
            var hours = makeGetter('hours');
            var days = makeGetter('days');
            var months = makeGetter('months');
            var years = makeGetter('years');

            function weeks() {
                return absFloor(this.days() / 7);
            }

            var round = Math.round;
            var thresholds = {
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month
                M: 11 // months to year
            };

            // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }

            function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
                var duration = create__createDuration(posNegDuration).abs();
                var seconds = round(duration.as('s'));
                var minutes = round(duration.as('m'));
                var hours = round(duration.as('h'));
                var days = round(duration.as('d'));
                var months = round(duration.as('M'));
                var years = round(duration.as('y'));

                var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

                a[2] = withoutSuffix;
                a[3] = +posNegDuration > 0;
                a[4] = locale;
                return substituteTimeAgo.apply(null, a);
            }

            // This function allows you to set the rounding function for relative time strings
            function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
                if (roundingFunction === undefined) {
                    return round;
                }
                if (typeof roundingFunction === 'function') {
                    round = roundingFunction;
                    return true;
                }
                return false;
            }

            // This function allows you to set a threshold for relative time strings
            function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
                if (thresholds[threshold] === undefined) {
                    return false;
                }
                if (limit === undefined) {
                    return thresholds[threshold];
                }
                thresholds[threshold] = limit;
                return true;
            }

            function humanize(withSuffix) {
                var locale = this.localeData();
                var output = duration_humanize__relativeTime(this, !withSuffix, locale);

                if (withSuffix) {
                    output = locale.pastFuture(+this, output);
                }

                return locale.postformat(output);
            }

            var iso_string__abs = Math.abs;

            function iso_string__toISOString() {
                // for ISO strings we do not use the normal bubbling rules:
                //  * milliseconds bubble up until they become hours
                //  * days do not bubble at all
                //  * months bubble up until they become years
                // This is because there is no context-free conversion between hours and days
                // (think of clock changes)
                // and also not between days and months (28-31 days per month)
                var seconds = iso_string__abs(this._milliseconds) / 1000;
                var days = iso_string__abs(this._days);
                var months = iso_string__abs(this._months);
                var minutes, hours, years;

                // 3600 seconds -> 60 minutes -> 1 hour
                minutes = absFloor(seconds / 60);
                hours = absFloor(minutes / 60);
                seconds %= 60;
                minutes %= 60;

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;

                // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                var Y = years;
                var M = months;
                var D = days;
                var h = hours;
                var m = minutes;
                var s = seconds;
                var total = this.asSeconds();

                if (!total) {
                    // this is the same as C#'s (Noda) and python (isodate)...
                    // but not other JS (goog.date)
                    return 'P0D';
                }

                return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
            }

            var duration_prototype__proto = Duration.prototype;

            duration_prototype__proto.abs = duration_abs__abs;
            duration_prototype__proto.add = duration_add_subtract__add;
            duration_prototype__proto.subtract = duration_add_subtract__subtract;
            duration_prototype__proto.as = as;
            duration_prototype__proto.asMilliseconds = asMilliseconds;
            duration_prototype__proto.asSeconds = asSeconds;
            duration_prototype__proto.asMinutes = asMinutes;
            duration_prototype__proto.asHours = asHours;
            duration_prototype__proto.asDays = asDays;
            duration_prototype__proto.asWeeks = asWeeks;
            duration_prototype__proto.asMonths = asMonths;
            duration_prototype__proto.asYears = asYears;
            duration_prototype__proto.valueOf = duration_as__valueOf;
            duration_prototype__proto._bubble = bubble;
            duration_prototype__proto.get = duration_get__get;
            duration_prototype__proto.milliseconds = milliseconds;
            duration_prototype__proto.seconds = seconds;
            duration_prototype__proto.minutes = minutes;
            duration_prototype__proto.hours = hours;
            duration_prototype__proto.days = days;
            duration_prototype__proto.weeks = weeks;
            duration_prototype__proto.months = months;
            duration_prototype__proto.years = years;
            duration_prototype__proto.humanize = humanize;
            duration_prototype__proto.toISOString = iso_string__toISOString;
            duration_prototype__proto.toString = iso_string__toISOString;
            duration_prototype__proto.toJSON = iso_string__toISOString;
            duration_prototype__proto.locale = locale;
            duration_prototype__proto.localeData = localeData;

            // Deprecations
            duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
            duration_prototype__proto.lang = lang;

            // Side effect imports

            // FORMATTING

            addFormatToken('X', 0, 0, 'unix');
            addFormatToken('x', 0, 0, 'valueOf');

            // PARSING

            addRegexToken('x', matchSigned);
            addRegexToken('X', matchTimestamp);
            addParseToken('X', function (input, array, config) {
                config._d = new Date(parseFloat(input, 10) * 1000);
            });
            addParseToken('x', function (input, array, config) {
                config._d = new Date(toInt(input));
            });

            // Side effect imports


            utils_hooks__hooks.version = '2.15.1';

            setHookCallback(local__createLocal);

            utils_hooks__hooks.fn = momentPrototype;
            utils_hooks__hooks.min = min;
            utils_hooks__hooks.max = max;
            utils_hooks__hooks.now = now;
            utils_hooks__hooks.utc = create_utc__createUTC;
            utils_hooks__hooks.unix = moment__createUnix;
            utils_hooks__hooks.months = lists__listMonths;
            utils_hooks__hooks.isDate = isDate;
            utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
            utils_hooks__hooks.invalid = valid__createInvalid;
            utils_hooks__hooks.duration = create__createDuration;
            utils_hooks__hooks.isMoment = isMoment;
            utils_hooks__hooks.weekdays = lists__listWeekdays;
            utils_hooks__hooks.parseZone = moment__createInZone;
            utils_hooks__hooks.localeData = locale_locales__getLocale;
            utils_hooks__hooks.isDuration = isDuration;
            utils_hooks__hooks.monthsShort = lists__listMonthsShort;
            utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
            utils_hooks__hooks.defineLocale = defineLocale;
            utils_hooks__hooks.updateLocale = updateLocale;
            utils_hooks__hooks.locales = locale_locales__listLocales;
            utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
            utils_hooks__hooks.normalizeUnits = normalizeUnits;
            utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
            utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
            utils_hooks__hooks.calendarFormat = getCalendarFormat;
            utils_hooks__hooks.prototype = momentPrototype;

            var _moment = utils_hooks__hooks;

            return _moment;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('7', ['4', '5', '6'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    var timerModule = $__global['timerModule'],
        app = $__global['app'];
    /**
     * angular-timer - v1.3.4 - 2016-05-01 9:52 PM
     * https://github.com/siddii/angular-timer
     *
     * Copyright (c) 2016 Siddique Hameed
     * Licensed MIT <https://github.com/siddii/angular-timer/blob/master/LICENSE.txt>
     */
    var timerModule = angular.module('timer', []).directive('timer', ['$compile', function ($compile) {
      return {
        restrict: 'EA',
        replace: false,
        scope: {
          interval: '=interval',
          startTimeAttr: '=startTime',
          endTimeAttr: '=endTime',
          countdownattr: '=countdown',
          finishCallback: '&finishCallback',
          autoStart: '&autoStart',
          language: '@?',
          fallback: '@?',
          maxTimeUnit: '=',
          seconds: '=?',
          minutes: '=?',
          hours: '=?',
          days: '=?',
          months: '=?',
          years: '=?',
          secondsS: '=?',
          minutesS: '=?',
          hoursS: '=?',
          daysS: '=?',
          monthsS: '=?',
          yearsS: '=?'
        },
        controller: ['$scope', '$element', '$attrs', '$timeout', 'I18nService', '$interpolate', 'progressBarService', function ($scope, $element, $attrs, $timeout, I18nService, $interpolate, progressBarService) {

          // Checking for trim function since IE8 doesn't have it
          // If not a function, create tirm with RegEx to mimic native trim
          if (typeof String.prototype.trim !== 'function') {
            String.prototype.trim = function () {
              return this.replace(/^\s+|\s+$/g, '');
            };
          }

          //angular 1.2 doesn't support attributes ending in "-start", so we're
          //supporting both "autostart" and "auto-start" as a solution for
          //backward and forward compatibility.
          $scope.autoStart = $attrs.autoStart || $attrs.autostart;

          $scope.language = $scope.language || 'en';
          $scope.fallback = $scope.fallback || 'en';

          //allow to change the language of the directive while already launched
          $scope.$watch('language', function (newVal, oldVal) {
            if (newVal !== undefined) {
              i18nService.init(newVal, $scope.fallback);
            }
          });

          //init momentJS i18n, default english
          var i18nService = new I18nService();
          i18nService.init($scope.language, $scope.fallback);

          //progress bar
          $scope.displayProgressBar = 0;
          $scope.displayProgressActive = 'active'; //Bootstrap active effect for progress bar

          if ($element.html().trim().length === 0) {
            $element.append($compile('<span>' + $interpolate.startSymbol() + 'millis' + $interpolate.endSymbol() + '</span>')($scope));
          } else {
            $element.append($compile($element.contents())($scope));
          }

          $scope.startTime = null;
          $scope.endTime = null;
          $scope.timeoutId = null;
          $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) >= 0 ? parseInt($scope.countdownattr, 10) : undefined;
          $scope.isRunning = false;

          $scope.$on('timer-start', function () {
            $scope.start();
          });

          $scope.$on('timer-resume', function () {
            $scope.resume();
          });

          $scope.$on('timer-stop', function () {
            $scope.stop();
          });

          $scope.$on('timer-clear', function () {
            $scope.clear();
          });

          $scope.$on('timer-reset', function () {
            $scope.reset();
          });

          $scope.$on('timer-set-countdown', function (e, countdown) {
            $scope.countdown = countdown;
          });

          function resetTimeout() {
            if ($scope.timeoutId) {
              clearTimeout($scope.timeoutId);
            }
          }

          $scope.$watch('startTimeAttr', function (newValue, oldValue) {
            if (newValue !== oldValue && $scope.isRunning) {
              $scope.start();
            }
          });

          $scope.$watch('endTimeAttr', function (newValue, oldValue) {
            if (newValue !== oldValue && $scope.isRunning) {
              $scope.start();
            }
          });

          $scope.start = $element[0].start = function () {
            $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment();
            $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null;
            if (!angular.isNumber($scope.countdown)) {
              $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : undefined;
            }
            resetTimeout();
            tick();
            $scope.isRunning = true;
          };

          $scope.resume = $element[0].resume = function () {
            resetTimeout();
            if ($scope.countdownattr) {
              $scope.countdown += 1;
            }
            $scope.startTime = moment().diff(moment($scope.stoppedTime).diff(moment($scope.startTime)));
            tick();
            $scope.isRunning = true;
          };

          $scope.stop = $scope.pause = $element[0].stop = $element[0].pause = function () {
            var timeoutId = $scope.timeoutId;
            $scope.clear();
            $scope.$emit('timer-stopped', { timeoutId: timeoutId, millis: $scope.millis, seconds: $scope.seconds, minutes: $scope.minutes, hours: $scope.hours, days: $scope.days });
          };

          $scope.clear = $element[0].clear = function () {
            // same as stop but without the event being triggered
            $scope.stoppedTime = moment();
            resetTimeout();
            $scope.timeoutId = null;
            $scope.isRunning = false;
          };

          $scope.reset = $element[0].reset = function () {
            $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment();
            $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null;
            $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : undefined;
            resetTimeout();
            tick();
            $scope.isRunning = false;
            $scope.clear();
          };

          $element.bind('$destroy', function () {
            resetTimeout();
            $scope.isRunning = false;
          });

          function calculateTimeUnits() {
            var timeUnits = {}; //will contains time with units

            if ($attrs.startTime !== undefined) {
              $scope.millis = moment().diff(moment($scope.startTimeAttr));
            }

            timeUnits = i18nService.getTimeUnits($scope.millis);

            // compute time values based on maxTimeUnit specification
            if (!$scope.maxTimeUnit || $scope.maxTimeUnit === 'day') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24);
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'second') {
              $scope.seconds = Math.floor($scope.millis / 1000);
              $scope.minutes = 0;
              $scope.hours = 0;
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'minute') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000);
              $scope.hours = 0;
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'hour') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000);
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'month') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24 % 30);
              $scope.months = Math.floor($scope.millis / 3600000 / 24 / 30);
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'year') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24 % 30);
              $scope.months = Math.floor($scope.millis / 3600000 / 24 / 30 % 12);
              $scope.years = Math.floor($scope.millis / 3600000 / 24 / 365);
            }
            // plural - singular unit decision (old syntax, for backwards compatibility and English only, could be deprecated!)
            $scope.secondsS = $scope.seconds === 1 ? '' : 's';
            $scope.minutesS = $scope.minutes === 1 ? '' : 's';
            $scope.hoursS = $scope.hours === 1 ? '' : 's';
            $scope.daysS = $scope.days === 1 ? '' : 's';
            $scope.monthsS = $scope.months === 1 ? '' : 's';
            $scope.yearsS = $scope.years === 1 ? '' : 's';

            // new plural-singular unit decision functions (for custom units and multilingual support)
            $scope.secondUnit = timeUnits.seconds;
            $scope.minuteUnit = timeUnits.minutes;
            $scope.hourUnit = timeUnits.hours;
            $scope.dayUnit = timeUnits.days;
            $scope.monthUnit = timeUnits.months;
            $scope.yearUnit = timeUnits.years;

            //add leading zero if number is smaller than 10
            $scope.sseconds = $scope.seconds < 10 ? '0' + $scope.seconds : $scope.seconds;
            $scope.mminutes = $scope.minutes < 10 ? '0' + $scope.minutes : $scope.minutes;
            $scope.hhours = $scope.hours < 10 ? '0' + $scope.hours : $scope.hours;
            $scope.ddays = $scope.days < 10 ? '0' + $scope.days : $scope.days;
            $scope.mmonths = $scope.months < 10 ? '0' + $scope.months : $scope.months;
            $scope.yyears = $scope.years < 10 ? '0' + $scope.years : $scope.years;
          }

          //determine initial values of time units and add AddSeconds functionality
          if ($scope.countdownattr) {
            $scope.millis = $scope.countdownattr * 1000;

            $scope.addCDSeconds = $element[0].addCDSeconds = function (extraSeconds) {
              $scope.countdown += extraSeconds;
              $scope.$digest();
              if (!$scope.isRunning) {
                $scope.start();
              }
            };

            $scope.$on('timer-add-cd-seconds', function (e, extraSeconds) {
              $timeout(function () {
                $scope.addCDSeconds(extraSeconds);
              });
            });

            $scope.$on('timer-set-countdown-seconds', function (e, countdownSeconds) {
              if (!$scope.isRunning) {
                $scope.clear();
              }

              $scope.countdown = countdownSeconds;
              $scope.millis = countdownSeconds * 1000;
              calculateTimeUnits();
            });
          } else {
            $scope.millis = 0;
          }
          calculateTimeUnits();

          var tick = function tick() {
            var typeTimer = null; // countdown or endTimeAttr
            $scope.millis = moment().diff($scope.startTime);
            var adjustment = $scope.millis % 1000;

            if ($scope.endTimeAttr) {
              typeTimer = $scope.endTimeAttr;
              $scope.millis = moment($scope.endTime).diff(moment());
              adjustment = $scope.interval - $scope.millis % 1000;
            }

            if ($scope.countdownattr) {
              typeTimer = $scope.countdownattr;
              $scope.millis = $scope.countdown * 1000;
            }

            if ($scope.millis < 0) {
              $scope.stop();
              $scope.millis = 0;
              calculateTimeUnits();
              if ($scope.finishCallback) {
                $scope.$eval($scope.finishCallback);
              }
              return;
            }
            calculateTimeUnits();

            //We are not using $timeout for a reason. Please read here - https://github.com/siddii/angular-timer/pull/5
            $scope.timeoutId = setTimeout(function () {
              tick();
              $scope.$digest();
            }, $scope.interval - adjustment);

            $scope.$emit('timer-tick', { timeoutId: $scope.timeoutId, millis: $scope.millis, timerElement: $element[0] });

            if ($scope.countdown > 0) {
              $scope.countdown--;
            } else if ($scope.countdown <= 0) {
              $scope.stop();
              if ($scope.finishCallback) {
                $scope.$eval($scope.finishCallback);
              }
            }

            if (typeTimer !== null) {
              //calculate progress bar
              $scope.progressBar = progressBarService.calculateProgressBar($scope.startTime, $scope.millis, $scope.endTime, $scope.countdownattr);

              if ($scope.progressBar === 100) {
                $scope.displayProgressActive = ''; //No more Bootstrap active effect
              }
            }
          };

          if ($scope.autoStart === undefined || $scope.autoStart === true) {
            $scope.start();
          }
        }]
      };
    }]);

    /* commonjs package manager support (eg componentjs) */
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = timerModule;
    }

    var app = angular.module('timer');

    app.factory('I18nService', function () {

      var I18nService = function () {};

      I18nService.prototype.language = 'en';
      I18nService.prototype.fallback = 'en';
      I18nService.prototype.timeHumanizer = {};

      I18nService.prototype.init = function init(lang, fallback) {
        var supported_languages = humanizeDuration.getSupportedLanguages();

        this.fallback = fallback !== undefined ? fallback : 'en';
        if (supported_languages.indexOf(fallback) === -1) {
          this.fallback = 'en';
        }

        this.language = lang;
        if (supported_languages.indexOf(lang) === -1) {
          this.language = this.fallback;
        }

        //moment init
        moment.locale(this.language); //@TODO maybe to remove, it should be handle by the user's application itself, and not inside the directive

        //human duration init, using it because momentjs does not allow accurate time (
        // momentJS: a few moment ago, human duration : 4 seconds ago
        this.timeHumanizer = humanizeDuration.humanizer({
          language: this.language,
          halfUnit: false
        });
      };

      /**
       * get time with units from momentJS i18n
       * @param {int} millis
       * @returns {{millis: string, seconds: string, minutes: string, hours: string, days: string, months: string, years: string}}
       */
      I18nService.prototype.getTimeUnits = function getTimeUnits(millis) {
        var diffFromAlarm = Math.round(millis / 1000) * 1000; //time in milliseconds, get rid of the last 3 ms value to avoid 2.12 seconds display

        var time = {};

        if (typeof this.timeHumanizer != 'undefined') {
          time = {
            'millis': this.timeHumanizer(diffFromAlarm, { units: ["milliseconds"] }),
            'seconds': this.timeHumanizer(diffFromAlarm, { units: ["seconds"] }),
            'minutes': this.timeHumanizer(diffFromAlarm, { units: ["minutes", "seconds"] }),
            'hours': this.timeHumanizer(diffFromAlarm, { units: ["hours", "minutes", "seconds"] }),
            'days': this.timeHumanizer(diffFromAlarm, { units: ["days", "hours", "minutes", "seconds"] }),
            'months': this.timeHumanizer(diffFromAlarm, { units: ["months", "days", "hours", "minutes", "seconds"] }),
            'years': this.timeHumanizer(diffFromAlarm, { units: ["years", "months", "days", "hours", "minutes", "seconds"] })
          };
        } else {
          console.error('i18nService has not been initialized. You must call i18nService.init("en") for example');
        }

        return time;
      };

      return I18nService;
    });

    var app = angular.module('timer');

    app.factory('progressBarService', function () {

      var ProgressBarService = function () {};

      /**
       * calculate the remaining time in a progress bar in percentage
       * @param {momentjs} startValue in seconds
       * @param {integer} currentCountdown, where are we in the countdown
       * @param {integer} remainingTime, remaining milliseconds
       * @param {integer} endTime, end time, can be undefined
       * @param {integer} coutdown, original coutdown value, can be undefined
       *
       * joke : https://www.youtube.com/watch?v=gENVB6tjq_M
       * @return {float} 0 --> 100
       */
      ProgressBarService.prototype.calculateProgressBar = function calculateProgressBar(startValue, remainingTime, endTimeAttr, coutdown) {
        var displayProgressBar = 0,
            endTimeValue,
            initialCountdown;

        remainingTime = remainingTime / 1000; //seconds


        if (endTimeAttr !== null) {
          endTimeValue = moment(endTimeAttr);
          initialCountdown = endTimeValue.diff(startValue, 'seconds');
          displayProgressBar = remainingTime * 100 / initialCountdown;
        } else {
          displayProgressBar = remainingTime * 100 / coutdown;
        }

        displayProgressBar = 100 - displayProgressBar; //To have 0 to 100 and not 100 to 0
        displayProgressBar = Math.round(displayProgressBar * 10) / 10; //learn more why : http://stackoverflow.com/questions/588004/is-floating-point-math-broken

        if (displayProgressBar > 100) {
          //security
          displayProgressBar = 100;
        }

        return displayProgressBar;
      };

      return new ProgressBarService();
    });
    $__global['timerModule'] = timerModule;
    $__global['app'] = app;
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('8', ['9', 'a', 'b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $every = $__require('a')(4);

  $export($export.P + $export.F * !$__require('b')([].every, true), 'Array', {
    // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
    every: function every(callbackfn /* , thisArg */) {
      return $every(this, callbackfn, arguments[1]);
    }
  });
  return module.exports;
});
$__System.registerDynamic('d', ['8', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('8');
  module.exports = $__require('e').Array.every;
  return module.exports;
});
$__System.registerDynamic('f', ['9', 'a', '10', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $find = $__require('a')(6),
      KEY = 'findIndex',
      forced = true;
  // Shouldn't skip holes
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', {
    findIndex: function findIndex(callbackfn /*, that = undefined */) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  $__require('10')(KEY);
  return module.exports;
});
$__System.registerDynamic('11', ['f', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('f');
  module.exports = $__require('e').Array.findIndex;
  return module.exports;
});
$__System.registerDynamic('10', ['12', '13', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = $__require('12')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined) $__require('13')(ArrayProto, UNSCOPABLES, {});
  module.exports = function (key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
  return module.exports;
});
$__System.registerDynamic('14', ['9', 'a', '10', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $find = $__require('a')(5),
      KEY = 'find',
      forced = true;
  // Shouldn't skip holes
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', {
    find: function find(callbackfn /*, that = undefined */) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  $__require('10')(KEY);
  return module.exports;
});
$__System.registerDynamic('15', ['14', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('14');
  module.exports = $__require('e').Array.find;
  return module.exports;
});
$__System.registerDynamic('16', ['17', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var toInteger = $__require('17'),
      defined = $__require('18');
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  return module.exports;
});
$__System.registerDynamic("19", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = false;
  return module.exports;
});
$__System.registerDynamic('1a', ['1b', '1c', '1d', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var dP = $__require('1b'),
      anObject = $__require('1c'),
      getKeys = $__require('1d');

  module.exports = $__require('1e') ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties),
        length = keys.length,
        i = 0,
        P;
    while (length > i) dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  return module.exports;
});
$__System.registerDynamic('1f', ['20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('20').document && document.documentElement;
  return module.exports;
});
$__System.registerDynamic('21', ['1c', '1a', '22', '23', '24', '1f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject = $__require('1c'),
      dPs = $__require('1a'),
      enumBugKeys = $__require('22'),
      IE_PROTO = $__require('23')('IE_PROTO'),
      Empty = function () {/* empty */},
      PROTOTYPE = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = $__require('24')('iframe'),
        i = enumBugKeys.length,
        lt = '<',
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    $__require('1f').appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };

  module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };
  return module.exports;
});
$__System.registerDynamic('25', ['21', '26', '27', '13', '12', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var create = $__require('21'),
      descriptor = $__require('26'),
      setToStringTag = $__require('27'),
      IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  $__require('13')(IteratorPrototype, $__require('12')('iterator'), function () {
    return this;
  });

  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  return module.exports;
});
$__System.registerDynamic('27', ['1b', '28', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var def = $__require('1b').f,
      has = $__require('28'),
      TAG = $__require('12')('toStringTag');

  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };
  return module.exports;
});
$__System.registerDynamic('29', ['28', '2a', '23', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has = $__require('28'),
      toObject = $__require('2a'),
      IE_PROTO = $__require('23')('IE_PROTO'),
      ObjectProto = Object.prototype;

  module.exports = Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }return O instanceof Object ? ObjectProto : null;
  };
  return module.exports;
});
$__System.registerDynamic('2b', ['19', '9', '2c', '13', '28', '2d', '25', '27', '29', '12', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('19'),
      $export = $__require('9'),
      redefine = $__require('2c'),
      hide = $__require('13'),
      has = $__require('28'),
      Iterators = $__require('2d'),
      $iterCreate = $__require('25'),
      setToStringTag = $__require('27'),
      getPrototypeOf = $__require('29'),
      ITERATOR = $__require('12')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  ,
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';

  var returnThis = function () {
    return this;
  };

  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
        $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
        methods,
        key,
        IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype) {
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() {
        return $native.call(this);
      };
    }
    // Define iterator
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return module.exports;
});
$__System.registerDynamic('2e', ['16', '2b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $at = $__require('16')(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  $__require('2b')(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0; // next index
    // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });
  return module.exports;
});
$__System.registerDynamic('2f', ['1c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // call something on iterator step with safe closing on error
  var anObject = $__require('1c');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
      // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
  return module.exports;
});
$__System.registerDynamic('30', ['2d', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // check on default Array iterator
  var Iterators = $__require('2d'),
      ITERATOR = $__require('12')('iterator'),
      ArrayProto = Array.prototype;

  module.exports = function (it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return module.exports;
});
$__System.registerDynamic('31', ['1b', '26', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $defineProperty = $__require('1b'),
      createDesc = $__require('26');

  module.exports = function (object, index, value) {
    if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
  };
  return module.exports;
});
$__System.registerDynamic('32', ['33', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = $__require('33'),
      TAG = $__require('12')('toStringTag')
  // ES3 wrong here
  ,
      ARG = cof(function () {
    return arguments;
  }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {/* empty */}
  };

  module.exports = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  return module.exports;
});
$__System.registerDynamic("2d", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {};
  return module.exports;
});
$__System.registerDynamic('34', ['32', '12', '2d', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var classof = $__require('32'),
      ITERATOR = $__require('12')('iterator'),
      Iterators = $__require('2d');
  module.exports = $__require('e').getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  return module.exports;
});
$__System.registerDynamic('35', ['12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR = $__require('12')('iterator'),
      SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {/* empty */}

  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {/* empty */}
    return safe;
  };
  return module.exports;
});
$__System.registerDynamic('36', ['37', '9', '2a', '2f', '30', '38', '31', '34', '35', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var ctx = $__require('37'),
      $export = $__require('9'),
      toObject = $__require('2a'),
      call = $__require('2f'),
      isArrayIter = $__require('30'),
      toLength = $__require('38'),
      createProperty = $__require('31'),
      getIterFn = $__require('34');

  $export($export.S + $export.F * !$__require('35')(function (iter) {
    Array.from(iter);
  }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /*, mapfn = undefined, thisArg = undefined*/) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          aLen = arguments.length,
          mapfn = aLen > 1 ? arguments[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });
  return module.exports;
});
$__System.registerDynamic('39', ['2e', '36', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('2e');
  $__require('36');
  module.exports = $__require('e').Array.from;
  return module.exports;
});
$__System.registerDynamic('3a', ['33', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.2 IsArray(argument)
  var cof = $__require('33');
  module.exports = Array.isArray || function isArray(arg) {
    return cof(arg) == 'Array';
  };
  return module.exports;
});
$__System.registerDynamic('3b', ['3c', '3a', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c'),
      isArray = $__require('3a'),
      SPECIES = $__require('12')('species');

  module.exports = function (original) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }return C === undefined ? Array : C;
  };
  return module.exports;
});
$__System.registerDynamic('3d', ['3b', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
  var speciesConstructor = $__require('3b');

  module.exports = function (original, length) {
    return new (speciesConstructor(original))(length);
  };
  return module.exports;
});
$__System.registerDynamic('a', ['37', '3e', '2a', '38', '3d', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex
  var ctx = $__require('37'),
      IObject = $__require('3e'),
      toObject = $__require('2a'),
      toLength = $__require('38'),
      asc = $__require('3d');
  module.exports = function (TYPE, $create) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
        create = $create || asc;
    return function ($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return module.exports;
});
$__System.registerDynamic('b', ['3f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var fails = $__require('3f');

  module.exports = function (method, arg) {
    return !!method && fails(function () {
      arg ? method.call(null, function () {}, 1) : method.call(null);
    });
  };
  return module.exports;
});
$__System.registerDynamic('40', ['9', 'a', 'b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $some = $__require('a')(3);

  $export($export.P + $export.F * !$__require('b')([].some, true), 'Array', {
    // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
    some: function some(callbackfn /* , thisArg */) {
      return $some(this, callbackfn, arguments[1]);
    }
  });
  return module.exports;
});
$__System.registerDynamic('41', ['40', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('40');
  module.exports = $__require('e').Array.some;
  return module.exports;
});
$__System.registerDynamic("42", ["c"], true, function ($__require, exports, module) {
                  var process = $__require("c");
                  var define,
                      global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
                  return module.exports;
});
$__System.registerDynamic('43', ['44', '3c', '42', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var aFunction = $__require('44'),
      isObject = $__require('3c'),
      invoke = $__require('42'),
      arraySlice = [].slice,
      factories = {};

  var construct = function (F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }return factories[len](F, args);
  };

  module.exports = Function.bind || function bind(that /*, args... */) {
    var fn = aFunction(this),
        partArgs = arraySlice.call(arguments, 1);
    var bound = function () /* args... */{
      var args = partArgs.concat(arraySlice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
    };
    if (isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
  };
  return module.exports;
});
$__System.registerDynamic('45', ['9', '43', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
  var $export = $__require('9');

  $export($export.P, 'Function', { bind: $__require('43') });
  return module.exports;
});
$__System.registerDynamic('46', ['45', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('45');
  module.exports = $__require('e').Function.bind;
  return module.exports;
});
$__System.registerDynamic('47', ['3e', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = $__require('3e'),
      defined = $__require('18');
  module.exports = function (it) {
    return IObject(defined(it));
  };
  return module.exports;
});
$__System.registerDynamic('48', ['17', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var toInteger = $__require('17'),
      max = Math.max,
      min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  return module.exports;
});
$__System.registerDynamic('49', ['47', '38', '48', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = $__require('47'),
      toLength = $__require('38'),
      toIndex = $__require('48');
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      // Array#includes uses SameValueZero equality algorithm
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
        // Array#toIndex ignores holes, Array#includes - not
      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }return !IS_INCLUDES && -1;
    };
  };
  return module.exports;
});
$__System.registerDynamic('23', ['4a', '4b', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var shared = $__require('4a')('keys'),
      uid = $__require('4b');
  module.exports = function (key) {
    return shared[key] || (shared[key] = uid(key));
  };
  return module.exports;
});
$__System.registerDynamic('4c', ['28', '47', '49', '23', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var has = $__require('28'),
      toIObject = $__require('47'),
      arrayIndexOf = $__require('49')(false),
      IE_PROTO = $__require('23')('IE_PROTO');

  module.exports = function (object, names) {
    var O = toIObject(object),
        i = 0,
        result = [],
        key;
    for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };
  return module.exports;
});
$__System.registerDynamic('22', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // IE 8- don't enum bug keys
  module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
  return module.exports;
});
$__System.registerDynamic('1d', ['4c', '22', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys = $__require('4c'),
      enumBugKeys = $__require('22');

  module.exports = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
  };
  return module.exports;
});
$__System.registerDynamic("4d", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.f = Object.getOwnPropertySymbols;
  return module.exports;
});
$__System.registerDynamic("4e", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.f = {}.propertyIsEnumerable;
  return module.exports;
});
$__System.registerDynamic('2a', ['18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.13 ToObject(argument)
  var defined = $__require('18');
  module.exports = function (it) {
    return Object(defined(it));
  };
  return module.exports;
});
$__System.registerDynamic('3e', ['33', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = $__require('33');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});
$__System.registerDynamic('4f', ['1d', '4d', '4e', '2a', '3e', '3f', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 19.1.2.1 Object.assign(target, source, ...)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var getKeys = $__require('1d'),
      gOPS = $__require('4d'),
      pIE = $__require('4e'),
      toObject = $__require('2a'),
      IObject = $__require('3e'),
      $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || $__require('3f')(function () {
    var A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars
    var T = toObject(target),
        aLen = arguments.length,
        index = 1,
        getSymbols = gOPS.f,
        isEnum = pIE.f;
    while (aLen > index) {
      var S = IObject(arguments[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }return T;
  } : $assign;
  return module.exports;
});
$__System.registerDynamic('50', ['9', '4f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.3.1 Object.assign(target, source)
  var $export = $__require('9');

  $export($export.S + $export.F, 'Object', { assign: $__require('4f') });
  return module.exports;
});
$__System.registerDynamic('51', ['50', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('50');
  module.exports = $__require('e').Object.assign;
  return module.exports;
});
$__System.registerDynamic('1c', ['3c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('24', ['3c', '20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c'),
      document = $__require('20').document
  // in old IE typeof document.createElement is 'object'
  ,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function (it) {
    return is ? document.createElement(it) : {};
  };
  return module.exports;
});
$__System.registerDynamic('52', ['1e', '3f', '24', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = !$__require('1e') && !$__require('3f')(function () {
    return Object.defineProperty($__require('24')('div'), 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
  return module.exports;
});
$__System.registerDynamic('53', ['3c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = $__require('3c');
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  return module.exports;
});
$__System.registerDynamic('1b', ['1c', '52', '53', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var anObject = $__require('1c'),
      IE8_DOM_DEFINE = $__require('52'),
      toPrimitive = $__require('53'),
      dP = Object.defineProperty;

  exports.f = $__require('1e') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) {/* empty */}
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  return module.exports;
});
$__System.registerDynamic("26", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return module.exports;
});
$__System.registerDynamic("3f", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});
$__System.registerDynamic('1e', ['3f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // Thank's IE8 for his funny defineProperty
  module.exports = !$__require('3f')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
  return module.exports;
});
$__System.registerDynamic('13', ['1b', '26', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var dP = $__require('1b'),
      createDesc = $__require('26');
  module.exports = $__require('1e') ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
  return module.exports;
});
$__System.registerDynamic("28", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
  return module.exports;
});
$__System.registerDynamic('2c', ['20', '13', '28', '4b', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      hide = $__require('13'),
      has = $__require('28'),
      SRC = $__require('4b')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);

  $__require('e').inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) has(val, 'name') || hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe) {
        delete O[key];
        hide(O, key, val);
      } else {
        if (O[key]) O[key] = val;else hide(O, key, val);
      }
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  return module.exports;
});
$__System.registerDynamic('44', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('37', ['44', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // optional / simple context binding
  var aFunction = $__require('44');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () /* ...args */{
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});
$__System.registerDynamic('9', ['20', 'e', '13', '2c', '37', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      core = $__require('e'),
      hide = $__require('13'),
      redefine = $__require('2c'),
      ctx = $__require('37'),
      PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // extend global
      if (target) redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  global.core = core;
  // type bitmap
  $export.F = 1; // forced
  $export.G = 2; // global
  $export.S = 4; // static
  $export.P = 8; // proto
  $export.B = 16; // bind
  $export.W = 32; // wrap
  $export.U = 64; // safe
  $export.R = 128; // real proto method for `library` 
  module.exports = $export;
  return module.exports;
});
$__System.registerDynamic("17", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return module.exports;
});
$__System.registerDynamic('38', ['17', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.15 ToLength
  var toInteger = $__require('17'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };
  return module.exports;
});
$__System.registerDynamic('3c', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});
$__System.registerDynamic("33", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});
$__System.registerDynamic('54', ['3c', '33', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.8 IsRegExp(argument)
  var isObject = $__require('3c'),
      cof = $__require('33'),
      MATCH = $__require('12')('match');
  module.exports = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  return module.exports;
});
$__System.registerDynamic("18", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('55', ['54', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // helper for String#{startsWith, endsWith, includes}
  var isRegExp = $__require('54'),
      defined = $__require('18');

  module.exports = function (that, searchString, NAME) {
    if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  return module.exports;
});
$__System.registerDynamic('4a', ['20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function (key) {
    return store[key] || (store[key] = {});
  };
  return module.exports;
});
$__System.registerDynamic('4b', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  return module.exports;
});
$__System.registerDynamic('20', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

  return module.exports;
});
$__System.registerDynamic('12', ['4a', '4b', '20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var store = $__require('4a')('wks'),
      uid = $__require('4b'),
      Symbol = $__require('20').Symbol,
      USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;
  return module.exports;
});
$__System.registerDynamic('56', ['12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var MATCH = $__require('12')('match');
  module.exports = function (KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {/* empty */}
    }return true;
  };
  return module.exports;
});
$__System.registerDynamic('57', ['9', '38', '55', '56', 'c'], true, function ($__require, exports, module) {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      toLength = $__require('38'),
      context = $__require('55'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];

  $export($export.P + $export.F * $__require('56')(STARTS_WITH), 'String', {
    startsWith: function startsWith(searchString /*, position = 0 */) {
      var that = context(this, searchString, STARTS_WITH),
          index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
  });
  return module.exports;
});
$__System.registerDynamic('e', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var core = module.exports = { version: '2.4.0' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

  return module.exports;
});
$__System.registerDynamic("@system-env", [], false, function() {
  return {
    "production": true,
    "browser": true,
    "node": false,
    "dev": false,
    "default": true
  };
});

$__System.registerDynamic('c', ['@system-env'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
    return module.exports;
});
$__System.registerDynamic('58', ['57', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('57');
  module.exports = $__require('e').String.startsWith;
  return module.exports;
});
$__System.registerDynamic("59", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("5a", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/css_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
            var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
            var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
            var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
            var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

            var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
            var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
            var pseudoClasses = exports.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

            var CssHighlightRules = function () {

                var keywordMapper = this.createKeywordMapper({
                    "support.function": supportFunction,
                    "support.constant": supportConstant,
                    "support.type": supportType,
                    "support.constant.color": supportConstantColor,
                    "support.constant.fonts": supportConstantFonts
                }, "text", true);

                this.$rules = {
                    "start": [{
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "paren.lparen",
                        regex: "\\{",
                        push: "ruleset"
                    }, {
                        token: "string",
                        regex: "@.*?{",
                        push: "media"
                    }, {
                        token: "keyword",
                        regex: "#[a-z0-9-_]+"
                    }, {
                        token: "variable",
                        regex: "\\.[a-z0-9-_]+"
                    }, {
                        token: "string",
                        regex: ":[a-z0-9-_]+"
                    }, {
                        token: "constant",
                        regex: "[a-z0-9-_]+"
                    }, {
                        caseInsensitive: true
                    }],

                    "media": [{
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "paren.lparen",
                        regex: "\\{",
                        push: "ruleset"
                    }, {
                        token: "string",
                        regex: "\\}",
                        next: "pop"
                    }, {
                        token: "keyword",
                        regex: "#[a-z0-9-_]+"
                    }, {
                        token: "variable",
                        regex: "\\.[a-z0-9-_]+"
                    }, {
                        token: "string",
                        regex: ":[a-z0-9-_]+"
                    }, {
                        token: "constant",
                        regex: "[a-z0-9-_]+"
                    }, {
                        caseInsensitive: true
                    }],

                    "comment": [{
                        token: "comment",
                        regex: "\\*\\/",
                        next: "pop"
                    }, {
                        defaultToken: "comment"
                    }],

                    "ruleset": [{
                        token: "paren.rparen",
                        regex: "\\}",
                        next: "pop"
                    }, {
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "string", // single line
                        regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                    }, {
                        token: "string", // single line
                        regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token: ["constant.numeric", "keyword"],
                        regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
                    }, {
                        token: "constant.numeric",
                        regex: numRe
                    }, {
                        token: "constant.numeric", // hex6 color
                        regex: "#[a-f0-9]{6}"
                    }, {
                        token: "constant.numeric", // hex3 color
                        regex: "#[a-f0-9]{3}"
                    }, {
                        token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
                        regex: pseudoElements
                    }, {
                        token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
                        regex: pseudoClasses
                    }, {
                        token: ["support.function", "string", "support.function"],
                        regex: "(url\\()(.*)(\\))"
                    }, {
                        token: keywordMapper,
                        regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
                    }, {
                        caseInsensitive: true
                    }]
                };

                this.normalizeRules();
            };

            oop.inherits(CssHighlightRules, TextHighlightRules);

            exports.CssHighlightRules = CssHighlightRules;
        });

        ace.define("ace/mode/css_completions", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var propertyMap = {
                "background": { "#$0": 1 },
                "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
                "background-image": { "url('/$0')": 1 },
                "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
                "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
                "background-attachment": { "scroll": 1, "fixed": 1 },
                "background-size": { "cover": 1, "contain": 1 },
                "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
                "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
                "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
                "border-color": { "#$0": 1 },
                "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
                "border-collapse": { "collapse": 1, "separate": 1 },
                "bottom": { "px": 1, "em": 1, "%": 1 },
                "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
                "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
                "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
                "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
                "empty-cells": { "show": 1, "hide": 1 },
                "float": { "left": 1, "right": 1, "none": 1 },
                "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
                "font-size": { "px": 1, "em": 1, "%": 1 },
                "font-weight": { "bold": 1, "normal": 1 },
                "font-style": { "italic": 1, "normal": 1 },
                "font-variant": { "normal": 1, "small-caps": 1 },
                "height": { "px": 1, "em": 1, "%": 1 },
                "left": { "px": 1, "em": 1, "%": 1 },
                "letter-spacing": { "normal": 1 },
                "line-height": { "normal": 1 },
                "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
                "margin": { "px": 1, "em": 1, "%": 1 },
                "margin-right": { "px": 1, "em": 1, "%": 1 },
                "margin-left": { "px": 1, "em": 1, "%": 1 },
                "margin-top": { "px": 1, "em": 1, "%": 1 },
                "margin-bottom": { "px": 1, "em": 1, "%": 1 },
                "max-height": { "px": 1, "em": 1, "%": 1 },
                "max-width": { "px": 1, "em": 1, "%": 1 },
                "min-height": { "px": 1, "em": 1, "%": 1 },
                "min-width": { "px": 1, "em": 1, "%": 1 },
                "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "padding": { "px": 1, "em": 1, "%": 1 },
                "padding-top": { "px": 1, "em": 1, "%": 1 },
                "padding-right": { "px": 1, "em": 1, "%": 1 },
                "padding-bottom": { "px": 1, "em": 1, "%": 1 },
                "padding-left": { "px": 1, "em": 1, "%": 1 },
                "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
                "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
                "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
                "right": { "px": 1, "em": 1, "%": 1 },
                "table-layout": { "fixed": 1, "auto": 1 },
                "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
                "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
                "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
                "top": { "px": 1, "em": 1, "%": 1 },
                "vertical-align": { "top": 1, "bottom": 1 },
                "visibility": { "hidden": 1, "visible": 1 },
                "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
                "width": { "px": 1, "em": 1, "%": 1 },
                "word-spacing": { "normal": 1 },
                "filter": { "alpha(opacity=$0100)": 1 },

                "text-shadow": { "$02px 2px 2px #777": 1 },
                "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
                "-moz-border-radius": 1,
                "-moz-border-radius-topright": 1,
                "-moz-border-radius-bottomright": 1,
                "-moz-border-radius-topleft": 1,
                "-moz-border-radius-bottomleft": 1,
                "-webkit-border-radius": 1,
                "-webkit-border-top-right-radius": 1,
                "-webkit-border-top-left-radius": 1,
                "-webkit-border-bottom-right-radius": 1,
                "-webkit-border-bottom-left-radius": 1,
                "-moz-box-shadow": 1,
                "-webkit-box-shadow": 1,
                "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
                "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
                "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
            };

            var CssCompletions = function () {};

            (function () {

                this.completionsDefined = false;

                this.defineCompletions = function () {
                    if (document) {
                        var style = document.createElement('c').style;

                        for (var i in style) {
                            if (typeof style[i] !== 'string') continue;

                            var name = i.replace(/[A-Z]/g, function (x) {
                                return '-' + x.toLowerCase();
                            });

                            if (!propertyMap.hasOwnProperty(name)) propertyMap[name] = 1;
                        }
                    }

                    this.completionsDefined = true;
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    if (!this.completionsDefined) {
                        this.defineCompletions();
                    }

                    var token = session.getTokenAt(pos.row, pos.column);

                    if (!token) return [];
                    if (state === 'ruleset') {
                        var line = session.getLine(pos.row).substr(0, pos.column);
                        if (/:[^;]+$/.test(line)) {
                            /([\w\-]+):[^:]*$/.test(line);

                            return this.getPropertyValueCompletions(state, session, pos, prefix);
                        } else {
                            return this.getPropertyCompletions(state, session, pos, prefix);
                        }
                    }

                    return [];
                };

                this.getPropertyCompletions = function (state, session, pos, prefix) {
                    var properties = Object.keys(propertyMap);
                    return properties.map(function (property) {
                        return {
                            caption: property,
                            snippet: property + ': $0',
                            meta: "property",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getPropertyValueCompletions = function (state, session, pos, prefix) {
                    var line = session.getLine(pos.row).substr(0, pos.column);
                    var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];

                    if (!property) return [];
                    var values = [];
                    if (property in propertyMap && typeof propertyMap[property] === "object") {
                        values = Object.keys(propertyMap[property]);
                    }
                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "property value",
                            score: Number.MAX_VALUE
                        };
                    });
                };
            }).call(CssCompletions.prototype);

            exports.CssCompletions = CssCompletions;
        });

        ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;

            var CssBehaviour = function () {

                this.inherit(CstyleBehaviour);

                this.add("colon", "insertion", function (state, action, editor, session, text) {
                    if (text === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === ':') {
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                            if (!line.substring(cursor.column).match(/^\s*;/)) {
                                return {
                                    text: ':;',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("colon", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.end.column, range.end.column + 1);
                            if (rightChar === ';') {
                                range.end.column++;
                                return range;
                            }
                        }
                    }
                });

                this.add("semicolon", "insertion", function (state, action, editor, session, text) {
                    if (text === ';') {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === ';') {
                            return {
                                text: '',
                                selection: [1, 1]
                            };
                        }
                    }
                });
            };
            oop.inherits(CssBehaviour, CstyleBehaviour);

            exports.CssBehaviour = CssBehaviour;
        });

        ace.define("ace/mode/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/css_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/css_completions", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CssCompletions = require("./css_completions").CssCompletions;
            var CssBehaviour = require("./behaviour/css").CssBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = CssHighlightRules;
                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CssBehaviour();
                this.$completer = new CssCompletions();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.foldingRules = "cStyle";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);
                    var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    var match = line.match(/^.*\{\s*$/);
                    if (match) {
                        indent += tab;
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    return this.$completer.getCompletions(state, session, pos, prefix);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (e) {
                        session.setAnnotations(e.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/css";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/xml_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var XmlHighlightRules = function (normalize) {
                var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

                this.$rules = {
                    start: [{ token: "string.cdata.xml", regex: "<\\!\\[CDATA\\[", next: "cdata" }, {
                        token: ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                        regex: "(<\\?)(xml)(?=[\\s])", next: "xml_decl", caseInsensitive: true
                    }, {
                        token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
                        regex: "(<\\?)(" + tagRegex + ")", next: "processing_instruction"
                    }, { token: "comment.xml", regex: "<\\!--", next: "comment" }, {
                        token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                        regex: "(<\\!)(DOCTYPE)(?=[\\s])", next: "doctype", caseInsensitive: true
                    }, { include: "tag" }, { token: "text.end-tag-open.xml", regex: "</" }, { token: "text.tag-open.xml", regex: "<" }, { include: "reference" }, { defaultToken: "text.xml" }],

                    xml_decl: [{
                        token: "entity.other.attribute-name.decl-attribute-name.xml",
                        regex: "(?:" + tagRegex + ":)?" + tagRegex + ""
                    }, {
                        token: "keyword.operator.decl-attribute-equals.xml",
                        regex: "="
                    }, {
                        include: "whitespace"
                    }, {
                        include: "string"
                    }, {
                        token: "punctuation.xml-decl.xml",
                        regex: "\\?>",
                        next: "start"
                    }],

                    processing_instruction: [{ token: "punctuation.instruction.xml", regex: "\\?>", next: "start" }, { defaultToken: "instruction.xml" }],

                    doctype: [{ include: "whitespace" }, { include: "string" }, { token: "xml-pe.doctype.xml", regex: ">", next: "start" }, { token: "xml-pe.xml", regex: "[-_a-zA-Z0-9:]+" }, { token: "punctuation.int-subset", regex: "\\[", push: "int_subset" }],

                    int_subset: [{
                        token: "text.xml",
                        regex: "\\s+"
                    }, {
                        token: "punctuation.int-subset.xml",
                        regex: "]",
                        next: "pop"
                    }, {
                        token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
                        regex: "(<\\!)(" + tagRegex + ")",
                        push: [{
                            token: "text",
                            regex: "\\s+"
                        }, {
                            token: "punctuation.markup-decl.xml",
                            regex: ">",
                            next: "pop"
                        }, { include: "string" }]
                    }],

                    cdata: [{ token: "string.cdata.xml", regex: "\\]\\]>", next: "start" }, { token: "text.xml", regex: "\\s+" }, { token: "text.xml", regex: "(?:[^\\]]|\\](?!\\]>))+" }],

                    comment: [{ token: "comment.xml", regex: "-->", next: "start" }, { defaultToken: "comment.xml" }],

                    reference: [{
                        token: "constant.language.escape.reference.xml",
                        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                    }],

                    attr_reference: [{
                        token: "constant.language.escape.reference.attribute-value.xml",
                        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                    }],

                    tag: [{
                        token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
                        regex: "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
                        next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                    }],

                    tag_whitespace: [{ token: "text.tag-whitespace.xml", regex: "\\s+" }],
                    whitespace: [{ token: "text.whitespace.xml", regex: "\\s+" }],
                    string: [{
                        token: "string.xml",
                        regex: "'",
                        push: [{ token: "string.xml", regex: "'", next: "pop" }, { defaultToken: "string.xml" }]
                    }, {
                        token: "string.xml",
                        regex: '"',
                        push: [{ token: "string.xml", regex: '"', next: "pop" }, { defaultToken: "string.xml" }]
                    }],

                    attributes: [{
                        token: "entity.other.attribute-name.xml",
                        regex: "(?:" + tagRegex + ":)?" + tagRegex + ""
                    }, {
                        token: "keyword.operator.attribute-equals.xml",
                        regex: "="
                    }, {
                        include: "tag_whitespace"
                    }, {
                        include: "attribute_value"
                    }],

                    attribute_value: [{
                        token: "string.attribute-value.xml",
                        regex: "'",
                        push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                    }, {
                        token: "string.attribute-value.xml",
                        regex: '"',
                        push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                    }]
                };

                if (this.constructor === XmlHighlightRules) this.normalizeRules();
            };

            (function () {

                this.embedTagRules = function (HighlightRules, prefix, tag) {
                    this.$rules.tag.unshift({
                        token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                        regex: "(<)(" + tag + "(?=\\s|>|$))",
                        next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: prefix + "start" }]
                    });

                    this.$rules[tag + "-end"] = [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start",
                        onMatch: function (value, currentState, stack) {
                            stack.splice(0);
                            return this.token;
                        } }];

                    this.embedRules(HighlightRules, prefix, [{
                        token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                        regex: "(</)(" + tag + "(?=\\s|>|$))",
                        next: tag + "-end"
                    }, {
                        token: "string.cdata.xml",
                        regex: "<\\!\\[CDATA\\["
                    }, {
                        token: "string.cdata.xml",
                        regex: "\\]\\]>"
                    }]);
                };
            }).call(TextHighlightRules.prototype);

            oop.inherits(XmlHighlightRules, TextHighlightRules);

            exports.XmlHighlightRules = XmlHighlightRules;
        });

        ace.define("ace/mode/html_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/css_highlight_rules", "ace/mode/javascript_highlight_rules", "ace/mode/xml_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;

            var tagMap = lang.createMap({
                a: 'anchor',
                button: 'form',
                form: 'form',
                img: 'image',
                input: 'form',
                label: 'form',
                option: 'form',
                script: 'script',
                select: 'form',
                textarea: 'form',
                style: 'style',
                table: 'table',
                tbody: 'table',
                td: 'table',
                tfoot: 'table',
                th: 'table',
                tr: 'table'
            });

            var HtmlHighlightRules = function () {
                XmlHighlightRules.call(this);

                this.addRules({
                    attributes: [{
                        include: "tag_whitespace"
                    }, {
                        token: "entity.other.attribute-name.xml",
                        regex: "[-_a-zA-Z0-9:.]+"
                    }, {
                        token: "keyword.operator.attribute-equals.xml",
                        regex: "=",
                        push: [{
                            include: "tag_whitespace"
                        }, {
                            token: "string.unquoted.attribute-value.html",
                            regex: "[^<>='\"`\\s]+",
                            next: "pop"
                        }, {
                            token: "empty",
                            regex: "",
                            next: "pop"
                        }]
                    }, {
                        include: "attribute_value"
                    }],
                    tag: [{
                        token: function (start, tag) {
                            var group = tagMap[tag];
                            return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml", "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
                        },
                        regex: "(</?)([-_a-zA-Z0-9:.]+)",
                        next: "tag_stuff"
                    }],
                    tag_stuff: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                });

                this.embedTagRules(CssHighlightRules, "css-", "style");
                this.embedTagRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), "js-", "script");

                if (this.constructor === HtmlHighlightRules) this.normalizeRules();
            };

            oop.inherits(HtmlHighlightRules, XmlHighlightRules);

            exports.HtmlHighlightRules = HtmlHighlightRules;
        });

        ace.define("ace/mode/behaviour/xml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;
            var lang = require("../../lib/lang");

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            var XmlBehaviour = function () {

                this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                    if (text == '"' || text == "'") {
                        var quote = text;
                        var selected = session.doc.getTextRange(editor.getSelectionRange());
                        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                            return {
                                text: quote + selected + quote,
                                selection: false
                            };
                        }

                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();

                        if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                            return {
                                text: "",
                                selection: [1, 1]
                            };
                        }

                        if (!token) token = iterator.stepBackward();

                        if (!token) return;

                        while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                            token = iterator.stepBackward();
                        }
                        var rightSpace = !rightChar || rightChar.match(/\s/);
                        if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?')) {
                            return {
                                text: quote + quote,
                                selection: [1, 1]
                            };
                        }
                    }
                });

                this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == selected) {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
                    if (text == '>') {
                        var position = editor.getSelectionRange().start;
                        var iterator = new TokenIterator(session, position.row, position.column);
                        var token = iterator.getCurrentToken() || iterator.stepBackward();
                        if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value"))) return;
                        if (is(token, "reference.attribute-value")) return;
                        if (is(token, "attribute-value")) {
                            var firstChar = token.value.charAt(0);
                            if (firstChar == '"' || firstChar == "'") {
                                var lastChar = token.value.charAt(token.value.length - 1);
                                var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                                if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar) return;
                            }
                        }
                        while (!is(token, "tag-name")) {
                            token = iterator.stepBackward();
                            if (token.value == "<") {
                                token = iterator.stepForward();
                                break;
                            }
                        }

                        var tokenRow = iterator.getCurrentTokenRow();
                        var tokenColumn = iterator.getCurrentTokenColumn();
                        if (is(iterator.stepBackward(), "end-tag-open")) return;

                        var element = token.value;
                        if (tokenRow == position.row) element = element.substring(0, position.column - tokenColumn);

                        if (this.voidElements.hasOwnProperty(element.toLowerCase())) return;

                        return {
                            text: ">" + "</" + element + ">",
                            selection: [1, 1]
                        };
                    }
                });

                this.add("autoindent", "insertion", function (state, action, editor, session, text) {
                    if (text == "\n") {
                        var cursor = editor.getCursorPosition();
                        var line = session.getLine(cursor.row);
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();

                        if (token && token.type.indexOf("tag-close") !== -1) {
                            if (token.value == "/>") return;
                            while (token && token.type.indexOf("tag-name") === -1) {
                                token = iterator.stepBackward();
                            }

                            if (!token) {
                                return;
                            }

                            var tag = token.value;
                            var row = iterator.getCurrentTokenRow();
                            token = iterator.stepBackward();
                            if (!token || token.type.indexOf("end-tag") !== -1) {
                                return;
                            }

                            if (this.voidElements && !this.voidElements[tag]) {
                                var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
                                var line = session.getLine(row);
                                var nextIndent = this.$getIndent(line);
                                var indent = nextIndent + session.getTabString();

                                if (nextToken && nextToken.value === "</") {
                                    return {
                                        text: "\n" + indent + "\n" + nextIndent,
                                        selection: [1, indent.length, 1, indent.length]
                                    };
                                } else {
                                    return {
                                        text: "\n" + indent
                                    };
                                }
                            }
                        }
                    }
                });
            };

            oop.inherits(XmlBehaviour, Behaviour);

            exports.XmlBehaviour = XmlBehaviour;
        });

        ace.define("ace/mode/folding/mixed", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (defaultMode, subModes) {
                this.defaultMode = defaultMode;
                this.subModes = subModes;
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.$getMode = function (state) {
                    if (typeof state != "string") state = state[0];
                    for (var key in this.subModes) {
                        if (state.indexOf(key) === 0) return this.subModes[key];
                    }
                    return null;
                };

                this.$tryMode = function (state, session, foldStyle, row) {
                    var mode = this.$getMode(state);
                    return mode ? mode.getFoldWidget(session, foldStyle, row) : "";
                };

                this.getFoldWidget = function (session, foldStyle, row) {
                    return this.$tryMode(session.getState(row - 1), session, foldStyle, row) || this.$tryMode(session.getState(row), session, foldStyle, row) || this.defaultMode.getFoldWidget(session, foldStyle, row);
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var mode = this.$getMode(session.getState(row - 1));

                    if (!mode || !mode.getFoldWidget(session, foldStyle, row)) mode = this.$getMode(session.getState(row));

                    if (!mode || !mode.getFoldWidget(session, foldStyle, row)) mode = this.defaultMode;

                    return mode.getFoldWidgetRange(session, foldStyle, row);
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/folding/xml", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/range", "ace/mode/folding/fold_mode", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var lang = require("../../lib/lang");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;
            var TokenIterator = require("../../token_iterator").TokenIterator;

            var FoldMode = exports.FoldMode = function (voidElements, optionalEndTags) {
                BaseFoldMode.call(this);
                this.voidElements = voidElements || {};
                this.optionalEndTags = oop.mixin({}, this.voidElements);
                if (optionalEndTags) oop.mixin(this.optionalEndTags, optionalEndTags);
            };
            oop.inherits(FoldMode, BaseFoldMode);

            var Tag = function () {
                this.tagName = "";
                this.closing = false;
                this.selfClosing = false;
                this.start = { row: 0, column: 0 };
                this.end = { row: 0, column: 0 };
            };

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            (function () {

                this.getFoldWidget = function (session, foldStyle, row) {
                    var tag = this._getFirstTagInLine(session, row);

                    if (!tag) return "";

                    if (tag.closing || !tag.tagName && tag.selfClosing) return foldStyle == "markbeginend" ? "end" : "";

                    if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase())) return "";

                    if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column)) return "";

                    return "start";
                };
                this._getFirstTagInLine = function (session, row) {
                    var tokens = session.getTokens(row);
                    var tag = new Tag();

                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        if (is(token, "tag-open")) {
                            tag.end.column = tag.start.column + token.value.length;
                            tag.closing = is(token, "end-tag-open");
                            token = tokens[++i];
                            if (!token) return null;
                            tag.tagName = token.value;
                            tag.end.column += token.value.length;
                            for (i++; i < tokens.length; i++) {
                                token = tokens[i];
                                tag.end.column += token.value.length;
                                if (is(token, "tag-close")) {
                                    tag.selfClosing = token.value == '/>';
                                    break;
                                }
                            }
                            return tag;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == '/>';
                            return tag;
                        }
                        tag.start.column += token.value.length;
                    }

                    return null;
                };

                this._findEndTagInLine = function (session, row, tagName, startColumn) {
                    var tokens = session.getTokens(row);
                    var column = 0;
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        column += token.value.length;
                        if (column < startColumn) continue;
                        if (is(token, "end-tag-open")) {
                            token = tokens[i + 1];
                            if (token && token.value == tagName) return true;
                        }
                    }
                    return false;
                };
                this._readTagForward = function (iterator) {
                    var token = iterator.getCurrentToken();
                    if (!token) return null;

                    var tag = new Tag();
                    do {
                        if (is(token, "tag-open")) {
                            tag.closing = is(token, "end-tag-open");
                            tag.start.row = iterator.getCurrentTokenRow();
                            tag.start.column = iterator.getCurrentTokenColumn();
                        } else if (is(token, "tag-name")) {
                            tag.tagName = token.value;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == "/>";
                            tag.end.row = iterator.getCurrentTokenRow();
                            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                            iterator.stepForward();
                            return tag;
                        }
                    } while (token = iterator.stepForward());

                    return null;
                };

                this._readTagBackward = function (iterator) {
                    var token = iterator.getCurrentToken();
                    if (!token) return null;

                    var tag = new Tag();
                    do {
                        if (is(token, "tag-open")) {
                            tag.closing = is(token, "end-tag-open");
                            tag.start.row = iterator.getCurrentTokenRow();
                            tag.start.column = iterator.getCurrentTokenColumn();
                            iterator.stepBackward();
                            return tag;
                        } else if (is(token, "tag-name")) {
                            tag.tagName = token.value;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == "/>";
                            tag.end.row = iterator.getCurrentTokenRow();
                            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                        }
                    } while (token = iterator.stepBackward());

                    return null;
                };

                this._pop = function (stack, tag) {
                    while (stack.length) {

                        var top = stack[stack.length - 1];
                        if (!tag || top.tagName == tag.tagName) {
                            return stack.pop();
                        } else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                            stack.pop();
                            continue;
                        } else {
                            return null;
                        }
                    }
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var firstTag = this._getFirstTagInLine(session, row);

                    if (!firstTag) return null;

                    var isBackward = firstTag.closing || firstTag.selfClosing;
                    var stack = [];
                    var tag;

                    if (!isBackward) {
                        var iterator = new TokenIterator(session, row, firstTag.start.column);
                        var start = {
                            row: row,
                            column: firstTag.start.column + firstTag.tagName.length + 2
                        };
                        if (firstTag.start.row == firstTag.end.row) start.column = firstTag.end.column;
                        while (tag = this._readTagForward(iterator)) {
                            if (tag.selfClosing) {
                                if (!stack.length) {
                                    tag.start.column += tag.tagName.length + 2;
                                    tag.end.column -= 2;
                                    return Range.fromPoints(tag.start, tag.end);
                                } else continue;
                            }

                            if (tag.closing) {
                                this._pop(stack, tag);
                                if (stack.length == 0) return Range.fromPoints(start, tag.start);
                            } else {
                                stack.push(tag);
                            }
                        }
                    } else {
                        var iterator = new TokenIterator(session, row, firstTag.end.column);
                        var end = {
                            row: row,
                            column: firstTag.start.column
                        };

                        while (tag = this._readTagBackward(iterator)) {
                            if (tag.selfClosing) {
                                if (!stack.length) {
                                    tag.start.column += tag.tagName.length + 2;
                                    tag.end.column -= 2;
                                    return Range.fromPoints(tag.start, tag.end);
                                } else continue;
                            }

                            if (!tag.closing) {
                                this._pop(stack, tag);
                                if (stack.length == 0) {
                                    tag.start.column += tag.tagName.length + 2;
                                    if (tag.start.row == tag.end.row && tag.start.column < tag.end.column) tag.start.column = tag.end.column;
                                    return Range.fromPoints(tag.start, end);
                                }
                            } else {
                                stack.push(tag);
                            }
                        }
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/folding/html", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/mixed", "ace/mode/folding/xml", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var MixedFoldMode = require("./mixed").FoldMode;
            var XmlFoldMode = require("./xml").FoldMode;
            var CStyleFoldMode = require("./cstyle").FoldMode;

            var FoldMode = exports.FoldMode = function (voidElements, optionalTags) {
                MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
                    "js-": new CStyleFoldMode(),
                    "css-": new CStyleFoldMode()
                });
            };

            oop.inherits(FoldMode, MixedFoldMode);
        });

        ace.define("ace/mode/html_completions", ["require", "exports", "module", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var TokenIterator = require("../token_iterator").TokenIterator;

            var commonAttributes = ["accesskey", "class", "contenteditable", "contextmenu", "dir", "draggable", "dropzone", "hidden", "id", "inert", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "spellcheck", "style", "tabindex", "title", "translate"];

            var eventAttributes = ["onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];

            var globalAttributes = commonAttributes.concat(eventAttributes);

            var attributeMap = {
                "html": { "manifest": 1 },
                "head": {},
                "title": {},
                "base": { "href": 1, "target": 1 },
                "link": { "href": 1, "hreflang": 1, "rel": { "stylesheet": 1, "icon": 1 }, "media": { "all": 1, "screen": 1, "print": 1 }, "type": { "text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1 }, "sizes": 1 },
                "meta": { "http-equiv": { "content-type": 1 }, "name": { "description": 1, "keywords": 1 }, "content": { "text/html; charset=UTF-8": 1 }, "charset": 1 },
                "style": { "type": 1, "media": { "all": 1, "screen": 1, "print": 1 }, "scoped": 1 },
                "script": { "charset": 1, "type": { "text/javascript": 1 }, "src": 1, "defer": 1, "async": 1 },
                "noscript": { "href": 1 },
                "body": { "onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1 },
                "section": {},
                "nav": {},
                "article": { "pubdate": 1 },
                "aside": {},
                "h1": {},
                "h2": {},
                "h3": {},
                "h4": {},
                "h5": {},
                "h6": {},
                "header": {},
                "footer": {},
                "address": {},
                "main": {},
                "p": {},
                "hr": {},
                "pre": {},
                "blockquote": { "cite": 1 },
                "ol": { "start": 1, "reversed": 1 },
                "ul": {},
                "li": { "value": 1 },
                "dl": {},
                "dt": {},
                "dd": {},
                "figure": {},
                "figcaption": {},
                "div": {},
                "a": { "href": 1, "target": { "_blank": 1, "top": 1 }, "ping": 1, "rel": { "nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1 }, "media": 1, "hreflang": 1, "type": 1 },
                "em": {},
                "strong": {},
                "small": {},
                "s": {},
                "cite": {},
                "q": { "cite": 1 },
                "dfn": {},
                "abbr": {},
                "data": {},
                "time": { "datetime": 1 },
                "code": {},
                "var": {},
                "samp": {},
                "kbd": {},
                "sub": {},
                "sup": {},
                "i": {},
                "b": {},
                "u": {},
                "mark": {},
                "ruby": {},
                "rt": {},
                "rp": {},
                "bdi": {},
                "bdo": {},
                "span": {},
                "br": {},
                "wbr": {},
                "ins": { "cite": 1, "datetime": 1 },
                "del": { "cite": 1, "datetime": 1 },
                "img": { "alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1 },
                "iframe": { "name": 1, "src": 1, "height": 1, "width": 1, "sandbox": { "allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1 }, "seamless": { "seamless": 1 } },
                "embed": { "src": 1, "height": 1, "width": 1, "type": 1 },
                "object": { "param": 1, "data": 1, "type": 1, "height": 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1 },
                "param": { "name": 1, "value": 1 },
                "video": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "width": 1, "height": 1, "poster": 1, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
                "audio": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
                "source": { "src": 1, "type": 1, "media": 1 },
                "track": { "kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1 },
                "canvas": { "width": 1, "height": 1 },
                "map": { "name": 1 },
                "area": { "shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1 },
                "svg": {},
                "math": {},
                "table": { "summary": 1 },
                "caption": {},
                "colgroup": { "span": 1 },
                "col": { "span": 1 },
                "tbody": {},
                "thead": {},
                "tfoot": {},
                "tr": {},
                "td": { "headers": 1, "rowspan": 1, "colspan": 1 },
                "th": { "headers": 1, "rowspan": 1, "colspan": 1, "scope": 1 },
                "form": { "accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": { "multipart/form-data": 1, "application/x-www-form-urlencoded": 1 }, "method": { "get": 1, "post": 1 }, "name": 1, "novalidate": 1, "target": { "_blank": 1, "top": 1 } },
                "fieldset": { "disabled": 1, "form": 1, "name": 1 },
                "legend": {},
                "label": { "form": 1, "for": 1 },
                "input": {
                    "type": { "text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1 },
                    "accept": 1, "alt": 1, "autocomplete": { "on": 1, "off": 1 }, "autofocus": { "autofocus": 1 }, "checked": { "checked": 1 }, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": { "application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1 }, "formmethod": { "get": 1, "post": 1 }, "formnovalidate": { "formnovalidate": 1 }, "formtarget": { "_blank": 1, "_self": 1, "_parent": 1, "_top": 1 }, "height": 1, "list": 1, "max": 1, "maxlength": 1, "min": 1, "multiple": { "multiple": 1 }, "name": 1, "pattern": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "size": 1, "src": 1, "step": 1, "width": 1, "files": 1, "value": 1 },
                "button": { "autofocus": 1, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": { "button": 1, "submit": 1 } },
                "select": { "autofocus": 1, "disabled": 1, "form": 1, "multiple": { "multiple": 1 }, "name": 1, "size": 1, "readonly": { "readonly": 1 } },
                "datalist": {},
                "optgroup": { "disabled": 1, "label": 1 },
                "option": { "disabled": 1, "selected": 1, "label": 1, "value": 1 },
                "textarea": { "autofocus": { "autofocus": 1 }, "disabled": { "disabled": 1 }, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "rows": 1, "cols": 1, "wrap": { "on": 1, "off": 1, "hard": 1, "soft": 1 } },
                "keygen": { "autofocus": 1, "challenge": { "challenge": 1 }, "disabled": { "disabled": 1 }, "form": 1, "keytype": { "rsa": 1, "dsa": 1, "ec": 1 }, "name": 1 },
                "output": { "for": 1, "form": 1, "name": 1 },
                "progress": { "value": 1, "max": 1 },
                "meter": { "value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1 },
                "details": { "open": 1 },
                "summary": {},
                "command": { "type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1 },
                "menu": { "type": 1, "label": 1 },
                "dialog": { "open": 1 }
            };

            var elements = Object.keys(attributeMap);

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            function findTagName(session, pos) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                while (token && !is(token, "tag-name")) {
                    token = iterator.stepBackward();
                }
                if (token) return token.value;
            }

            function findAttributeName(session, pos) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                while (token && !is(token, "attribute-name")) {
                    token = iterator.stepBackward();
                }
                if (token) return token.value;
            }

            var HtmlCompletions = function () {};

            (function () {

                this.getCompletions = function (state, session, pos, prefix) {
                    var token = session.getTokenAt(pos.row, pos.column);

                    if (!token) return [];
                    if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open")) return this.getTagCompletions(state, session, pos, prefix);
                    if (is(token, "tag-whitespace") || is(token, "attribute-name")) return this.getAttributeCompletions(state, session, pos, prefix);
                    if (is(token, "attribute-value")) return this.getAttributeValueCompletions(state, session, pos, prefix);
                    var line = session.getLine(pos.row).substr(0, pos.column);
                    if (/&[A-z]*$/i.test(line)) return this.getHTMLEntityCompletions(state, session, pos, prefix);

                    return [];
                };

                this.getTagCompletions = function (state, session, pos, prefix) {
                    return elements.map(function (element) {
                        return {
                            value: element,
                            meta: "tag",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getAttributeCompletions = function (state, session, pos, prefix) {
                    var tagName = findTagName(session, pos);
                    if (!tagName) return [];
                    var attributes = globalAttributes;
                    if (tagName in attributeMap) {
                        attributes = attributes.concat(Object.keys(attributeMap[tagName]));
                    }
                    return attributes.map(function (attribute) {
                        return {
                            caption: attribute,
                            snippet: attribute + '="$0"',
                            meta: "attribute",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getAttributeValueCompletions = function (state, session, pos, prefix) {
                    var tagName = findTagName(session, pos);
                    var attributeName = findAttributeName(session, pos);

                    if (!tagName) return [];
                    var values = [];
                    if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
                        values = Object.keys(attributeMap[tagName][attributeName]);
                    }
                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "attribute value",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getHTMLEntityCompletions = function (state, session, pos, prefix) {
                    var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];

                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "html entity",
                            score: Number.MAX_VALUE
                        };
                    });
                };
            }).call(HtmlCompletions.prototype);

            exports.HtmlCompletions = HtmlCompletions;
        });

        ace.define("ace/mode/html", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text", "ace/mode/javascript", "ace/mode/css", "ace/mode/html_highlight_rules", "ace/mode/behaviour/xml", "ace/mode/folding/html", "ace/mode/html_completions", "ace/worker/worker_client"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var TextMode = require("./text").Mode;
            var JavaScriptMode = require("./javascript").Mode;
            var CssMode = require("./css").Mode;
            var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
            var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
            var HtmlFoldMode = require("./folding/html").FoldMode;
            var HtmlCompletions = require("./html_completions").HtmlCompletions;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
            var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

            var Mode = function (options) {
                this.fragmentContext = options && options.fragmentContext;
                this.HighlightRules = HtmlHighlightRules;
                this.$behaviour = new XmlBehaviour();
                this.$completer = new HtmlCompletions();

                this.createModeDelegates({
                    "js-": JavaScriptMode,
                    "css-": CssMode
                });

                this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.blockComment = { start: "<!--", end: "-->" };

                this.voidElements = lang.arrayToMap(voidElements);

                this.getNextLineIndent = function (state, line, tab) {
                    return this.$getIndent(line);
                };

                this.checkOutdent = function (state, line, input) {
                    return false;
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    return this.$completer.getCompletions(state, session, pos, prefix);
                };

                this.createWorker = function (session) {
                    if (this.constructor != Mode) return;
                    var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
                    worker.attachToDocument(session.getDocument());

                    if (this.fragmentContext) worker.call("setOptions", [{ context: this.fragmentContext }]);

                    worker.on("error", function (e) {
                        session.setAnnotations(e.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/html";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5c", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/java_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var JavaHighlightRules = function () {
                var keywords = "abstract|continue|for|new|switch|" + "assert|default|goto|package|synchronized|" + "boolean|do|if|private|this|" + "break|double|implements|protected|throw|" + "byte|else|import|public|throws|" + "case|enum|instanceof|return|transient|" + "catch|extends|int|short|try|" + "char|final|interface|static|void|" + "class|finally|long|strictfp|volatile|" + "const|float|native|super|while";

                var buildinConstants = "null|Infinity|NaN|undefined";

                var langClasses = "AbstractMethodError|AssertionError|ClassCircularityError|" + "ClassFormatError|Deprecated|EnumConstantNotPresentException|" + "ExceptionInInitializerError|IllegalAccessError|" + "IllegalThreadStateException|InstantiationError|InternalError|" + "NegativeArraySizeException|NoSuchFieldError|Override|Process|" + "ProcessBuilder|SecurityManager|StringIndexOutOfBoundsException|" + "SuppressWarnings|TypeNotPresentException|UnknownError|" + "UnsatisfiedLinkError|UnsupportedClassVersionError|VerifyError|" + "InstantiationException|IndexOutOfBoundsException|" + "ArrayIndexOutOfBoundsException|CloneNotSupportedException|" + "NoSuchFieldException|IllegalArgumentException|NumberFormatException|" + "SecurityException|Void|InheritableThreadLocal|IllegalStateException|" + "InterruptedException|NoSuchMethodException|IllegalAccessException|" + "UnsupportedOperationException|Enum|StrictMath|Package|Compiler|" + "Readable|Runtime|StringBuilder|Math|IncompatibleClassChangeError|" + "NoSuchMethodError|ThreadLocal|RuntimePermission|ArithmeticException|" + "NullPointerException|Long|Integer|Short|Byte|Double|Number|Float|" + "Character|Boolean|StackTraceElement|Appendable|StringBuffer|" + "Iterable|ThreadGroup|Runnable|Thread|IllegalMonitorStateException|" + "StackOverflowError|OutOfMemoryError|VirtualMachineError|" + "ArrayStoreException|ClassCastException|LinkageError|" + "NoClassDefFoundError|ClassNotFoundException|RuntimeException|" + "Exception|ThreadDeath|Error|Throwable|System|ClassLoader|" + "Cloneable|Class|CharSequence|Comparable|String|Object";

                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "this",
                    "keyword": keywords,
                    "constant.language": buildinConstants,
                    "support.function": langClasses
                }, "identifier");

                this.$rules = {
                    "start": [{
                        token: "comment",
                        regex: "\\/\\/.*$"
                    }, DocCommentHighlightRules.getStartRule("doc-start"), {
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        next: "comment"
                    }, {
                        token: "string", // single line
                        regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                    }, {
                        token: "string", // single line
                        regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F][0-9a-fA-F_]*|[bB][01][01_]*)[LlSsDdFfYy]?\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.[\d_]*)?(?:[eE][+-]?[\d_]+)?)?[LlSsDdFfYy]?\b/
                    }, {
                        token: "constant.language.boolean",
                        regex: "(?:true|false)\\b"
                    }, {
                        token: keywordMapper,
                        regex: "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
                    }, {
                        token: "keyword.operator",
                        regex: "!|\\$|%|&|\\*|\\-\\-|\\-|\\+\\+|\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\|\\||\\?\\:|\\*=|%=|\\+=|\\-=|&=|\\^=|\\b(?:in|instanceof|new|delete|typeof|void)"
                    }, {
                        token: "lparen",
                        regex: "[[({]"
                    }, {
                        token: "rparen",
                        regex: "[\\])}]"
                    }, {
                        token: "text",
                        regex: "\\s+"
                    }],
                    "comment": [{
                        token: "comment", // closing comment
                        regex: ".*?\\*\\/",
                        next: "start"
                    }, {
                        token: "comment", // comment spanning whole line
                        regex: ".+"
                    }]
                };

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("start")]);
            };

            oop.inherits(JavaHighlightRules, TextHighlightRules);

            exports.JavaHighlightRules = JavaHighlightRules;
        });

        ace.define("ace/mode/java", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript", "ace/mode/java_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var JavaScriptMode = require("./javascript").Mode;
            var JavaHighlightRules = require("./java_highlight_rules").JavaHighlightRules;

            var Mode = function () {
                JavaScriptMode.call(this);
                this.HighlightRules = JavaHighlightRules;
            };
            oop.inherits(Mode, JavaScriptMode);

            (function () {

                this.createWorker = function (session) {
                    return null;
                };

                this.$id = "ace/mode/java";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5d", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5e", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/python_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var PythonHighlightRules = function () {

                var keywords = "and|as|assert|break|class|continue|def|del|elif|else|except|exec|" + "finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|" + "raise|return|try|while|with|yield";

                var builtinConstants = "True|False|None|NotImplemented|Ellipsis|__debug__";

                var builtinFunctions = "abs|divmod|input|open|staticmethod|all|enumerate|int|ord|str|any|" + "eval|isinstance|pow|sum|basestring|execfile|issubclass|print|super|" + "binfile|iter|property|tuple|bool|filter|len|range|type|bytearray|" + "float|list|raw_input|unichr|callable|format|locals|reduce|unicode|" + "chr|frozenset|long|reload|vars|classmethod|getattr|map|repr|xrange|" + "cmp|globals|max|reversed|zip|compile|hasattr|memoryview|round|" + "__import__|complex|hash|min|set|apply|delattr|help|next|setattr|" + "buffer|dict|hex|object|slice|coerce|dir|id|oct|sorted|intern";
                var keywordMapper = this.createKeywordMapper({
                    "invalid.deprecated": "debugger",
                    "support.function": builtinFunctions,
                    "constant.language": builtinConstants,
                    "keyword": keywords
                }, "identifier");

                var strPre = "(?:r|u|ur|R|U|UR|Ur|uR)?";

                var decimalInteger = "(?:(?:[1-9]\\d*)|(?:0))";
                var octInteger = "(?:0[oO]?[0-7]+)";
                var hexInteger = "(?:0[xX][\\dA-Fa-f]+)";
                var binInteger = "(?:0[bB][01]+)";
                var integer = "(?:" + decimalInteger + "|" + octInteger + "|" + hexInteger + "|" + binInteger + ")";

                var exponent = "(?:[eE][+-]?\\d+)";
                var fraction = "(?:\\.\\d+)";
                var intPart = "(?:\\d+)";
                var pointFloat = "(?:(?:" + intPart + "?" + fraction + ")|(?:" + intPart + "\\.))";
                var exponentFloat = "(?:(?:" + pointFloat + "|" + intPart + ")" + exponent + ")";
                var floatNumber = "(?:" + exponentFloat + "|" + pointFloat + ")";

                var stringEscape = "\\\\(x[0-9A-Fa-f]{2}|[0-7]{3}|[\\\\abfnrtv'\"]|U[0-9A-Fa-f]{8}|u[0-9A-Fa-f]{4})";

                this.$rules = {
                    "start": [{
                        token: "comment",
                        regex: "#.*$"
                    }, {
                        token: "string", // multi line """ string start
                        regex: strPre + '"{3}',
                        next: "qqstring3"
                    }, {
                        token: "string", // " string
                        regex: strPre + '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "string", // multi line ''' string start
                        regex: strPre + "'{3}",
                        next: "qstring3"
                    }, {
                        token: "string", // ' string
                        regex: strPre + "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "constant.numeric", // imaginary
                        regex: "(?:" + floatNumber + "|\\d+)[jJ]\\b"
                    }, {
                        token: "constant.numeric", // float
                        regex: floatNumber
                    }, {
                        token: "constant.numeric", // long integer
                        regex: integer + "[lL]\\b"
                    }, {
                        token: "constant.numeric", // integer
                        regex: integer + "\\b"
                    }, {
                        token: keywordMapper,
                        regex: "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
                    }, {
                        token: "keyword.operator",
                        regex: "\\+|\\-|\\*|\\*\\*|\\/|\\/\\/|%|<<|>>|&|\\||\\^|~|<|>|<=|=>|==|!=|<>|="
                    }, {
                        token: "paren.lparen",
                        regex: "[\\[\\(\\{]"
                    }, {
                        token: "paren.rparen",
                        regex: "[\\]\\)\\}]"
                    }, {
                        token: "text",
                        regex: "\\s+"
                    }],
                    "qqstring3": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string", // multi line """ string end
                        regex: '"{3}',
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring3": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string", // multi line ''' string end
                        regex: "'{3}",
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }]
                };
            };

            oop.inherits(PythonHighlightRules, TextHighlightRules);

            exports.PythonHighlightRules = PythonHighlightRules;
        });

        ace.define("ace/mode/folding/pythonic", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (markers) {
                this.foldingStartMarker = new RegExp("([\\[{])(?:\\s*)$|(" + markers + ")(?:\\s*)(?:#.*)?$");
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var line = session.getLine(row);
                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        if (match[1]) return this.openingBracketBlock(session, match[1], row, match.index);
                        if (match[2]) return this.indentationBlock(session, row, match.index + match[2].length);
                        return this.indentationBlock(session, row);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/python", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/python_highlight_rules", "ace/mode/folding/pythonic", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var PythonHighlightRules = require("./python_highlight_rules").PythonHighlightRules;
            var PythonFoldMode = require("./folding/pythonic").FoldMode;
            var Range = require("../range").Range;

            var Mode = function () {
                this.HighlightRules = PythonHighlightRules;
                this.foldingRules = new PythonFoldMode("\\:");
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "#";

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start") {
                        var match = line.match(/^.*[\{\(\[:]\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    }

                    return indent;
                };

                var outdents = {
                    "pass": 1,
                    "return": 1,
                    "raise": 1,
                    "break": 1,
                    "continue": 1
                };

                this.checkOutdent = function (state, line, input) {
                    if (input !== "\r\n" && input !== "\r" && input !== "\n") return false;

                    var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;

                    if (!tokens) return false;
                    do {
                        var last = tokens.pop();
                    } while (last && (last.type == "comment" || last.type == "text" && last.value.match(/^\s+$/)));

                    if (!last) return false;

                    return last.type == "keyword" && outdents[last.value];
                };

                this.autoOutdent = function (state, doc, row) {

                    row += 1;
                    var indent = this.$getIndent(doc.getLine(row));
                    var tab = doc.getTabString();
                    if (indent.slice(-tab.length) == tab) doc.remove(new Range(row, indent.length - tab.length, row, indent.length));
                };

                this.$id = "ace/mode/python";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5f", ["5b"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    ace.define("ace/theme/twilight", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {

      exports.isDark = true;
      exports.cssClass = "ace-twilight";
      exports.cssText = ".ace-twilight .ace_gutter {\
background: #232323;\
color: #E2E2E2\
}\
.ace-twilight .ace_print-margin {\
width: 1px;\
background: #232323\
}\
.ace-twilight {\
background-color: #141414;\
color: #F8F8F8\
}\
.ace-twilight .ace_cursor {\
color: #A7A7A7\
}\
.ace-twilight .ace_marker-layer .ace_selection {\
background: rgba(221, 240, 255, 0.20)\
}\
.ace-twilight.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #141414;\
}\
.ace-twilight .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-twilight .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgba(255, 255, 255, 0.25)\
}\
.ace-twilight .ace_marker-layer .ace_active-line {\
background: rgba(255, 255, 255, 0.031)\
}\
.ace-twilight .ace_gutter-active-line {\
background-color: rgba(255, 255, 255, 0.031)\
}\
.ace-twilight .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(221, 240, 255, 0.20)\
}\
.ace-twilight .ace_invisible {\
color: rgba(255, 255, 255, 0.25)\
}\
.ace-twilight .ace_keyword,\
.ace-twilight .ace_meta {\
color: #CDA869\
}\
.ace-twilight .ace_constant,\
.ace-twilight .ace_constant.ace_character,\
.ace-twilight .ace_constant.ace_character.ace_escape,\
.ace-twilight .ace_constant.ace_other,\
.ace-twilight .ace_heading,\
.ace-twilight .ace_markup.ace_heading,\
.ace-twilight .ace_support.ace_constant {\
color: #CF6A4C\
}\
.ace-twilight .ace_invalid.ace_illegal {\
color: #F8F8F8;\
background-color: rgba(86, 45, 86, 0.75)\
}\
.ace-twilight .ace_invalid.ace_deprecated {\
text-decoration: underline;\
font-style: italic;\
color: #D2A8A1\
}\
.ace-twilight .ace_support {\
color: #9B859D\
}\
.ace-twilight .ace_fold {\
background-color: #AC885B;\
border-color: #F8F8F8\
}\
.ace-twilight .ace_support.ace_function {\
color: #DAD085\
}\
.ace-twilight .ace_list,\
.ace-twilight .ace_markup.ace_list,\
.ace-twilight .ace_storage {\
color: #F9EE98\
}\
.ace-twilight .ace_entity.ace_name.ace_function,\
.ace-twilight .ace_meta.ace_tag,\
.ace-twilight .ace_variable {\
color: #AC885B\
}\
.ace-twilight .ace_string {\
color: #8F9D6A\
}\
.ace-twilight .ace_string.ace_regexp {\
color: #E9C062\
}\
.ace-twilight .ace_comment {\
font-style: italic;\
color: #5F5A60\
}\
.ace-twilight .ace_variable {\
color: #7587A6\
}\
.ace-twilight .ace_xml-pe {\
color: #494949\
}\
.ace-twilight .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y\
}";

      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("60", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("61", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("62", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.MD5", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Constants table
            var T = [];

            // Compute constants
            (function () {
                for (var i = 0; i < 64; i++) {
                    T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
                }
            })();

            /**
             * MD5 hash algorithm.
             */
            var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
                },

                _doProcessBlock: function (M, offset) {
                    // Swap endian
                    for (var i = 0; i < 16; i++) {
                        // Shortcuts
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];

                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
                    }

                    // Shortcuts
                    var H = this._hash.words;

                    var M_offset_0 = M[offset + 0];
                    var M_offset_1 = M[offset + 1];
                    var M_offset_2 = M[offset + 2];
                    var M_offset_3 = M[offset + 3];
                    var M_offset_4 = M[offset + 4];
                    var M_offset_5 = M[offset + 5];
                    var M_offset_6 = M[offset + 6];
                    var M_offset_7 = M[offset + 7];
                    var M_offset_8 = M[offset + 8];
                    var M_offset_9 = M[offset + 9];
                    var M_offset_10 = M[offset + 10];
                    var M_offset_11 = M[offset + 11];
                    var M_offset_12 = M[offset + 12];
                    var M_offset_13 = M[offset + 13];
                    var M_offset_14 = M[offset + 14];
                    var M_offset_15 = M[offset + 15];

                    // Working varialbes
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];

                    // Computation
                    a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                    d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                    c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                    b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                    a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                    d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                    c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                    b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                    a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                    d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                    a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);

                    a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                    d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                    b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                    a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                    d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                    b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                    a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                    d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                    c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                    b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                    a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                    d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                    c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);

                    a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                    d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                    a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                    d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                    c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                    a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                    d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                    c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                    b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                    a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                    b = HH(b, c, d, a, M_offset_2, 23, T[47]);

                    a = II(a, b, c, d, M_offset_0, 6, T[48]);
                    d = II(d, a, b, c, M_offset_7, 10, T[49]);
                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                    b = II(b, c, d, a, M_offset_5, 21, T[51]);
                    a = II(a, b, c, d, M_offset_12, 6, T[52]);
                    d = II(d, a, b, c, M_offset_3, 10, T[53]);
                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                    b = II(b, c, d, a, M_offset_1, 21, T[55]);
                    a = II(a, b, c, d, M_offset_8, 6, T[56]);
                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                    c = II(c, d, a, b, M_offset_6, 15, T[58]);
                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                    a = II(a, b, c, d, M_offset_4, 6, T[60]);
                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                    c = II(c, d, a, b, M_offset_2, 15, T[62]);
                    b = II(b, c, d, a, M_offset_9, 21, T[63]);

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;

                    var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                    var nBitsTotalL = nBitsTotal;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;

                    data.sigBytes = (dataWords.length + 1) * 4;

                    // Hash final blocks
                    this._process();

                    // Shortcuts
                    var hash = this._hash;
                    var H = hash.words;

                    // Swap endian
                    for (var i = 0; i < 4; i++) {
                        // Shortcut
                        var H_i = H[i];

                        H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
                    }

                    // Return final computed hash
                    return hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            function FF(a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function GG(a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.MD5('message');
             *     var hash = CryptoJS.MD5(wordArray);
             */
            C.MD5 = Hasher._createHelper(MD5);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacMD5(message, key);
             */
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("64", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.SHA1", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Reusable object
            var W = [];

            /**
             * SHA-1 hash algorithm.
             */
            var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
                },

                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;

                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];

                    // Computation
                    for (var i = 0; i < 80; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = n << 1 | n >>> 31;
                        }

                        var t = (a << 5 | a >>> 27) + e + W[i];
                        if (i < 20) {
                            t += (b & c | ~b & d) + 0x5a827999;
                        } else if (i < 40) {
                            t += (b ^ c ^ d) + 0x6ed9eba1;
                        } else if (i < 60) {
                            t += (b & c | b & d | c & d) - 0x70e44324;
                        } else /* if (i < 80) */{
                                t += (b ^ c ^ d) - 0x359d3e2a;
                            }

                        e = d;
                        d = c;
                        c = b << 30 | b >>> 2;
                        b = a;
                        a = t;
                    }

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;

                    // Hash final blocks
                    this._process();

                    // Return final computed hash
                    return this._hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA1('message');
             *     var hash = CryptoJS.SHA1(wordArray);
             */
            C.SHA1 = Hasher._createHelper(SHA1);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA1(message, key);
             */
            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('65', ['63'], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'CryptoJS.algo.HMAC', null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C.algo;

            /**
             * HMAC algorithm.
             */
            var HMAC = C_algo.HMAC = Base.extend({
                /**
                 * Initializes a newly created HMAC.
                 *
                 * @param {Hasher} hasher The hash algorithm to use.
                 * @param {WordArray|string} key The secret key.
                 *
                 * @example
                 *
                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                 */
                init: function (hasher, key) {
                    // Init hasher
                    hasher = this._hasher = new hasher.init();

                    // Convert string to WordArray, else assume WordArray already
                    if (typeof key == 'string') {
                        key = Utf8.parse(key);
                    }

                    // Shortcuts
                    var hasherBlockSize = hasher.blockSize;
                    var hasherBlockSizeBytes = hasherBlockSize * 4;

                    // Allow arbitrary length keys
                    if (key.sigBytes > hasherBlockSizeBytes) {
                        key = hasher.finalize(key);
                    }

                    // Clamp excess bits
                    key.clamp();

                    // Clone key for inner and outer pads
                    var oKey = this._oKey = key.clone();
                    var iKey = this._iKey = key.clone();

                    // Shortcuts
                    var oKeyWords = oKey.words;
                    var iKeyWords = iKey.words;

                    // XOR keys with pad constants
                    for (var i = 0; i < hasherBlockSize; i++) {
                        oKeyWords[i] ^= 0x5c5c5c5c;
                        iKeyWords[i] ^= 0x36363636;
                    }
                    oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

                    // Set initial values
                    this.reset();
                },

                /**
                 * Resets this HMAC to its initial state.
                 *
                 * @example
                 *
                 *     hmacHasher.reset();
                 */
                reset: function () {
                    // Shortcut
                    var hasher = this._hasher;

                    // Reset
                    hasher.reset();
                    hasher.update(this._iKey);
                },

                /**
                 * Updates this HMAC with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {HMAC} This HMAC instance.
                 *
                 * @example
                 *
                 *     hmacHasher.update('message');
                 *     hmacHasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    this._hasher.update(messageUpdate);

                    // Chainable
                    return this;
                },

                /**
                 * Finalizes the HMAC computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The HMAC.
                 *
                 * @example
                 *
                 *     var hmac = hmacHasher.finalize();
                 *     var hmac = hmacHasher.finalize('message');
                 *     var hmac = hmacHasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Shortcut
                    var hasher = this._hasher;

                    // Compute HMAC
                    var innerHash = hasher.finalize(messageUpdate);
                    hasher.reset();
                    var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

                    return hmac;
                }
            });
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("66", ["64", "65"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.PBKDF2", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA1 = C_algo.SHA1;
            var HMAC = C_algo.HMAC;

            /**
             * Password-Based Key Derivation Function 2 algorithm.
             */
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hasher to use. Default: SHA1
                 * @property {number} iterations The number of iterations to perform. Default: 1
                 */
                cfg: Base.extend({
                    keySize: 128 / 32,
                    hasher: SHA1,
                    iterations: 1
                }),

                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.PBKDF2.create();
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                 */
                init: function (cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },

                /**
                 * Computes the Password-Based Key Derivation Function 2.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function (password, salt) {
                    // Shortcut
                    var cfg = this.cfg;

                    // Init HMAC
                    var hmac = HMAC.create(cfg.hasher, password);

                    // Initial values
                    var derivedKey = WordArray.create();
                    var blockIndex = WordArray.create([0x00000001]);

                    // Shortcuts
                    var derivedKeyWords = derivedKey.words;
                    var blockIndexWords = blockIndex.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;

                    // Generate key
                    while (derivedKeyWords.length < keySize) {
                        var block = hmac.update(salt).finalize(blockIndex);
                        hmac.reset();

                        // Shortcuts
                        var blockWords = block.words;
                        var blockWordsLength = blockWords.length;

                        // Iterations
                        var intermediate = block;
                        for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();

                            // Shortcut
                            var intermediateWords = intermediate.words;

                            // XOR intermediate with block
                            for (var j = 0; j < blockWordsLength; j++) {
                                blockWords[j] ^= intermediateWords[j];
                            }
                        }

                        derivedKey.concat(block);
                        blockIndexWords[0]++;
                    }
                    derivedKey.sigBytes = keySize * 4;

                    return derivedKey;
                }
            });

            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.PBKDF2(password, salt);
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.PBKDF2 = function (password, salt, cfg) {
                return PBKDF2.create(cfg).compute(password, salt);
            };
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('63', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'CryptoJS', null);

    (function ($__global) {
        var CryptoJS = $__global['CryptoJS'];
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        /**
         * CryptoJS core components.
         */
        var CryptoJS = CryptoJS || function (Math, undefined) {
            /**
             * CryptoJS namespace.
             */
            var C = {};

            /**
             * Library namespace.
             */
            var C_lib = C.lib = {};

            /**
             * Base object for prototypal inheritance.
             */
            var Base = C_lib.Base = function () {
                function F() {}

                return {
                    /**
                     * Creates a new object that inherits from this object.
                     *
                     * @param {Object} overrides Properties to copy into the new object.
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         field: 'value',
                     *
                     *         method: function () {
                     *         }
                     *     });
                     */
                    extend: function (overrides) {
                        // Spawn
                        F.prototype = this;
                        var subtype = new F();

                        // Augment
                        if (overrides) {
                            subtype.mixIn(overrides);
                        }

                        // Create default initializer
                        if (!subtype.hasOwnProperty('init')) {
                            subtype.init = function () {
                                subtype.$super.init.apply(this, arguments);
                            };
                        }

                        // Initializer's prototype is the subtype object
                        subtype.init.prototype = subtype;

                        // Reference supertype
                        subtype.$super = this;

                        return subtype;
                    },

                    /**
                     * Extends this object and runs the init method.
                     * Arguments to create() will be passed to init().
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var instance = MyType.create();
                     */
                    create: function () {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);

                        return instance;
                    },

                    /**
                     * Initializes a newly created object.
                     * Override this method to add some logic when your objects are created.
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         init: function () {
                     *             // ...
                     *         }
                     *     });
                     */
                    init: function () {},

                    /**
                     * Copies properties into this object.
                     *
                     * @param {Object} properties The properties to mix in.
                     *
                     * @example
                     *
                     *     MyType.mixIn({
                     *         field: 'value'
                     *     });
                     */
                    mixIn: function (properties) {
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                                this[propertyName] = properties[propertyName];
                            }
                        }

                        // IE won't copy toString using the loop above
                        if (properties.hasOwnProperty('toString')) {
                            this.toString = properties.toString;
                        }
                    },

                    /**
                     * Creates a copy of this object.
                     *
                     * @return {Object} The clone.
                     *
                     * @example
                     *
                     *     var clone = instance.clone();
                     */
                    clone: function () {
                        return this.init.prototype.extend(this);
                    }
                };
            }();

            /**
             * An array of 32-bit words.
             *
             * @property {Array} words The array of 32-bit words.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function (words, sigBytes) {
                    words = this.words = words || [];

                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 4;
                    }
                },

                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function (encoder) {
                    return (encoder || Hex).stringify(this);
                },

                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function (wordArray) {
                    // Shortcuts
                    var thisWords = this.words;
                    var thatWords = wordArray.words;
                    var thisSigBytes = this.sigBytes;
                    var thatSigBytes = wordArray.sigBytes;

                    // Clamp excess bits
                    this.clamp();

                    // Concat
                    if (thisSigBytes % 4) {
                        // Copy one byte at a time
                        for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                        }
                    } else if (thatWords.length > 0xffff) {
                        // Copy one word at a time
                        for (var i = 0; i < thatSigBytes; i += 4) {
                            thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                        }
                    } else {
                        // Copy all words at once
                        thisWords.push.apply(thisWords, thatWords);
                    }
                    this.sigBytes += thatSigBytes;

                    // Chainable
                    return this;
                },

                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function () {
                    // Shortcuts
                    var words = this.words;
                    var sigBytes = this.sigBytes;

                    // Clamp
                    words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
                    words.length = Math.ceil(sigBytes / 4);
                },

                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone.words = this.words.slice(0);

                    return clone;
                },

                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function (nBytes) {
                    var words = [];
                    for (var i = 0; i < nBytes; i += 4) {
                        words.push(Math.random() * 0x100000000 | 0);
                    }

                    return new WordArray.init(words, nBytes);
                }
            });

            /**
             * Encoder namespace.
             */
            var C_enc = C.enc = {};

            /**
             * Hex encoding strategy.
             */
            var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;

                    // Convert
                    var hexChars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 0x0f).toString(16));
                    }

                    return hexChars.join('');
                },

                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function (hexStr) {
                    // Shortcut
                    var hexStrLength = hexStr.length;

                    // Convert
                    var words = [];
                    for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                    }

                    return new WordArray.init(words, hexStrLength / 2);
                }
            };

            /**
             * Latin1 encoding strategy.
             */
            var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;

                    // Convert
                    var latin1Chars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                        latin1Chars.push(String.fromCharCode(bite));
                    }

                    return latin1Chars.join('');
                },

                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function (latin1Str) {
                    // Shortcut
                    var latin1StrLength = latin1Str.length;

                    // Convert
                    var words = [];
                    for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
                    }

                    return new WordArray.init(words, latin1StrLength);
                }
            };

            /**
             * UTF-8 encoding strategy.
             */
            var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                    } catch (e) {
                        throw new Error('Malformed UTF-8 data');
                    }
                },

                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function (utf8Str) {
                    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
            };

            /**
             * Abstract buffered block algorithm template.
             *
             * The property blockSize must be implemented in a concrete subtype.
             *
             * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
             */
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function () {
                    // Initial values
                    this._data = new WordArray.init();
                    this._nDataBytes = 0;
                },

                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function (data) {
                    // Convert string to WordArray, else assume WordArray already
                    if (typeof data == 'string') {
                        data = Utf8.parse(data);
                    }

                    // Append
                    this._data.concat(data);
                    this._nDataBytes += data.sigBytes;
                },

                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function (doFlush) {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
                    var dataSigBytes = data.sigBytes;
                    var blockSize = this.blockSize;
                    var blockSizeBytes = blockSize * 4;

                    // Count blocks ready
                    var nBlocksReady = dataSigBytes / blockSizeBytes;
                    if (doFlush) {
                        // Round up to include partial blocks
                        nBlocksReady = Math.ceil(nBlocksReady);
                    } else {
                        // Round down to include only full blocks,
                        // less the number of blocks that must remain in the buffer
                        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                    }

                    // Count words ready
                    var nWordsReady = nBlocksReady * blockSize;

                    // Count bytes ready
                    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                    // Process blocks
                    if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            // Perform concrete-algorithm logic
                            this._doProcessBlock(dataWords, offset);
                        }

                        // Remove processed words
                        var processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                    }

                    // Return processed words
                    return new WordArray.init(processedWords, nBytesReady);
                },

                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone._data = this._data.clone();

                    return clone;
                },

                _minBufferSize: 0
            });

            /**
             * Abstract hasher template.
             *
             * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
             */
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),

                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function (cfg) {
                    // Apply config defaults
                    this.cfg = this.cfg.extend(cfg);

                    // Set initial values
                    this.reset();
                },

                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function () {
                    // Reset data buffer
                    BufferedBlockAlgorithm.reset.call(this);

                    // Perform concrete-hasher logic
                    this._doReset();
                },

                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    // Append
                    this._append(messageUpdate);

                    // Update the hash
                    this._process();

                    // Chainable
                    return this;
                },

                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Final message update
                    if (messageUpdate) {
                        this._append(messageUpdate);
                    }

                    // Perform concrete-hasher logic
                    var hash = this._doFinalize();

                    return hash;
                },

                blockSize: 512 / 32,

                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function (hasher) {
                    return function (message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                    };
                },

                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function (hasher) {
                    return function (message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                    };
                }
            });

            /**
             * Algorithm namespace.
             */
            var C_algo = C.algo = {};

            return C;
        }(Math);
        $__global['CryptoJS'] = CryptoJS;
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("67", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.SHA256", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Initialization and round constants tables
            var H = [];
            var K = [];

            // Compute constants
            (function () {
                function isPrime(n) {
                    var sqrtN = Math.sqrt(n);
                    for (var factor = 2; factor <= sqrtN; factor++) {
                        if (!(n % factor)) {
                            return false;
                        }
                    }

                    return true;
                }

                function getFractionalBits(n) {
                    return (n - (n | 0)) * 0x100000000 | 0;
                }

                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                    if (isPrime(n)) {
                        if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                        }
                        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                        nPrime++;
                    }

                    n++;
                }
            })();

            // Reusable object
            var W = [];

            /**
             * SHA-256 hash algorithm.
             */
            var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init(H.slice(0));
                },

                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;

                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
                    var f = H[5];
                    var g = H[6];
                    var h = H[7];

                    // Computation
                    for (var i = 0; i < 64; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var gamma0x = W[i - 15];
                            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;

                            var gamma1x = W[i - 2];
                            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;

                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                        }

                        var ch = e & f ^ ~e & g;
                        var maj = a & b ^ a & c ^ b & c;

                        var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                        var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);

                        var t1 = h + sigma1 + ch + K[i] + W[i];
                        var t2 = sigma0 + maj;

                        h = g;
                        g = f;
                        f = e;
                        e = d + t1 | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = t1 + t2 | 0;
                    }

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                    H[5] = H[5] + f | 0;
                    H[6] = H[6] + g | 0;
                    H[7] = H[7] + h | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;

                    // Hash final blocks
                    this._process();

                    // Return final computed hash
                    return this._hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA256('message');
             *     var hash = CryptoJS.SHA256(wordArray);
             */
            C.SHA256 = Hasher._createHelper(SHA256);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA256(message, key);
             */
            C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('68', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
      rsComboSymbolsRange = '\\u20d0-\\u20f0',
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')', rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr, rsUpper + '+' + rsOptUpperContr, rsDigits, rsEmoji].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C', '\xe7': 'c',
    '\xd0': 'D', '\xf0': 'd',
    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N', '\xf1': 'n',
    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J', '\u0135': 'j',
    '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't', '\u0165': 't', '\u0167': 't',
    '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W', '\u0175': 'w',
    '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 'ss'
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Built-in value references. */
  var Symbol = root.Symbol;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function (string) {
      string = toString(string);

      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

      var chr = strSymbols ? strSymbols[0] : string.charAt(0);

      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  module.exports = camelCase;
  return module.exports;
});
$__System.registerDynamic("69", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6a", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6b", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "d3", null);

  (function ($__global) {
    !function () {
      var d3 = {
        version: "3.5.17"
      };
      var d3_arraySlice = [].slice,
          d3_array = function (list) {
        return d3_arraySlice.call(list);
      };
      var d3_document = this.document;
      function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
      }
      function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
      }
      if (d3_document) {
        try {
          d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
          d3_array = function (list) {
            var i = list.length,
                array = new Array(i);
            while (i--) array[i] = list[i];
            return array;
          };
        }
      }
      if (!Date.now) Date.now = function () {
        return +new Date();
      };
      if (d3_document) {
        try {
          d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
          var d3_element_prototype = this.Element.prototype,
              d3_element_setAttribute = d3_element_prototype.setAttribute,
              d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
              d3_style_prototype = this.CSSStyleDeclaration.prototype,
              d3_style_setProperty = d3_style_prototype.setProperty;
          d3_element_prototype.setAttribute = function (name, value) {
            d3_element_setAttribute.call(this, name, value + "");
          };
          d3_element_prototype.setAttributeNS = function (space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
          };
          d3_style_prototype.setProperty = function (name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
          };
        }
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
      };
      d3.max = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
      };
      d3.extent = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = +array[i])) s += a;
        } else {
          while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
      };
      d3.mean = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;else --j;
        } else {
          while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;else --j;
        }
        if (j) return s / j;
      };
      d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function (array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
          while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      d3.variance = function (array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (arguments.length === 1) {
          while (++i < n) {
            if (d3_numeric(a = d3_number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1) return s / (j - 1);
      };
      d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
      };
      function d3_bisector(compare) {
        return {
          left: function (a, x, lo, hi) {
            if (arguments.length < 3) lo = 0;
            if (arguments.length < 4) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
            }
            return lo;
          },
          right: function (a, x, lo, hi) {
            if (arguments.length < 3) lo = 0;
            if (arguments.length < 4) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2) i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function (array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function (array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.transpose = function (matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;) {
          for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
            row[j] = matrix[j][i];
          }
        }
        return transpose;
      };
      function d3_transposeLength(d) {
        return d.length;
      }
      d3.zip = function () {
        return d3.transpose(arguments);
      };
      d3.keys = function (map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
      };
      d3.values = function (map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
      };
      d3.entries = function (map) {
        var entries = [];
        for (var key in map) entries.push({
          key: key,
          value: map[key]
        });
        return entries;
      };
      d3.merge = function (arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function (key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object) map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
          return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
          var values = [];
          for (var key in this._) values.push(this._[key]);
          return values;
        },
        entries: function () {
          var entries = [];
          for (var key in this._) entries.push({
            key: d3_map_unescape(key),
            value: this._[key]
          });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
          for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._) keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._) ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._) return false;
        return true;
      }
      d3.nest = function () {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function (keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function (keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length) return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function (key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function (array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function (array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function (order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function (order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function (f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function (array) {
        var set = new d3_Set();
        if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
          for (var key in this._) f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      function d3_identity(d) {
        return d;
      }
      d3.rebind = function (target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function () {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object) return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function () {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null) for (type in this) {
            if (this.hasOwnProperty(type)) this[type].on(name, null);
          }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n) if (l = z[i].on) l.apply(this, arguments);
          return dispatch;
        }
        event.on = function (name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2) return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener) listeners.push(listenerByName.set(name, {
            on: listener
          }));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent) e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
          return function (e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function (s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
      } : function (object, prototype) {
        for (var property in prototype) object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function (s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function (s, n) {
        return n.querySelectorAll(s);
      },
          d3_selectMatches = function (n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function (n, s) {
          return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
      };
      if (typeof Sizzle === "function") {
        d3_select = function (s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function () {
        return d3.select(d3_document.documentElement);
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function (selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function () {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function () {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name) this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null) this.removeAttribute(name);else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null) this.removeAttributeNS(name.space, name.local);else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n) if (!value.contains(name[i])) return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
            }
            return true;
          }
          for (value in name) this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n) name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
          if (c = node.classList) return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2) value = "";
            for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2) {
            var node = this.node();
            return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
          }
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null) this.style.removeProperty(name);else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") return this.node()[name];
          for (value in name) this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null) delete this[name];else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function () {
          this.textContent = "";
        } : function () {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function () {
          this.innerHTML = "";
        } : function () {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        function create() {
          var document = this.ownerDocument,
              namespace = this.namespaceURI;
          return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
      }
      d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
      }
      d3_selectionPrototype.data = function (value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n;) {
              if (node = group[i]) {
                if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                  exitNodes[i] = node;
                } else {
                  nodeByKeyValue.set(keyValue, node);
                }
                keyValues[i] = keyValue;
              }
            }
            for (i = -1; ++i < m;) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n;) {
              if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0;) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function () {
          return enter;
        };
        update.exit = function () {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {
          __data__: data
        };
      }
      d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function (filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0, n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function () {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function (a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
          for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
            if (node = group[i]) callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function () {
        return !this.node();
      };
      d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            var node = group[i];
            if (node) return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1, m = this.length; ++j < m;) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0) j0 = j, i0 = 0;
          if (i >= i0) i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n);
          return node;
        };
      }
      d3.select = function (node) {
        var group;
        if (typeof node === "string") {
          group = [d3_select(node, d3_document)];
          group.parentNode = d3_document.documentElement;
        } else {
          group = [node];
          group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
      };
      d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === "string") {
          group = d3_array(d3_selectAll(nodes, d3_document));
          group.parentNode = d3_document.documentElement;
        } else {
          group = d3_array(nodes);
          group.parentNode = null;
        }
        return d3_selection([group]);
      };
      d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2) listener = false;
            for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2) return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
          if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
        });
      }
      function d3_selection_onListener(listener, argumentz) {
        return function (e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect,
          d3_event_dragId = 0;
      function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
          d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
          var style = d3_documentElement(node).style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function (suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function () {
              w.on(click, null);
            };
            w.on(click, function () {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0) {
            var window = d3_window(container);
            if (window.scrollX || window.scrollY) {
              svg = d3.select("body").append("svg").style({
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                border: "none"
              }, "important");
              var ctm = svg[0][0].getScreenCTM();
              d3_mouse_bug44083 = !(ctm.f || ctm.e);
              svg.remove();
            }
          }
          if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;else point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
          if ((touch = touches[i]).identifier === identifier) {
            return d3_mousePoint(container, touch);
          }
        }
      };
      d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function () {
            var that = this,
                target = d3.event.target.correspondingElement || d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(target),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({
              type: "dragstart"
            });
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1) return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId)) return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged);
              dispatch({
                type: "dragend"
              });
            }
          };
        }
        drag.origin = function (x) {
          if (!arguments.length) return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      d3.touches = function (container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;
        if (d2 < ε2) {
          S = Math.log(w1 / w0) / ρ;
          i = function (t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S)];
          };
        } else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
              b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / ρ;
          i = function (t) {
            var s = t * S,
                coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          };
        }
        i.duration = S * 1e3;
        return i;
      };
      d3.behavior.zoom = function () {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        if (!d3_behavior_zoomWheel) {
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function () {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function () {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function () {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
        }
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
          g.each(function () {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function () {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function () {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function (t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function () {
                zoomended(dispatch);
              }).each("end.zoom", function () {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function (_) {
          if (!arguments.length) return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function (_) {
          if (!arguments.length) return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: null
          };
          scaleTo(+_);
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function (_) {
          if (!arguments.length) return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function (_) {
          if (!arguments.length) return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function (_) {
          if (!arguments.length) return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function (_) {
          if (!arguments.length) return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function (z) {
          if (!arguments.length) return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function (z) {
          if (!arguments.length) return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0) that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1) x1.domain(x0.range().map(function (x) {
            return (x - view.x) / view.k;
          }).map(x0.invert));
          if (y1) y1.domain(y0.range().map(function (y) {
            return (y - view.y) / view.k;
          }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++) dispatch({
            type: "zoomstart"
          });
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (! --zooming) dispatch({
            type: "zoomend"
          }), center0 = null;
        }
        function mousedowned() {
          var that = this,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress(that);
          d3_selection_interrupt.call(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress(that);
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function (t) {
              if (t.identifier in locations0) locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0, n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt.call(that);
            for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0) break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0, n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer) clearTimeout(mousewheelTimer);else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function () {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity],
          d3_behavior_zoomDelta,
          d3_behavior_zoomWheel;
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function () {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360) h -= 360;else if (h < 0) h += 360;
          if (h < 60) return m1 + (m2 - m1) * h / 60;
          if (h < 180) return m2;
          if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function () {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }

            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format)) {
          return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max) h = (g - b) / d + (g < b ? 6 : 0);else if (g == max) h = (b - r) / d + 2;else h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function () {
          return v;
        };
      }
      d3.functor = d3_functor;
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function (url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function (event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function (name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2) return headers[name];
          if (value == null) delete headers[name];else headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function (value) {
          if (!arguments.length) return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function (value) {
          if (!arguments.length) return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function (value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function (method) {
          xhr[method] = function () {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function (method, data, callback) {
          if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
          if (responseType != null) request.responseType = responseType;
          if (callback != null) xhr.on("error", callback).on("load", function (request) {
            callback(null, request);
          });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function () {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3) callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function (_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function (request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function (text, f) {
          var o;
          return dsv.parseRows(text, function (row, i) {
            if (o) return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function (name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function (row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function (text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N) return EOF;
            if (eol) return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34) break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10) ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10) eol = true;else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10) ++I, ++k;
              } else if (c !== delimiterCode) continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null) continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function (rows) {
          if (Array.isArray(rows[0])) return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function (row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
            return fields.map(function (field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function (rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function (callback) {
        setTimeout(callback, 17);
      };
      d3.timer = function () {
        d3_timer.apply(this, arguments);
      };
      function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay,
            timer = {
          c: callback,
          t: time,
          n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer;else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
        return timer;
      }
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now(),
            timer = d3_timer_queueHead;
        while (timer) {
          if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
          timer = timer.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.c) {
            if (t1.t < time) time = t1.t;
            t1 = (t0 = t1).n;
          } else {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value = +value) {
          if (value < 0) value *= -1;
          if (precision) value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function (d) {
            return d / k;
          } : function (d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function (value, width) {
          var i = value.length,
              t = [],
              j = 0,
              g = locale_grouping[0],
              length = 0;
          while (i > 0 && g > 0) {
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = locale_grouping[j = (j + 1) % locale_grouping.length];
          }
          return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function (specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision) precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;

            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;

            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;

            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#") prefix = "0" + type.toLowerCase();

            case "c":
              exponent = false;

            case "d":
              integer = true;
              precision = 0;
              break;

            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision) type = "g";
          if (precision != null) {
            if (type == "g") precision = Math.max(1, Math.min(21, precision));else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function (value) {
            var fullSuffix = suffix;
            if (integer && value % 1) return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0) before = value, after = "";else before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma) before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function (x) {
          return x.toString(2);
        },
        c: function (x) {
          return String.fromCharCode(x);
        },
        o: function (x) {
          return x.toString(8);
        },
        x: function (x) {
          return x.toString(16);
        },
        X: function (x) {
          return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
          return x.toPrecision(p);
        },
        e: function (x, p) {
          return x.toExponential(p);
        },
        f: function (x, p) {
          return x.toFixed(p);
        },
        r: function (x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function () {
          return this._.getUTCDate();
        },
        getDay: function () {
          return this._.getUTCDay();
        },
        getFullYear: function () {
          return this._.getUTCFullYear();
        },
        getHours: function () {
          return this._.getUTCHours();
        },
        getMilliseconds: function () {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
          return this._.getUTCMinutes();
        },
        getMonth: function () {
          return this._.getUTCMonth();
        },
        getSeconds: function () {
          return this._.getUTCSeconds();
        },
        getTime: function () {
          return this._.getTime();
        },
        getTimezoneOffset: function () {
          return 0;
        },
        valueOf: function () {
          return this._.valueOf();
        },
        setDate: function () {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt)) times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1) times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function (date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function (date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function (date, offset) {
        date.setDate(date.getDate() + offset);
      }, function (date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function (date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function (date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function (string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length) return null;
            if ("p" in d) d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d) date.setFullYear(d.y, 0, d.j);else if ("W" in d || "U" in d) {
              if (!("w" in d)) d.w = "W" in d ? 1 : 0;
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function () {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m) return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0) return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function (template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function (string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function (d) {
            return locale_shortDays[d.getDay()];
          },
          A: function (d) {
            return locale_days[d.getDay()];
          },
          b: function (d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function (d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function (d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function (d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function (d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function (d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function (d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function (d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function (d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function (d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function (d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function (d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function (d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function (d) {
            return d.getDay();
          },
          W: function (d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function (d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function (d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function () {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return (/^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1
        );
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n) formats[i][0] = this(formats[i][0]);
        return function (date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date)) f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function (locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s) this.t += d3_adderTemp.t;else this.s = d3_adderTemp.t;
        },
        reset: function () {
          this.s = this.t = 0;
        },
        valueOf: function () {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
          listener.sphere();
        },
        Point: function (object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function () {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function (λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function () {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function () {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function () {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function () {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);else if (dλSum > ε) φ1 = 90;else if (dλSum < -ε) φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1) φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0) φ0 = φi;
            } else {
              if (φ < φ0) φ0 = φ;
              if (φ > φ1) φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0) λ0 = λ;
                if (λ > λ1) λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2) return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function (x, y) {
          return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function (segment) {
          if ((n = segment.length - 1) <= 0) return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v) if ((current = current.n) === start) return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function () {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function () {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n) return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n) listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function () {
            lines.push(line = []);
          },
          point: function (λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function () {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function () {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function () {
            listener.lineStart();
            clean = 1;
          },
          point: function (λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function () {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function () {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m) continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m) j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++) break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0, c0, v0, v00, clean;
          return {
            lineStart: function () {
              v00 = v0 = false;
              clean = 1;
            },
            point: function (λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v)) listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function () {
              if (v0) listener.lineEnd();
              point0 = null;
            },
            clean: function () {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant) return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0) return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two) return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r) code |= 1;else if (λ > r) code |= 2;
          if (φ < -r) code |= 4;else if (φ > r) code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0) return;
          r /= dx;
          if (dx < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dx > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0) return;
          r /= dx;
          if (dx < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dx > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0) return;
          r /= dy;
          if (dy < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dy > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0) return;
          r /= dy;
          if (dy < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dy > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          if (t0 > 0) line.a = {
            x: ax + t0 * dx,
            y: ay + t0 * dy
          };
          if (t1 < 1) line.b = {
            x: ax + t1 * dx,
            y: ay + t1 * dy
          };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function () {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
          stream: function (output) {
            if (stream) stream.valid = false;
            stream = clip(output);
            stream.valid = true;
            return stream;
          },
          extent: function (_) {
            if (!arguments.length) return [[x0, y0], [x1, y1]];
            clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
            if (stream) stream.valid = false, stream = null;
            return clipExtent;
          }
        };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function () {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y)) listener.point(x, y);
          }
          var x__, y__, v__, x_, y_, v_, first, clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon) polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_) bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_) listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon) ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_) listener.point(x, y);else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v) listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function (_) {
          if (!arguments.length) return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {
          point: function (x, y) {
            point = [x, y];
          }
        },
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function (coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function (x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function () {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function () {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function () {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function () {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function () {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function (_) {
          if (!arguments.length) return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function (_) {
          if (!arguments.length) return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
          if (!arguments.length) return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
          d3_geo_pathAreaPolygon = 0;
          d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function () {
          d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
          d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
      };
      function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function () {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function () {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function () {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function (_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function () {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function () {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function () {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function () {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function (_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function (x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function () {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function (_) {
          if (!arguments.length) return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function () {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function (object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function (object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function (_) {
          if (!arguments.length) return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function (_) {
          if (!arguments.length) return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function (_) {
          if (!arguments.length) return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function (stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function (methods) {
        return {
          stream: function (stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods) transform[k] = methods[k];
            return transform;
          }
        };
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function (x, y) {
          this.stream.point(x, y);
        },
        sphere: function () {
          this.stream.sphere();
        },
        lineStart: function () {
          this.stream.lineStart();
        },
        lineEnd: function () {
          this.stream.lineEnd();
        },
        polygonStart: function () {
          this.stream.polygonStart();
        },
        polygonEnd: function () {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function () {
            stream.sphere();
          },
          lineStart: function () {
            stream.lineStart();
          },
          lineEnd: function () {
            stream.lineEnd();
          },
          polygonStart: function () {
            stream.polygonStart();
          },
          polygonEnd: function () {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function (x, y) {
          x = project(x, y);
          return [x[0] * k + δx, δy - x[1] * k];
        }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function (output) {
          if (stream) stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function (_) {
          if (!arguments.length) return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function (_) {
          if (!arguments.length) return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function (_) {
          if (!arguments.length) return k;
          k = +_;
          return reset();
        };
        projection.translate = function (_) {
          if (!arguments.length) return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function (_) {
          if (!arguments.length) return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function (_) {
          if (!arguments.length) return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream) stream.valid = false, stream = null;
          return projection;
        }
        return function () {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function (λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function (λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function () {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {
            point: function (x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }
          });
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function (x) {
          if (!arguments.length) return origin;
          origin = x;
          return circle;
        };
        circle.angle = function (x) {
          if (!arguments.length) return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function (_) {
          if (!arguments.length) return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function (from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to) from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function (a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function () {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function () {
          return lines().map(function (coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function () {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function (_) {
          if (!arguments.length) return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
          if (!arguments.length) return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1) _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
          if (!arguments.length) return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1) _ = x0, x0 = x1, x1 = _;
          if (y0 > y1) _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function (_) {
          if (!arguments.length) return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
          if (!arguments.length) return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function (_) {
          if (!arguments.length) return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function (_) {
          if (!arguments.length) return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function (x) {
          return y.map(function (y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function (y) {
          return x.map(function (x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function () {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function () {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
          if (!arguments.length) return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function (_) {
          if (!arguments.length) return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function () {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function () {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function (λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function (x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function (ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function (φ) {
          return Math.tan(π / 4 + φ / 2);
        },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε) φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε) φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function (x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function () {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function (ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function (x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function (_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function (_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
          if (data.length < 3) return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function (_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function () {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function (subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed) subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
          x: x,
          y: y
        },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε) node = node.L;else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
          x: (cy * hb - by * hc) / d + ax,
          y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare()) continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2) return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;else {
              before = node.P;
              break;
            }
          } else {
            if (node.R) node = node.R;else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1) return;
          if (lx > rx) {
            if (!va) va = {
              x: fx,
              y: y0
            };else if (va.y >= y1) return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va) va = {
              x: fx,
              y: y1
            };else if (va.y < y0) return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va) va = {
                x: (y0 - fb) / fm,
                y: y0
              };else if (va.y >= y1) return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va) va = {
                x: (y1 - fb) / fm,
                y: y1
              };else if (va.y < y0) return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va) va = {
                x: x0,
                y: fm * x0 + fb
              };else if (va.x >= x1) return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va) va = {
                x: x1,
                y: fm * x1 + fb
              };else if (va.x < x0) return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
          var parent, grandpa, uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L) after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function (node) {
          if (node.N) node.N.P = node.P;
          if (node.P) node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left) next = right;else if (!right) next = left;else next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node) parent.L = next;else parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node) node.U = parent;
          if (red) return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._) break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node) node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function (e) {
              var s = e.start();
              return [s.x, s.y];
            }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function (d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function (data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
            return edge.l && edge.r;
          }).map(function (edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function (data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function (_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
          if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function (_) {
          if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat) for (i = 0; i < n; ++i) {
              d = data[i];
              if (d.x < x1_) x1_ = d.x;
              if (d.y < y1_) y1_ = d.y;
              if (d.x > x2_) x2_ = d.x;
              if (d.y > y2_) y2_ = d.y;
              xs.push(d.x);
              ys.push(d.y);
            } else for (i = 0; i < n; ++i) {
              var x_ = +fx(d = data[i], i),
                  y_ = +fy(d, i);
              if (x_ < x1_) x1_ = x_;
              if (y_ < y1_) y1_ = y_;
              if (x_ > x2_) x2_ = x_;
              if (y_ > y2_) y2_ = y_;
              xs.push(x_);
              ys.push(y_);
            }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy) y2_ = y1_ + dx;else x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y)) return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right) x1 = xm;else x2 = xm;
            if (below) y1 = ym;else y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function (d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function (f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function (point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function (_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
          if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function (_) {
          if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
          if (point = node.point) {
            var point,
                dx = x - node.x,
                dy = y - node.y,
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
            if (node = children[i & 3]) switch (i & 3) {
              case 0:
                find(node, x1, y1, xm, ym);
                break;

              case 1:
                find(node, xm, y1, x2, ym);
                break;

              case 2:
                find(node, x1, ym, xm, y2);
                break;

              case 3:
                find(node, xm, ym, x2, y2);
                break;
            }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function (t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function (t) {
          for (k in i) c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs;else s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm;else s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs;else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
          return b(t) + "";
        }) : function () {
          return b;
        } : (b = q.length, function (t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
      }
      d3.interpolators = [function (a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i) c[i] = a[i];
        for (; i < nb; ++i) c[i] = b[i];
        return function (t) {
          for (i = 0; i < n0; ++i) c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function () {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
          return d3_ease_quad;
        },
        cubic: function () {
          return d3_ease_cubic;
        },
        sin: function () {
          return d3_ease_sin;
        },
        exp: function () {
          return d3_ease_exp;
        },
        circle: function () {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function (f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function (name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function (t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function (t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function (t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function (t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / τ * Math.asin(1 / a);else a = 1, s = p / 4;
        return function (t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function (t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;
        return function (t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;
        return function (t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function (t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function (string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function () {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
      }
      function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
          var i = s.push("translate(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        }
      }
      function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
          if (ra - rb > 180) rb += 360;else if (rb - ra > 180) ra += 360;
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
        }
      }
      function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
        }
      }
      function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
          var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
          s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
        }
      }
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function (t) {
          var i = -1,
              n = q.length,
              o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function () {
        return function (links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function () {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function (a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function (d, i) {
              d.sort(function (a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: groupSums[di]
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords) resort();
        }
        function resort() {
          chords.sort(function (a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function (x) {
          if (!arguments.length) return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function (x) {
          if (!arguments.length) return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function (x) {
          if (!arguments.length) return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function (x) {
          if (!arguments.length) return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function (x) {
          if (!arguments.length) return sortChords;
          sortChords = x;
          if (chords) resort();
          return chord;
        };
        chord.chords = function () {
          if (!chords) relayout();
          return chords;
        };
        chord.groups = function () {
          if (!groups) relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function () {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            timer,
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function (quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function () {
          if ((alpha *= .99) < .005) {
            timer = null;
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k) while (++i < n) {
              o = nodes[i];
              o.x += (x - o.x) * k;
              o.y += (y - o.y) * k;
            }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function (x) {
          if (!arguments.length) return nodes;
          nodes = x;
          return force;
        };
        force.links = function (x) {
          if (!arguments.length) return links;
          links = x;
          return force;
        };
        force.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return force;
        };
        force.linkDistance = function (x) {
          if (!arguments.length) return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
          if (!arguments.length) return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function (x) {
          if (!arguments.length) return friction;
          friction = +x;
          return force;
        };
        force.charge = function (x) {
          if (!arguments.length) return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function (x) {
          if (!arguments.length) return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function (x) {
          if (!arguments.length) return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function (x) {
          if (!arguments.length) return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function (x) {
          if (!arguments.length) return alpha;
          x = +x;
          if (alpha) {
            if (x > 0) {
              alpha = x;
            } else {
              timer.c = null, timer.t = NaN, timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
            }
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            timer = d3_timer(force.tick);
          }
          return force;
        };
        force.start = function () {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number") o.source = nodes[o.source];
            if (typeof o.target == "number") o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x)) o.x = position("x", w);
            if (isNaN(o.y)) o.y = position("y", h);
            if (isNaN(o.px)) o.px = o.x;
            if (isNaN(o.py)) o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);else for (i = 0; i < m; ++i) distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);else for (i = 0; i < n; ++i) charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                l = candidates.length,
                x;
            while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function () {
          return force.alpha(.1);
        };
        force.stop = function () {
          return force.alpha(0);
        };
        force.drag = function () {
          if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length) return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null) continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n, childs, child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value) node.value = 0;
              node.children = childs;
            } else {
              if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function (node) {
            var childs, parent;
            if (sort && (childs = node.children)) childs.sort(sort);
            if (value && (parent = node.parent)) parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function (x) {
          if (!arguments.length) return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function (x) {
          if (!arguments.length) return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function (x) {
          if (!arguments.length) return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function (root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function (node) {
              if (node.children) node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function (node) {
              var parent;
              if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent) parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n, children;
            while (--n >= 0) nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n) nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
          return (parent.children || []).map(function (child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n) d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function () {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function (d, i) {
            return +value.call(pie, d, i);
          }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              sum = d3.sum(values),
              k = sum ? (da - n * pa) / sum : 0,
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
            return values[j] - values[i];
          } : function (i, j) {
            return sort(data[i], data[j]);
          });
          index.forEach(function (i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function (_) {
          if (!arguments.length) return value;
          value = _;
          return pie;
        };
        pie.sort = function (_) {
          if (!arguments.length) return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function (_) {
          if (!arguments.length) return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function (_) {
          if (!arguments.length) return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function (_) {
          if (!arguments.length) return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function () {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length)) return data;
          var series = data.map(function (d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function (d) {
            return d.map(function (v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function (x) {
          if (!arguments.length) return values;
          values = x;
          return stack;
        };
        stack.order = function (x) {
          if (!arguments.length) return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function (x) {
          if (!arguments.length) return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function (z) {
          if (!arguments.length) return x;
          x = z;
          return stack;
        };
        stack.y = function (z) {
          if (!arguments.length) return y;
          y = z;
          return stack;
        };
        stack.out = function (z) {
          if (!arguments.length) return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function (data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function (a, b) {
            return max[a] - max[b];
          }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
            if (o > max) max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function (data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0) o0 = o;
          }
          for (j = 0; j < m; ++j) y0[j] -= o0;
          return y0;
        },
        expand: function (data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
            if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;else for (i = 0; i < n; i++) data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j) y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function () {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function (x) {
          if (!arguments.length) return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function (x) {
          if (!arguments.length) return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function (x) {
          if (!arguments.length) return binner;
          binner = typeof x === "number" ? function (range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function (x) {
          if (!arguments.length) return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function () {
            return radius;
          };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function (d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function (d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function (d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function (_) {
          if (!arguments.length) return size;
          size = _;
          return pack;
        };
        pack.radius = function (_) {
          if (!arguments.length) return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function (_) {
          if (!arguments.length) return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);else d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function (node) {
              if (node.x < left.x) left = node;
              if (node.x > right.x) right = node;
              if (node.depth > bottom.depth) bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function (node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
          if (!arguments.length) return separation;
          separation = x;
          return tree;
        };
        tree.size = function (x) {
          if (!arguments.length) return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function (x) {
          if (!arguments.length) return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function (node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function (node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function (x) {
          if (!arguments.length) return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function (x) {
          if (!arguments.length) return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function (x) {
          if (!arguments.length) return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area)) continue;
            if (r < rmin) rmin = r;
            if (r > rmax) rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy) v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx) v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = root.y = 0;
          if (root.value) root.dx = size[0], root.dy = size[1];else root.dx = root.dy = 0;
          if (stickies) hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky) stickies = nodes;
          return nodes;
        }
        treemap.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return treemap;
        };
        treemap.padding = function (x) {
          if (!arguments.length) return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function (x) {
          if (!arguments.length) return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function (x) {
          if (!arguments.length) return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function (x) {
          if (!arguments.length) return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function (x) {
          if (!arguments.length) return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function (µ, σ) {
          var n = arguments.length;
          if (n < 2) σ = 1;
          if (n < 1) µ = 0;
          return function () {
            var x, y, r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function () {
          var random = d3.random.normal.apply(d3, arguments);
          return function () {
            return Math.exp(random());
          };
        },
        bates: function (m) {
          var random = d3.random.irwinHall(m);
          return function () {
            return random() / m;
          };
        },
        irwinHall: function (m) {
          return function () {
            for (var s = 0, j = 0; j < m; j++) s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function (x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function (x) {
            return Math.floor(x / step) * step;
          },
          ceil: function (x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function () {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function (y) {
          return input(y);
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function (x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
          if (!arguments.length) return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function (x) {
          if (!arguments.length) return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function () {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15) step *= 10;else if (err <= .35) step *= 5;else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function (d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function (x) {
          return pow(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function (_) {
          if (!arguments.length) return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function () {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function () {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j;) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function (n, format) {
          if (!arguments.length) return d3_scale_logFormat;
          if (arguments.length < 2) format = d3_scale_logFormat;else if (typeof format !== "function") format = d3.format(format);
          var k = Math.max(1, base * n / scale.ticks().length);
          return function (d) {
            var i = d / pow(Math.round(log(d)));
            if (i * base < base - .5) i *= base;
            return i <= k ? format(d) : "";
          };
        };
        scale.copy = function () {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
        floor: function (x) {
          return -Math.ceil(-x);
        },
        ceil: function (x) {
          return -Math.floor(-x);
        }
      };
      d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function (x) {
          return powb(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
          if (!arguments.length) return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function () {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function (x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function (i) {
            return start + step * i;
          });
        }
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function (x, padding) {
          if (arguments.length < 2) padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
          if (arguments.length < 2) padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
          if (arguments.length < 2) padding = 0;
          if (arguments.length < 3) outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse) range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
          if (arguments.length < 2) padding = 0;
          if (arguments.length < 3) outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse) range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function () {
          return rangeBand;
        };
        scale.rangeExtent = function () {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function () {
          return thresholds;
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function () {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function (x) {
          if (!arguments.length) return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function () {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function () {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
          if (!arguments.length) return domain;
          domain = _;
          return scale;
        };
        scale.range = function (_) {
          if (!arguments.length) return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function () {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function () {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
          if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw) p1 *= -1;
            if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var rc1 = rc,
                rc0 = rc;
            if (da < π) {
              var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                  ax = x0 - oc[0],
                  ay = y0 - oc[1],
                  bx = x1 - oc[0],
                  by = y1 - oc[1],
                  kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                  lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
              rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
            }
            if (x1 != null) {
              var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function (v) {
          if (!arguments.length) return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function (v) {
          if (!arguments.length) return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function (v) {
          if (!arguments.length) return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function (v) {
          if (!arguments.length) return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function (v) {
          if (!arguments.length) return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function (v) {
          if (!arguments.length) return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function (v) {
          if (!arguments.length) return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function () {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length) segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function (_) {
          if (!arguments.length) return x;
          x = _;
          return line;
        };
        line.y = function (_) {
          if (!arguments.length) return y;
          y = _;
          return line;
        };
        line.defined = function (_) {
          if (!arguments.length) return defined;
          defined = _;
          return line;
        };
        line.interpolate = function (_) {
          if (!arguments.length) return interpolateKey;
          if (typeof _ === "function") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function (_) {
          if (!arguments.length) return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function () {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
      }
      function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function () {
            return x;
          } : d3_functor(x1),
              fy1 = y0 === y1 ? function () {
            return y;
          } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length) segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function (_) {
          if (!arguments.length) return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function (_) {
          if (!arguments.length) return x0;
          x0 = _;
          return area;
        };
        area.x1 = function (_) {
          if (!arguments.length) return x1;
          x1 = _;
          return area;
        };
        area.y = function (_) {
          if (!arguments.length) return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function (_) {
          if (!arguments.length) return y0;
          y0 = _;
          return area;
        };
        area.y1 = function (_) {
          if (!arguments.length) return y1;
          y1 = _;
          return area;
        };
        area.defined = function (_) {
          if (!arguments.length) return defined;
          defined = _;
          return area;
        };
        area.interpolate = function (_) {
          if (!arguments.length) return interpolateKey;
          if (typeof _ === "function") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function (_) {
          if (!arguments.length) return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function () {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function () {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function (v) {
          if (!arguments.length) return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function (v) {
          if (!arguments.length) return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function (v) {
          if (!arguments.length) return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function (v) {
          if (!arguments.length) return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function (v) {
          if (!arguments.length) return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function () {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
            x: p0.x,
            y: m
          }, {
            x: p3.x,
            y: m
          }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function (x) {
          if (!arguments.length) return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function (x) {
          if (!arguments.length) return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function (x) {
          if (!arguments.length) return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function (x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function () {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function () {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
          if (!arguments.length) return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function (x) {
          if (!arguments.length) return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function (size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function (size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function (size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function (size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
          time: Date.now(),
          ease: d3_ease_cubicInOut,
          delay: 0,
          duration: 250
        };
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
      };
      var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
      function d3_selection_interruptNS(ns) {
        return function () {
          var lock, activeId, active;
          if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
            active.timer.c = null;
            active.timer.t = NaN;
            if (--lock.count) delete lock[activeId];else delete this[ns];
            lock.active += .5;
            active.event && active.event.interrupt.call(this, this.__data__, active.index);
          }
        };
      }
      function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function (selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1, o = subnodes.length; ++k < o;) {
                if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function (filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
          node[ns][id].tween.remove(name);
        } : function (node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function (node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS) this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function () {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function (t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function () {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function (t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function (t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function (t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2) value = "";
            for (priority in name) this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function () {
            var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function (t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
          return f && function (t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null) b = "";
        return function () {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each("end.transition", function () {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function (type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          try {
            d3_transitionInheritId = id;
            d3_selection_each(this, function (node, i, j) {
              d3_transitionInherit = node[ns][id];
              type.call(node, node.__data__, i, j);
            });
          } finally {
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
          }
        } else {
          d3_selection_each(this, function (node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function () {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
          active: 0,
          count: 0
        }),
            transition = lock[id],
            time,
            timer,
            duration,
            ease,
            tweens;
        function schedule(elapsed) {
          var delay = transition.delay;
          timer.t = delay + time;
          if (delay <= elapsed) return start(elapsed - delay);
          timer.c = start;
        }
        function start(elapsed) {
          var activeId = lock.active,
              active = lock[activeId];
          if (active) {
            active.timer.c = null;
            active.timer.t = NaN;
            --lock.count;
            delete lock[activeId];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          for (var cancelId in lock) {
            if (+cancelId < id) {
              var cancel = lock[cancelId];
              cancel.timer.c = null;
              cancel.timer.t = NaN;
              --lock.count;
              delete lock[cancelId];
            }
          }
          timer.c = tick;
          d3_timer(function () {
            if (timer.c && tick(elapsed || 1)) {
              timer.c = null;
              timer.t = NaN;
            }
            return 1;
          }, 0, time);
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          tweens = [];
          transition.tween.forEach(function (key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweens.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
        }
        function tick(elapsed) {
          var t = elapsed / duration,
              e = ease(t),
              n = tweens.length;
          while (n > 0) {
            tweens[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            if (--lock.count) delete lock[id];else delete node[ns];
            return 1;
          }
        }
        if (!transition) {
          time = inherit.time;
          timer = d3_timer(schedule, 0, time);
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            timer: timer,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease,
            index: i
          };
          inherit = null;
          ++lock.count;
        }
      }
      d3.svg.axis = function () {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function () {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function (d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function (x) {
          if (!arguments.length) return scale;
          scale = x;
          return axis;
        };
        axis.orient = function (x) {
          if (!arguments.length) return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function () {
          if (!arguments.length) return tickArguments_;
          tickArguments_ = d3_array(arguments);
          return axis;
        };
        axis.tickValues = function (x) {
          if (!arguments.length) return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function (x) {
          if (!arguments.length) return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function (x) {
          var n = arguments.length;
          if (!n) return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function (x) {
          if (!arguments.length) return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function (x) {
          if (!arguments.length) return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function (x) {
          if (!arguments.length) return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function () {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function (d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function (d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function () {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function (d) {
              return "resize " + d;
            }).style("cursor", function (d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function (d) {
              return (/[ew]$/.test(d) ? -3 : null
              );
            }).attr("y", function (d) {
              return (/^[ns]/.test(d) ? -3 : null
              );
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function (g) {
          g.each(function () {
            var event_ = event.of(this, arguments),
                extent1 = {
              x: xExtent,
              y: yExtent,
              i: xExtentDomain,
              j: yExtentDomain
            },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function () {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({
                  type: "brushstart"
                });
              }).tween("brush:brush", function () {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function (t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function () {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              });
            } else {
              event_({
                type: "brushstart"
              });
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({
                type: "brushend"
              });
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function (d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(target),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey) center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({
            type: "brushstart"
          });
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i) yExtentDomain = null;else xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({
              type: "brushend"
            });
          }
        }
        brush.x = function (z) {
          if (!arguments.length) return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function (z) {
          if (!arguments.length) return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function (z) {
          if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y) xClamp = !!z[0], yClamp = !!z[1];else if (x) xClamp = !!z;else if (y) yClamp = !!z;
          return brush;
        };
        brush.extent = function (z) {
          var x0, x1, y0, y1, t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y) x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert) x0 = x(x0), x1 = x(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x) y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert) y0 = y(y0), y1 = y(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function () {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function () {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function (date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function (date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function (date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function (date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function (x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function (d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method) interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function (date) {
              while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function (date) {
              while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function (interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{
            range: interval
          }, skip];
          if (method) interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
          return format;
        };
        scale.copy = function () {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function (d) {
        return d.getMilliseconds();
      }], [":%S", function (d) {
        return d.getSeconds();
      }], ["%I:%M", function (d) {
        return d.getMinutes();
      }], ["%I %p", function (d) {
        return d.getHours();
      }], ["%a %d", function (d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function (d) {
        return d.getDate() != 1;
      }], ["%B", function (d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function (d) {
        return d.getUTCMilliseconds();
      }], [":%S", function (d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function (d) {
        return d.getUTCMinutes();
      }], ["%I %p", function (d) {
        return d.getUTCHours();
      }], ["%a %d", function (d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function (d) {
        return d.getUTCDate() != 1;
      }], ["%B", function (d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function (request) {
        return request.responseText;
      });
      d3.json = function (url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function (url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd) this.d3 = d3, define(d3);else if (typeof module === "object" && module.exports) module.exports = d3;else this.d3 = d3;
    }();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6c", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('6d', ['6b', '6c'], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'c3', null);

    (function ($__global) {
        (function (window) {
            'use strict';

            /*global define, module, exports, require */

            var c3 = { version: "0.4.11" };

            var c3_chart_fn, c3_chart_internal_fn, c3_chart_internal_axis_fn;

            function API(owner) {
                this.owner = owner;
            }

            function inherit(base, derived) {

                if (Object.create) {
                    derived.prototype = Object.create(base.prototype);
                } else {
                    var f = function f() {};
                    f.prototype = base.prototype;
                    derived.prototype = new f();
                }

                derived.prototype.constructor = derived;

                return derived;
            }

            function Chart(config) {
                var $$ = this.internal = new ChartInternal(this);
                $$.loadConfig(config);

                $$.beforeInit(config);
                $$.init();
                $$.afterInit(config);

                // bind "this" to nested API
                (function bindThis(fn, target, argThis) {
                    Object.keys(fn).forEach(function (key) {
                        target[key] = fn[key].bind(argThis);
                        if (Object.keys(fn[key]).length > 0) {
                            bindThis(fn[key], target[key], argThis);
                        }
                    });
                })(c3_chart_fn, this, this);
            }

            function ChartInternal(api) {
                var $$ = this;
                $$.d3 = window.d3 ? window.d3 : typeof require !== 'undefined' ? require("d3") : undefined;
                $$.api = api;
                $$.config = $$.getDefaultConfig();
                $$.data = {};
                $$.cache = {};
                $$.axes = {};
            }

            c3.generate = function (config) {
                return new Chart(config);
            };

            c3.chart = {
                fn: Chart.prototype,
                internal: {
                    fn: ChartInternal.prototype,
                    axis: {
                        fn: Axis.prototype
                    }
                }
            };
            c3_chart_fn = c3.chart.fn;
            c3_chart_internal_fn = c3.chart.internal.fn;
            c3_chart_internal_axis_fn = c3.chart.internal.axis.fn;

            c3_chart_internal_fn.beforeInit = function () {
                // can do something
            };
            c3_chart_internal_fn.afterInit = function () {
                // can do something
            };
            c3_chart_internal_fn.init = function () {
                var $$ = this,
                    config = $$.config;

                $$.initParams();

                if (config.data_url) {
                    $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);
                } else if (config.data_json) {
                    $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
                } else if (config.data_rows) {
                    $$.initWithData($$.convertRowsToData(config.data_rows));
                } else if (config.data_columns) {
                    $$.initWithData($$.convertColumnsToData(config.data_columns));
                } else {
                    throw Error('url or json or rows or columns is required.');
                }
            };

            c3_chart_internal_fn.initParams = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;

                // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
                $$.clipId = "c3-" + +new Date() + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
                $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;
                $$.dragging = false;
                $$.flowing = false;
                $$.cancelClick = false;
                $$.mouseover = false;
                $$.transiting = false;

                $$.color = $$.generateColor();
                $$.levelColor = $$.generateLevelColor();

                $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;
                $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;
                $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[".%L", function (d) {
                    return d.getMilliseconds();
                }], [":%S", function (d) {
                    return d.getSeconds();
                }], ["%I:%M", function (d) {
                    return d.getMinutes();
                }], ["%I %p", function (d) {
                    return d.getHours();
                }], ["%-m/%-d", function (d) {
                    return d.getDay() && d.getDate() !== 1;
                }], ["%-m/%-d", function (d) {
                    return d.getDate() !== 1;
                }], ["%-m/%-d", function (d) {
                    return d.getMonth();
                }], ["%Y/%-m/%-d", function () {
                    return true;
                }]]);

                $$.hiddenTargetIds = [];
                $$.hiddenLegendIds = [];
                $$.focusedTargetIds = [];
                $$.defocusedTargetIds = [];

                $$.xOrient = config.axis_rotated ? "left" : "bottom";
                $$.yOrient = config.axis_rotated ? config.axis_y_inner ? "top" : "bottom" : config.axis_y_inner ? "right" : "left";
                $$.y2Orient = config.axis_rotated ? config.axis_y2_inner ? "bottom" : "top" : config.axis_y2_inner ? "left" : "right";
                $$.subXOrient = config.axis_rotated ? "left" : "bottom";

                $$.isLegendRight = config.legend_position === 'right';
                $$.isLegendInset = config.legend_position === 'inset';
                $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';
                $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';
                $$.legendStep = 0;
                $$.legendItemWidth = 0;
                $$.legendItemHeight = 0;

                $$.currentMaxTickWidths = {
                    x: 0,
                    y: 0,
                    y2: 0
                };

                $$.rotated_padding_left = 30;
                $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
                $$.rotated_padding_top = 5;

                $$.withoutFadeIn = {};

                $$.intervalForObserveInserted = undefined;

                $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js
            };

            c3_chart_internal_fn.initChartElements = function () {
                if (this.initBar) {
                    this.initBar();
                }
                if (this.initLine) {
                    this.initLine();
                }
                if (this.initArc) {
                    this.initArc();
                }
                if (this.initGauge) {
                    this.initGauge();
                }
                if (this.initText) {
                    this.initText();
                }
            };

            c3_chart_internal_fn.initWithData = function (data) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                var defs,
                    main,
                    binding = true;

                $$.axis = new Axis($$);

                if ($$.initPie) {
                    $$.initPie();
                }
                if ($$.initBrush) {
                    $$.initBrush();
                }
                if ($$.initZoom) {
                    $$.initZoom();
                }

                if (!config.bindto) {
                    $$.selectChart = d3.selectAll([]);
                } else if (typeof config.bindto.node === 'function') {
                    $$.selectChart = config.bindto;
                } else {
                    $$.selectChart = d3.select(config.bindto);
                }
                if ($$.selectChart.empty()) {
                    $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);
                    $$.observeInserted($$.selectChart);
                    binding = false;
                }
                $$.selectChart.html("").classed("c3", true);

                // Init data as targets
                $$.data.xs = {};
                $$.data.targets = $$.convertDataToTargets(data);

                if (config.data_filter) {
                    $$.data.targets = $$.data.targets.filter(config.data_filter);
                }

                // Set targets to hide if needed
                if (config.data_hide) {
                    $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);
                }
                if (config.legend_hide) {
                    $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);
                }

                // when gauge, hide legend // TODO: fix
                if ($$.hasType('gauge')) {
                    config.legend_show = false;
                }

                // Init sizes and scales
                $$.updateSizes();
                $$.updateScales();

                // Set domains for each scale
                $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
                $$.y.domain($$.getYDomain($$.data.targets, 'y'));
                $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
                $$.subX.domain($$.x.domain());
                $$.subY.domain($$.y.domain());
                $$.subY2.domain($$.y2.domain());

                // Save original x domain for zoom update
                $$.orgXDomain = $$.x.domain();

                // Set initialized scales to brush and zoom
                if ($$.brush) {
                    $$.brush.scale($$.subX);
                }
                if (config.zoom_enabled) {
                    $$.zoom.scale($$.x);
                }

                /*-- Basic Elements --*/

                // Define svgs
                $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").on('mouseenter', function () {
                    return config.onmouseover.call($$);
                }).on('mouseleave', function () {
                    return config.onmouseout.call($$);
                });

                if ($$.config.svg_classname) {
                    $$.svg.attr('class', $$.config.svg_classname);
                }

                // Define defs
                defs = $$.svg.append("defs");
                $$.clipChart = $$.appendClip(defs, $$.clipId);
                $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
                $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
                $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
                $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
                $$.updateSvgSize();

                // Define regions
                main = $$.main = $$.svg.append("g").attr("transform", $$.getTranslate('main'));

                if ($$.initSubchart) {
                    $$.initSubchart();
                }
                if ($$.initTooltip) {
                    $$.initTooltip();
                }
                if ($$.initLegend) {
                    $$.initLegend();
                }
                if ($$.initTitle) {
                    $$.initTitle();
                }

                /*-- Main Region --*/

                // text when empty
                main.append("text").attr("class", CLASS.text + ' ' + CLASS.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
                .attr("dominant-baseline", "middle"); // vertical centering of text at y position in all browsers, except IE.

                // Regions
                $$.initRegion();

                // Grids
                $$.initGrid();

                // Define g for chart area
                main.append('g').attr("clip-path", $$.clipPath).attr('class', CLASS.chart);

                // Grid lines
                if (config.grid_lines_front) {
                    $$.initGridLines();
                }

                // Cover whole with rects for events
                $$.initEventRect();

                // Define g for chart
                $$.initChartElements();

                // if zoom privileged, insert rect to forefront
                // TODO: is this needed?
                main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on("dblclick.zoom", null);

                // Set default extent if defined
                if (config.axis_x_extent) {
                    $$.brush.extent($$.getDefaultExtent());
                }

                // Add Axis
                $$.axis.init();

                // Set targets
                $$.updateTargets($$.data.targets);

                // Draw with targets
                if (binding) {
                    $$.updateDimension();
                    $$.config.oninit.call($$);
                    $$.redraw({
                        withTransition: false,
                        withTransform: true,
                        withUpdateXDomain: true,
                        withUpdateOrgXDomain: true,
                        withTransitionForAxis: false
                    });
                }

                // Bind resize event
                $$.bindResize();

                // export element of the chart
                $$.api.element = $$.selectChart.node();
            };

            c3_chart_internal_fn.smoothLines = function (el, type) {
                var $$ = this;
                if (type === 'grid') {
                    el.each(function () {
                        var g = $$.d3.select(this),
                            x1 = g.attr('x1'),
                            x2 = g.attr('x2'),
                            y1 = g.attr('y1'),
                            y2 = g.attr('y2');
                        g.attr({
                            'x1': Math.ceil(x1),
                            'x2': Math.ceil(x2),
                            'y1': Math.ceil(y1),
                            'y2': Math.ceil(y2)
                        });
                    });
                }
            };

            c3_chart_internal_fn.updateSizes = function () {
                var $$ = this,
                    config = $$.config;
                var legendHeight = $$.legend ? $$.getLegendHeight() : 0,
                    legendWidth = $$.legend ? $$.getLegendWidth() : 0,
                    legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
                    hasArc = $$.hasArcType(),
                    xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),
                    subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0;

                $$.currentWidth = $$.getCurrentWidth();
                $$.currentHeight = $$.getCurrentHeight();

                // for main
                $$.margin = config.axis_rotated ? {
                    top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
                    right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                    bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),
                    left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
                } : {
                    top: 4 + $$.getCurrentPaddingTop(), // for top tick text
                    right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                    bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
                    left: hasArc ? 0 : $$.getCurrentPaddingLeft()
                };

                // for subchart
                $$.margin2 = config.axis_rotated ? {
                    top: $$.margin.top,
                    right: NaN,
                    bottom: 20 + legendHeightForBottom,
                    left: $$.rotated_padding_left
                } : {
                    top: $$.currentHeight - subchartHeight - legendHeightForBottom,
                    right: NaN,
                    bottom: xAxisHeight + legendHeightForBottom,
                    left: $$.margin.left
                };

                // for legend
                $$.margin3 = {
                    top: 0,
                    right: NaN,
                    bottom: 0,
                    left: 0
                };
                if ($$.updateSizeForLegend) {
                    $$.updateSizeForLegend(legendHeight, legendWidth);
                }

                $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
                $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
                if ($$.width < 0) {
                    $$.width = 0;
                }
                if ($$.height < 0) {
                    $$.height = 0;
                }

                $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;
                $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
                if ($$.width2 < 0) {
                    $$.width2 = 0;
                }
                if ($$.height2 < 0) {
                    $$.height2 = 0;
                }

                // for arc
                $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
                $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
                if ($$.hasType('gauge') && !config.gauge_fullCircle) {
                    $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
                }
                if ($$.updateRadius) {
                    $$.updateRadius();
                }

                if ($$.isLegendRight && hasArc) {
                    $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
                }
            };

            c3_chart_internal_fn.updateTargets = function (targets) {
                var $$ = this;

                /*-- Main --*/

                //-- Text --//
                $$.updateTargetsForText(targets);

                //-- Bar --//
                $$.updateTargetsForBar(targets);

                //-- Line --//
                $$.updateTargetsForLine(targets);

                //-- Arc --//
                if ($$.hasArcType() && $$.updateTargetsForArc) {
                    $$.updateTargetsForArc(targets);
                }

                /*-- Sub --*/

                if ($$.updateTargetsForSubchart) {
                    $$.updateTargetsForSubchart(targets);
                }

                // Fade-in each chart
                $$.showTargets();
            };
            c3_chart_internal_fn.showTargets = function () {
                var $$ = this;
                $$.svg.selectAll('.' + CLASS.target).filter(function (d) {
                    return $$.isTargetToShow(d.id);
                }).transition().duration($$.config.transition_duration).style("opacity", 1);
            };

            c3_chart_internal_fn.redraw = function (options, transitions) {
                var $$ = this,
                    main = $$.main,
                    d3 = $$.d3,
                    config = $$.config;
                var areaIndices = $$.getShapeIndices($$.isAreaType),
                    barIndices = $$.getShapeIndices($$.isBarType),
                    lineIndices = $$.getShapeIndices($$.isLineType);
                var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;
                var hideAxis = $$.hasArcType();
                var drawArea, drawBar, drawLine, xForText, yForText;
                var duration, durationForExit, durationForAxis;
                var waitForDraw, flow;
                var targetsToShow = $$.filterTargetsToShow($$.data.targets),
                    tickValues,
                    i,
                    intervalForCulling,
                    xDomainForZoom;
                var xv = $$.xv.bind($$),
                    cx,
                    cy;

                options = options || {};
                withY = getOption(options, "withY", true);
                withSubchart = getOption(options, "withSubchart", true);
                withTransition = getOption(options, "withTransition", true);
                withTransform = getOption(options, "withTransform", false);
                withUpdateXDomain = getOption(options, "withUpdateXDomain", false);
                withUpdateOrgXDomain = getOption(options, "withUpdateOrgXDomain", false);
                withTrimXDomain = getOption(options, "withTrimXDomain", true);
                withUpdateXAxis = getOption(options, "withUpdateXAxis", withUpdateXDomain);
                withLegend = getOption(options, "withLegend", false);
                withEventRect = getOption(options, "withEventRect", true);
                withDimension = getOption(options, "withDimension", true);
                withTransitionForExit = getOption(options, "withTransitionForExit", withTransition);
                withTransitionForAxis = getOption(options, "withTransitionForAxis", withTransition);

                duration = withTransition ? config.transition_duration : 0;
                durationForExit = withTransitionForExit ? duration : 0;
                durationForAxis = withTransitionForAxis ? duration : 0;

                transitions = transitions || $$.axis.generateTransitions(durationForAxis);

                // update legend and transform each g
                if (withLegend && config.legend_show) {
                    $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
                } else if (withDimension) {
                    // need to update dimension (e.g. axis.y.tick.values) because y tick values should change
                    // no need to update axis in it because they will be updated in redraw()
                    $$.updateDimension(true);
                }

                // MEMO: needed for grids calculation
                if ($$.isCategorized() && targetsToShow.length === 0) {
                    $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
                }

                if (targetsToShow.length) {
                    $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
                    if (!config.axis_x_tick_values) {
                        tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
                    }
                } else {
                    $$.xAxis.tickValues([]);
                    $$.subXAxis.tickValues([]);
                }

                if (config.zoom_rescale && !options.flow) {
                    xDomainForZoom = $$.x.orgDomain();
                }

                $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
                $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));

                if (!config.axis_y_tick_values && config.axis_y_tick_count) {
                    $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
                }
                if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
                    $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
                }

                // axes
                $$.axis.redraw(transitions, hideAxis);

                // Update axis label
                $$.axis.updateLabels(withTransition);

                // show/hide if manual culling needed
                if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
                    if (config.axis_x_tick_culling && tickValues) {
                        for (i = 1; i < tickValues.length; i++) {
                            if (tickValues.length / i < config.axis_x_tick_culling_max) {
                                intervalForCulling = i;
                                break;
                            }
                        }
                        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {
                            var index = tickValues.indexOf(e);
                            if (index >= 0) {
                                d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
                            }
                        });
                    } else {
                        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');
                    }
                }

                // setup drawer - MEMO: these must be called after axis updated
                drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;
                drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
                drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;
                xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
                yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);

                // Update sub domain
                if (withY) {
                    $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
                    $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
                }

                // xgrid focus
                $$.updateXgridFocus();

                // Data empty label positioning and text.
                main.select("text." + CLASS.text + '.' + CLASS.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1);

                // grid
                $$.updateGrid(duration);

                // rect for regions
                $$.updateRegion(duration);

                // bars
                $$.updateBar(durationForExit);

                // lines, areas and cricles
                $$.updateLine(durationForExit);
                $$.updateArea(durationForExit);
                $$.updateCircle();

                // text
                if ($$.hasDataLabel()) {
                    $$.updateText(durationForExit);
                }

                // title
                if ($$.redrawTitle) {
                    $$.redrawTitle();
                }

                // arc
                if ($$.redrawArc) {
                    $$.redrawArc(duration, durationForExit, withTransform);
                }

                // subchart
                if ($$.redrawSubchart) {
                    $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
                }

                // circles for select
                main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove();

                // event rects will redrawn when flow called
                if (config.interaction_enabled && !options.flow && withEventRect) {
                    $$.redrawEventRect();
                    if ($$.updateZoom) {
                        $$.updateZoom();
                    }
                }

                // update circleY based on updated parameters
                $$.updateCircleY();

                // generate circle x/y functions depending on updated params
                cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
                cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);

                if (options.flow) {
                    flow = $$.generateFlow({
                        targets: targetsToShow,
                        flow: options.flow,
                        duration: options.flow.duration,
                        drawBar: drawBar,
                        drawLine: drawLine,
                        drawArea: drawArea,
                        cx: cx,
                        cy: cy,
                        xv: xv,
                        xForText: xForText,
                        yForText: yForText
                    });
                }

                if ((duration || flow) && $$.isTabVisible()) {
                    // Only use transition if tab visible. See #938.
                    // transition should be derived from one transition
                    d3.transition().duration(duration).each(function () {
                        var transitionsToWait = [];

                        // redraw and gather transitions
                        [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function (transitions) {
                            transitions.forEach(function (transition) {
                                transitionsToWait.push(transition);
                            });
                        });

                        // Wait for end of transitions to call flow and onrendered callback
                        waitForDraw = $$.generateWait();
                        transitionsToWait.forEach(function (t) {
                            waitForDraw.add(t);
                        });
                    }).call(waitForDraw, function () {
                        if (flow) {
                            flow();
                        }
                        if (config.onrendered) {
                            config.onrendered.call($$);
                        }
                    });
                } else {
                    $$.redrawBar(drawBar);
                    $$.redrawLine(drawLine);
                    $$.redrawArea(drawArea);
                    $$.redrawCircle(cx, cy);
                    $$.redrawText(xForText, yForText, options.flow);
                    $$.redrawRegion();
                    $$.redrawGrid();
                    if (config.onrendered) {
                        config.onrendered.call($$);
                    }
                }

                // update fadein condition
                $$.mapToIds($$.data.targets).forEach(function (id) {
                    $$.withoutFadeIn[id] = true;
                });
            };

            c3_chart_internal_fn.updateAndRedraw = function (options) {
                var $$ = this,
                    config = $$.config,
                    transitions;
                options = options || {};
                // same with redraw
                options.withTransition = getOption(options, "withTransition", true);
                options.withTransform = getOption(options, "withTransform", false);
                options.withLegend = getOption(options, "withLegend", false);
                // NOT same with redraw
                options.withUpdateXDomain = true;
                options.withUpdateOrgXDomain = true;
                options.withTransitionForExit = false;
                options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition);
                // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)
                $$.updateSizes();
                // MEMO: called in updateLegend in redraw if withLegend
                if (!(options.withLegend && config.legend_show)) {
                    transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
                    // Update scales
                    $$.updateScales();
                    $$.updateSvgSize();
                    // Update g positions
                    $$.transformAll(options.withTransitionForTransform, transitions);
                }
                // Draw with new sizes & scales
                $$.redraw(options, transitions);
            };
            c3_chart_internal_fn.redrawWithoutRescale = function () {
                this.redraw({
                    withY: false,
                    withSubchart: false,
                    withEventRect: false,
                    withTransitionForAxis: false
                });
            };

            c3_chart_internal_fn.isTimeSeries = function () {
                return this.config.axis_x_type === 'timeseries';
            };
            c3_chart_internal_fn.isCategorized = function () {
                return this.config.axis_x_type.indexOf('categor') >= 0;
            };
            c3_chart_internal_fn.isCustomX = function () {
                var $$ = this,
                    config = $$.config;
                return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
            };

            c3_chart_internal_fn.isTimeSeriesY = function () {
                return this.config.axis_y_type === 'timeseries';
            };

            c3_chart_internal_fn.getTranslate = function (target) {
                var $$ = this,
                    config = $$.config,
                    x,
                    y;
                if (target === 'main') {
                    x = asHalfPixel($$.margin.left);
                    y = asHalfPixel($$.margin.top);
                } else if (target === 'context') {
                    x = asHalfPixel($$.margin2.left);
                    y = asHalfPixel($$.margin2.top);
                } else if (target === 'legend') {
                    x = $$.margin3.left;
                    y = $$.margin3.top;
                } else if (target === 'x') {
                    x = 0;
                    y = config.axis_rotated ? 0 : $$.height;
                } else if (target === 'y') {
                    x = 0;
                    y = config.axis_rotated ? $$.height : 0;
                } else if (target === 'y2') {
                    x = config.axis_rotated ? 0 : $$.width;
                    y = config.axis_rotated ? 1 : 0;
                } else if (target === 'subx') {
                    x = 0;
                    y = config.axis_rotated ? 0 : $$.height2;
                } else if (target === 'arc') {
                    x = $$.arcWidth / 2;
                    y = $$.arcHeight / 2;
                }
                return "translate(" + x + "," + y + ")";
            };
            c3_chart_internal_fn.initialOpacity = function (d) {
                return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
            };
            c3_chart_internal_fn.initialOpacityForCircle = function (d) {
                return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;
            };
            c3_chart_internal_fn.opacityForCircle = function (d) {
                var opacity = this.config.point_show ? 1 : 0;
                return isValue(d.value) ? this.isScatterType(d) ? 0.5 : opacity : 0;
            };
            c3_chart_internal_fn.opacityForText = function () {
                return this.hasDataLabel() ? 1 : 0;
            };
            c3_chart_internal_fn.xx = function (d) {
                return d ? this.x(d.x) : null;
            };
            c3_chart_internal_fn.xv = function (d) {
                var $$ = this,
                    value = d.value;
                if ($$.isTimeSeries()) {
                    value = $$.parseDate(d.value);
                } else if ($$.isCategorized() && typeof d.value === 'string') {
                    value = $$.config.axis_x_categories.indexOf(d.value);
                }
                return Math.ceil($$.x(value));
            };
            c3_chart_internal_fn.yv = function (d) {
                var $$ = this,
                    yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
                return Math.ceil(yScale(d.value));
            };
            c3_chart_internal_fn.subxx = function (d) {
                return d ? this.subX(d.x) : null;
            };

            c3_chart_internal_fn.transformMain = function (withTransition, transitions) {
                var $$ = this,
                    xAxis,
                    yAxis,
                    y2Axis;
                if (transitions && transitions.axisX) {
                    xAxis = transitions.axisX;
                } else {
                    xAxis = $$.main.select('.' + CLASS.axisX);
                    if (withTransition) {
                        xAxis = xAxis.transition();
                    }
                }
                if (transitions && transitions.axisY) {
                    yAxis = transitions.axisY;
                } else {
                    yAxis = $$.main.select('.' + CLASS.axisY);
                    if (withTransition) {
                        yAxis = yAxis.transition();
                    }
                }
                if (transitions && transitions.axisY2) {
                    y2Axis = transitions.axisY2;
                } else {
                    y2Axis = $$.main.select('.' + CLASS.axisY2);
                    if (withTransition) {
                        y2Axis = y2Axis.transition();
                    }
                }
                (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate('main'));
                xAxis.attr("transform", $$.getTranslate('x'));
                yAxis.attr("transform", $$.getTranslate('y'));
                y2Axis.attr("transform", $$.getTranslate('y2'));
                $$.main.select('.' + CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
            };
            c3_chart_internal_fn.transformAll = function (withTransition, transitions) {
                var $$ = this;
                $$.transformMain(withTransition, transitions);
                if ($$.config.subchart_show) {
                    $$.transformContext(withTransition, transitions);
                }
                if ($$.legend) {
                    $$.transformLegend(withTransition);
                }
            };

            c3_chart_internal_fn.updateSvgSize = function () {
                var $$ = this,
                    brush = $$.svg.select(".c3-brush .background");
                $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
                $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);
                $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));
                $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));
                $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);
                $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height);
                // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>
                $$.selectChart.style('max-height', $$.currentHeight + "px");
            };

            c3_chart_internal_fn.updateDimension = function (withoutAxis) {
                var $$ = this;
                if (!withoutAxis) {
                    if ($$.config.axis_rotated) {
                        $$.axes.x.call($$.xAxis);
                        $$.axes.subx.call($$.subXAxis);
                    } else {
                        $$.axes.y.call($$.yAxis);
                        $$.axes.y2.call($$.y2Axis);
                    }
                }
                $$.updateSizes();
                $$.updateScales();
                $$.updateSvgSize();
                $$.transformAll(false);
            };

            c3_chart_internal_fn.observeInserted = function (selection) {
                var $$ = this,
                    observer;
                if (typeof MutationObserver === 'undefined') {
                    window.console.error("MutationObserver not defined.");
                    return;
                }
                observer = new MutationObserver(function (mutations) {
                    mutations.forEach(function (mutation) {
                        if (mutation.type === 'childList' && mutation.previousSibling) {
                            observer.disconnect();
                            // need to wait for completion of load because size calculation requires the actual sizes determined after that completion
                            $$.intervalForObserveInserted = window.setInterval(function () {
                                // parentNode will NOT be null when completed
                                if (selection.node().parentNode) {
                                    window.clearInterval($$.intervalForObserveInserted);
                                    $$.updateDimension();
                                    if ($$.brush) {
                                        $$.brush.update();
                                    }
                                    $$.config.oninit.call($$);
                                    $$.redraw({
                                        withTransform: true,
                                        withUpdateXDomain: true,
                                        withUpdateOrgXDomain: true,
                                        withTransition: false,
                                        withTransitionForTransform: false,
                                        withLegend: true
                                    });
                                    selection.transition().style('opacity', 1);
                                }
                            }, 10);
                        }
                    });
                });
                observer.observe(selection.node(), { attributes: true, childList: true, characterData: true });
            };

            c3_chart_internal_fn.bindResize = function () {
                var $$ = this,
                    config = $$.config;

                $$.resizeFunction = $$.generateResize();

                $$.resizeFunction.add(function () {
                    config.onresize.call($$);
                });
                if (config.resize_auto) {
                    $$.resizeFunction.add(function () {
                        if ($$.resizeTimeout !== undefined) {
                            window.clearTimeout($$.resizeTimeout);
                        }
                        $$.resizeTimeout = window.setTimeout(function () {
                            delete $$.resizeTimeout;
                            $$.api.flush();
                        }, 100);
                    });
                }
                $$.resizeFunction.add(function () {
                    config.onresized.call($$);
                });

                if (window.attachEvent) {
                    window.attachEvent('onresize', $$.resizeFunction);
                } else if (window.addEventListener) {
                    window.addEventListener('resize', $$.resizeFunction, false);
                } else {
                    // fallback to this, if this is a very old browser
                    var wrapper = window.onresize;
                    if (!wrapper) {
                        // create a wrapper that will call all charts
                        wrapper = $$.generateResize();
                    } else if (!wrapper.add || !wrapper.remove) {
                        // there is already a handler registered, make sure we call it too
                        wrapper = $$.generateResize();
                        wrapper.add(window.onresize);
                    }
                    // add this graph to the wrapper, we will be removed if the user calls destroy
                    wrapper.add($$.resizeFunction);
                    window.onresize = wrapper;
                }
            };

            c3_chart_internal_fn.generateResize = function () {
                var resizeFunctions = [];
                function callResizeFunctions() {
                    resizeFunctions.forEach(function (f) {
                        f();
                    });
                }
                callResizeFunctions.add = function (f) {
                    resizeFunctions.push(f);
                };
                callResizeFunctions.remove = function (f) {
                    for (var i = 0; i < resizeFunctions.length; i++) {
                        if (resizeFunctions[i] === f) {
                            resizeFunctions.splice(i, 1);
                            break;
                        }
                    }
                };
                return callResizeFunctions;
            };

            c3_chart_internal_fn.endall = function (transition, callback) {
                var n = 0;
                transition.each(function () {
                    ++n;
                }).each("end", function () {
                    if (! --n) {
                        callback.apply(this, arguments);
                    }
                });
            };
            c3_chart_internal_fn.generateWait = function () {
                var transitionsToWait = [],
                    f = function (transition, callback) {
                    var timer = setInterval(function () {
                        var done = 0;
                        transitionsToWait.forEach(function (t) {
                            if (t.empty()) {
                                done += 1;
                                return;
                            }
                            try {
                                t.transition();
                            } catch (e) {
                                done += 1;
                            }
                        });
                        if (done === transitionsToWait.length) {
                            clearInterval(timer);
                            if (callback) {
                                callback();
                            }
                        }
                    }, 10);
                };
                f.add = function (transition) {
                    transitionsToWait.push(transition);
                };
                return f;
            };

            c3_chart_internal_fn.parseDate = function (date) {
                var $$ = this,
                    parsedDate;
                if (date instanceof Date) {
                    parsedDate = date;
                } else if (typeof date === 'string') {
                    parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);
                } else if (typeof date === 'number' && !isNaN(date)) {
                    parsedDate = new Date(+date);
                }
                if (!parsedDate || isNaN(+parsedDate)) {
                    window.console.error("Failed to parse x '" + date + "' to Date object");
                }
                return parsedDate;
            };

            c3_chart_internal_fn.isTabVisible = function () {
                var hidden;
                if (typeof document.hidden !== "undefined") {
                    // Opera 12.10 and Firefox 18 and later support
                    hidden = "hidden";
                } else if (typeof document.mozHidden !== "undefined") {
                    hidden = "mozHidden";
                } else if (typeof document.msHidden !== "undefined") {
                    hidden = "msHidden";
                } else if (typeof document.webkitHidden !== "undefined") {
                    hidden = "webkitHidden";
                }

                return document[hidden] ? false : true;
            };

            c3_chart_internal_fn.getDefaultConfig = function () {
                var config = {
                    bindto: '#chart',
                    svg_classname: undefined,
                    size_width: undefined,
                    size_height: undefined,
                    padding_left: undefined,
                    padding_right: undefined,
                    padding_top: undefined,
                    padding_bottom: undefined,
                    resize_auto: true,
                    zoom_enabled: false,
                    zoom_extent: undefined,
                    zoom_privileged: false,
                    zoom_rescale: false,
                    zoom_onzoom: function () {},
                    zoom_onzoomstart: function () {},
                    zoom_onzoomend: function () {},
                    zoom_x_min: undefined,
                    zoom_x_max: undefined,
                    interaction_brighten: true,
                    interaction_enabled: true,
                    onmouseover: function () {},
                    onmouseout: function () {},
                    onresize: function () {},
                    onresized: function () {},
                    oninit: function () {},
                    onrendered: function () {},
                    transition_duration: 350,
                    data_x: undefined,
                    data_xs: {},
                    data_xFormat: '%Y-%m-%d',
                    data_xLocaltime: true,
                    data_xSort: true,
                    data_idConverter: function (id) {
                        return id;
                    },
                    data_names: {},
                    data_classes: {},
                    data_groups: [],
                    data_axes: {},
                    data_type: undefined,
                    data_types: {},
                    data_labels: {},
                    data_order: 'desc',
                    data_regions: {},
                    data_color: undefined,
                    data_colors: {},
                    data_hide: false,
                    data_filter: undefined,
                    data_selection_enabled: false,
                    data_selection_grouped: false,
                    data_selection_isselectable: function () {
                        return true;
                    },
                    data_selection_multiple: true,
                    data_selection_draggable: false,
                    data_onclick: function () {},
                    data_onmouseover: function () {},
                    data_onmouseout: function () {},
                    data_onselected: function () {},
                    data_onunselected: function () {},
                    data_url: undefined,
                    data_headers: undefined,
                    data_json: undefined,
                    data_rows: undefined,
                    data_columns: undefined,
                    data_mimeType: undefined,
                    data_keys: undefined,
                    // configuration for no plot-able data supplied.
                    data_empty_label_text: "",
                    // subchart
                    subchart_show: false,
                    subchart_size_height: 60,
                    subchart_axis_x_show: true,
                    subchart_onbrush: function () {},
                    // color
                    color_pattern: [],
                    color_threshold: {},
                    // legend
                    legend_show: true,
                    legend_hide: false,
                    legend_position: 'bottom',
                    legend_inset_anchor: 'top-left',
                    legend_inset_x: 10,
                    legend_inset_y: 0,
                    legend_inset_step: undefined,
                    legend_item_onclick: undefined,
                    legend_item_onmouseover: undefined,
                    legend_item_onmouseout: undefined,
                    legend_equally: false,
                    legend_padding: 0,
                    legend_item_tile_width: 10,
                    legend_item_tile_height: 10,
                    // axis
                    axis_rotated: false,
                    axis_x_show: true,
                    axis_x_type: 'indexed',
                    axis_x_localtime: true,
                    axis_x_categories: [],
                    axis_x_tick_centered: false,
                    axis_x_tick_format: undefined,
                    axis_x_tick_culling: {},
                    axis_x_tick_culling_max: 10,
                    axis_x_tick_count: undefined,
                    axis_x_tick_fit: true,
                    axis_x_tick_values: null,
                    axis_x_tick_rotate: 0,
                    axis_x_tick_outer: true,
                    axis_x_tick_multiline: true,
                    axis_x_tick_width: null,
                    axis_x_max: undefined,
                    axis_x_min: undefined,
                    axis_x_padding: {},
                    axis_x_height: undefined,
                    axis_x_extent: undefined,
                    axis_x_label: {},
                    axis_y_show: true,
                    axis_y_type: undefined,
                    axis_y_max: undefined,
                    axis_y_min: undefined,
                    axis_y_inverted: false,
                    axis_y_center: undefined,
                    axis_y_inner: undefined,
                    axis_y_label: {},
                    axis_y_tick_format: undefined,
                    axis_y_tick_outer: true,
                    axis_y_tick_values: null,
                    axis_y_tick_rotate: 0,
                    axis_y_tick_count: undefined,
                    axis_y_tick_time_value: undefined,
                    axis_y_tick_time_interval: undefined,
                    axis_y_padding: {},
                    axis_y_default: undefined,
                    axis_y2_show: false,
                    axis_y2_max: undefined,
                    axis_y2_min: undefined,
                    axis_y2_inverted: false,
                    axis_y2_center: undefined,
                    axis_y2_inner: undefined,
                    axis_y2_label: {},
                    axis_y2_tick_format: undefined,
                    axis_y2_tick_outer: true,
                    axis_y2_tick_values: null,
                    axis_y2_tick_count: undefined,
                    axis_y2_padding: {},
                    axis_y2_default: undefined,
                    // grid
                    grid_x_show: false,
                    grid_x_type: 'tick',
                    grid_x_lines: [],
                    grid_y_show: false,
                    // not used
                    // grid_y_type: 'tick',
                    grid_y_lines: [],
                    grid_y_ticks: 10,
                    grid_focus_show: true,
                    grid_lines_front: true,
                    // point - point of each data
                    point_show: true,
                    point_r: 2.5,
                    point_sensitivity: 10,
                    point_focus_expand_enabled: true,
                    point_focus_expand_r: undefined,
                    point_select_r: undefined,
                    // line
                    line_connectNull: false,
                    line_step_type: 'step',
                    // bar
                    bar_width: undefined,
                    bar_width_ratio: 0.6,
                    bar_width_max: undefined,
                    bar_zerobased: true,
                    // area
                    area_zerobased: true,
                    area_above: false,
                    // pie
                    pie_label_show: true,
                    pie_label_format: undefined,
                    pie_label_threshold: 0.05,
                    pie_label_ratio: undefined,
                    pie_expand: {},
                    pie_expand_duration: 50,
                    // gauge
                    gauge_fullCircle: false,
                    gauge_label_show: true,
                    gauge_label_format: undefined,
                    gauge_min: 0,
                    gauge_max: 100,
                    gauge_startingAngle: -1 * Math.PI / 2,
                    gauge_units: undefined,
                    gauge_width: undefined,
                    gauge_expand: {},
                    gauge_expand_duration: 50,
                    // donut
                    donut_label_show: true,
                    donut_label_format: undefined,
                    donut_label_threshold: 0.05,
                    donut_label_ratio: undefined,
                    donut_width: undefined,
                    donut_title: "",
                    donut_expand: {},
                    donut_expand_duration: 50,
                    // spline
                    spline_interpolation_type: 'cardinal',
                    // region - region to change style
                    regions: [],
                    // tooltip - show when mouseover on each data
                    tooltip_show: true,
                    tooltip_grouped: true,
                    tooltip_format_title: undefined,
                    tooltip_format_name: undefined,
                    tooltip_format_value: undefined,
                    tooltip_position: undefined,
                    tooltip_contents: function (d, defaultTitleFormat, defaultValueFormat, color) {
                        return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';
                    },
                    tooltip_init_show: false,
                    tooltip_init_x: 0,
                    tooltip_init_position: { top: '0px', left: '50px' },
                    tooltip_onshow: function () {},
                    tooltip_onhide: function () {},
                    // title
                    title_text: undefined,
                    title_padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    },
                    title_position: 'top-center'
                };

                Object.keys(this.additionalConfig).forEach(function (key) {
                    config[key] = this.additionalConfig[key];
                }, this);

                return config;
            };
            c3_chart_internal_fn.additionalConfig = {};

            c3_chart_internal_fn.loadConfig = function (config) {
                var this_config = this.config,
                    target,
                    keys,
                    read;
                function find() {
                    var key = keys.shift();
                    //        console.log("key =>", key, ", target =>", target);
                    if (key && target && typeof target === 'object' && key in target) {
                        target = target[key];
                        return find();
                    } else if (!key) {
                        return target;
                    } else {
                        return undefined;
                    }
                }
                Object.keys(this_config).forEach(function (key) {
                    target = config;
                    keys = key.split('_');
                    read = find();
                    //        console.log("CONFIG : ", key, read);
                    if (isDefined(read)) {
                        this_config[key] = read;
                    }
                });
            };

            c3_chart_internal_fn.getScale = function (min, max, forTimeseries) {
                return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);
            };
            c3_chart_internal_fn.getX = function (min, max, domain, offset) {
                var $$ = this,
                    scale = $$.getScale(min, max, $$.isTimeSeries()),
                    _scale = domain ? scale.domain(domain) : scale,
                    key;
                // Define customized scale if categorized axis
                if ($$.isCategorized()) {
                    offset = offset || function () {
                        return 0;
                    };
                    scale = function (d, raw) {
                        var v = _scale(d) + offset(d);
                        return raw ? v : Math.ceil(v);
                    };
                } else {
                    scale = function (d, raw) {
                        var v = _scale(d);
                        return raw ? v : Math.ceil(v);
                    };
                }
                // define functions
                for (key in _scale) {
                    scale[key] = _scale[key];
                }
                scale.orgDomain = function () {
                    return _scale.domain();
                };
                // define custom domain() for categorized axis
                if ($$.isCategorized()) {
                    scale.domain = function (domain) {
                        if (!arguments.length) {
                            domain = this.orgDomain();
                            return [domain[0], domain[1] + 1];
                        }
                        _scale.domain(domain);
                        return scale;
                    };
                }
                return scale;
            };
            c3_chart_internal_fn.getY = function (min, max, domain) {
                var scale = this.getScale(min, max, this.isTimeSeriesY());
                if (domain) {
                    scale.domain(domain);
                }
                return scale;
            };
            c3_chart_internal_fn.getYScale = function (id) {
                return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
            };
            c3_chart_internal_fn.getSubYScale = function (id) {
                return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
            };
            c3_chart_internal_fn.updateScales = function () {
                var $$ = this,
                    config = $$.config,
                    forInit = !$$.x;
                // update edges
                $$.xMin = config.axis_rotated ? 1 : 0;
                $$.xMax = config.axis_rotated ? $$.height : $$.width;
                $$.yMin = config.axis_rotated ? 0 : $$.height;
                $$.yMax = config.axis_rotated ? $$.width : 1;
                $$.subXMin = $$.xMin;
                $$.subXMax = $$.xMax;
                $$.subYMin = config.axis_rotated ? 0 : $$.height2;
                $$.subYMax = config.axis_rotated ? $$.width2 : 1;
                // update scales
                $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {
                    return $$.xAxis.tickOffset();
                });
                $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());
                $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());
                $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {
                    return d % 1 ? 0 : $$.subXAxis.tickOffset();
                });
                $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());
                $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain());
                // update axes
                $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
                $$.xAxisTickValues = $$.axis.getXAxisTickValues();
                $$.yAxisTickValues = $$.axis.getYAxisTickValues();
                $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();

                $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
                $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
                $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);
                $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer);

                // Set initialized scales to brush and zoom
                if (!forInit) {
                    if ($$.brush) {
                        $$.brush.scale($$.subX);
                    }
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x);
                    }
                }
                // update for arc
                if ($$.updateArc) {
                    $$.updateArc();
                }
            };

            c3_chart_internal_fn.getYDomainMin = function (targets) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.mapToIds(targets),
                    ys = $$.getValuesAsIdKeyed(targets),
                    j,
                    k,
                    baseId,
                    idsInGroup,
                    id,
                    hasNegativeValue;
                if (config.data_groups.length > 0) {
                    hasNegativeValue = $$.hasNegativeValueInTargets(targets);
                    for (j = 0; j < config.data_groups.length; j++) {
                        // Determine baseId
                        idsInGroup = config.data_groups[j].filter(function (id) {
                            return ids.indexOf(id) >= 0;
                        });
                        if (idsInGroup.length === 0) {
                            continue;
                        }
                        baseId = idsInGroup[0];
                        // Consider negative values
                        if (hasNegativeValue && ys[baseId]) {
                            ys[baseId].forEach(function (v, i) {
                                ys[baseId][i] = v < 0 ? v : 0;
                            });
                        }
                        // Compute min
                        for (k = 1; k < idsInGroup.length; k++) {
                            id = idsInGroup[k];
                            if (!ys[id]) {
                                continue;
                            }
                            ys[id].forEach(function (v, i) {
                                if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {
                                    ys[baseId][i] += +v;
                                }
                            });
                        }
                    }
                }
                return $$.d3.min(Object.keys(ys).map(function (key) {
                    return $$.d3.min(ys[key]);
                }));
            };
            c3_chart_internal_fn.getYDomainMax = function (targets) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.mapToIds(targets),
                    ys = $$.getValuesAsIdKeyed(targets),
                    j,
                    k,
                    baseId,
                    idsInGroup,
                    id,
                    hasPositiveValue;
                if (config.data_groups.length > 0) {
                    hasPositiveValue = $$.hasPositiveValueInTargets(targets);
                    for (j = 0; j < config.data_groups.length; j++) {
                        // Determine baseId
                        idsInGroup = config.data_groups[j].filter(function (id) {
                            return ids.indexOf(id) >= 0;
                        });
                        if (idsInGroup.length === 0) {
                            continue;
                        }
                        baseId = idsInGroup[0];
                        // Consider positive values
                        if (hasPositiveValue && ys[baseId]) {
                            ys[baseId].forEach(function (v, i) {
                                ys[baseId][i] = v > 0 ? v : 0;
                            });
                        }
                        // Compute max
                        for (k = 1; k < idsInGroup.length; k++) {
                            id = idsInGroup[k];
                            if (!ys[id]) {
                                continue;
                            }
                            ys[id].forEach(function (v, i) {
                                if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {
                                    ys[baseId][i] += +v;
                                }
                            });
                        }
                    }
                }
                return $$.d3.max(Object.keys(ys).map(function (key) {
                    return $$.d3.max(ys[key]);
                }));
            };
            c3_chart_internal_fn.getYDomain = function (targets, axisId, xDomain) {
                var $$ = this,
                    config = $$.config,
                    targetsByAxisId = targets.filter(function (t) {
                    return $$.axis.getId(t.id) === axisId;
                }),
                    yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
                    yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,
                    yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,
                    yDomainMin = $$.getYDomainMin(yTargets),
                    yDomainMax = $$.getYDomainMax(yTargets),
                    domain,
                    domainLength,
                    padding,
                    padding_top,
                    padding_bottom,
                    center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,
                    yDomainAbs,
                    lengths,
                    diff,
                    ratio,
                    isAllPositive,
                    isAllNegative,
                    isZeroBased = $$.hasType('bar', yTargets) && config.bar_zerobased || $$.hasType('area', yTargets) && config.area_zerobased,
                    isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,
                    showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
                    showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;

                // MEMO: avoid inverting domain unexpectedly
                yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin;
                yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax;

                if (yTargets.length === 0) {
                    // use current domain if target of axisId is none
                    return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
                }
                if (isNaN(yDomainMin)) {
                    // set minimum to zero when not number
                    yDomainMin = 0;
                }
                if (isNaN(yDomainMax)) {
                    // set maximum to have same value as yDomainMin
                    yDomainMax = yDomainMin;
                }
                if (yDomainMin === yDomainMax) {
                    yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;
                }
                isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
                isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;

                // Cancel zerobased if axis_*_min / axis_*_max specified
                if (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) {
                    isZeroBased = false;
                }

                // Bar/Area chart should be 0-based if all positive|negative
                if (isZeroBased) {
                    if (isAllPositive) {
                        yDomainMin = 0;
                    }
                    if (isAllNegative) {
                        yDomainMax = 0;
                    }
                }

                domainLength = Math.abs(yDomainMax - yDomainMin);
                padding = padding_top = padding_bottom = domainLength * 0.1;

                if (typeof center !== 'undefined') {
                    yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
                    yDomainMax = center + yDomainAbs;
                    yDomainMin = center - yDomainAbs;
                }
                // add padding for data label
                if (showHorizontalDataLabel) {
                    lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
                    diff = diffDomain($$.y.range());
                    ratio = [lengths[0] / diff, lengths[1] / diff];
                    padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
                    padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
                } else if (showVerticalDataLabel) {
                    lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
                    padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);
                    padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);
                }
                if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
                    padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
                    padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
                }
                if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
                    padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
                    padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
                }
                // Bar/Area chart should be 0-based if all positive|negative
                if (isZeroBased) {
                    if (isAllPositive) {
                        padding_bottom = yDomainMin;
                    }
                    if (isAllNegative) {
                        padding_top = -yDomainMax;
                    }
                }
                domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
                return isInverted ? domain.reverse() : domain;
            };
            c3_chart_internal_fn.getXDomainMin = function (targets) {
                var $$ = this,
                    config = $$.config;
                return isDefined(config.axis_x_min) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min : $$.d3.min(targets, function (t) {
                    return $$.d3.min(t.values, function (v) {
                        return v.x;
                    });
                });
            };
            c3_chart_internal_fn.getXDomainMax = function (targets) {
                var $$ = this,
                    config = $$.config;
                return isDefined(config.axis_x_max) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max : $$.d3.max(targets, function (t) {
                    return $$.d3.max(t.values, function (v) {
                        return v.x;
                    });
                });
            };
            c3_chart_internal_fn.getXDomainPadding = function (domain) {
                var $$ = this,
                    config = $$.config,
                    diff = domain[1] - domain[0],
                    maxDataCount,
                    padding,
                    paddingLeft,
                    paddingRight;
                if ($$.isCategorized()) {
                    padding = 0;
                } else if ($$.hasType('bar')) {
                    maxDataCount = $$.getMaxDataCount();
                    padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;
                } else {
                    padding = diff * 0.01;
                }
                if (typeof config.axis_x_padding === 'object' && notEmpty(config.axis_x_padding)) {
                    paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;
                    paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;
                } else if (typeof config.axis_x_padding === 'number') {
                    paddingLeft = paddingRight = config.axis_x_padding;
                } else {
                    paddingLeft = paddingRight = padding;
                }
                return { left: paddingLeft, right: paddingRight };
            };
            c3_chart_internal_fn.getXDomain = function (targets) {
                var $$ = this,
                    xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
                    firstX = xDomain[0],
                    lastX = xDomain[1],
                    padding = $$.getXDomainPadding(xDomain),
                    min = 0,
                    max = 0;
                // show center of x domain if min and max are the same
                if (firstX - lastX === 0 && !$$.isCategorized()) {
                    if ($$.isTimeSeries()) {
                        firstX = new Date(firstX.getTime() * 0.5);
                        lastX = new Date(lastX.getTime() * 1.5);
                    } else {
                        firstX = firstX === 0 ? 1 : firstX * 0.5;
                        lastX = lastX === 0 ? -1 : lastX * 1.5;
                    }
                }
                if (firstX || firstX === 0) {
                    min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;
                }
                if (lastX || lastX === 0) {
                    max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;
                }
                return [min, max];
            };
            c3_chart_internal_fn.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
                var $$ = this,
                    config = $$.config;

                if (withUpdateOrgXDomain) {
                    $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
                    $$.orgXDomain = $$.x.domain();
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x).updateScaleExtent();
                    }
                    $$.subX.domain($$.x.domain());
                    if ($$.brush) {
                        $$.brush.scale($$.subX);
                    }
                }
                if (withUpdateXDomain) {
                    $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.extent());
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x).updateScaleExtent();
                    }
                }

                // Trim domain when too big by zoom mousemove event
                if (withTrim) {
                    $$.x.domain($$.trimXDomain($$.x.orgDomain()));
                }

                return $$.x.domain();
            };
            c3_chart_internal_fn.trimXDomain = function (domain) {
                var zoomDomain = this.getZoomDomain(),
                    min = zoomDomain[0],
                    max = zoomDomain[1];
                if (domain[0] <= min) {
                    domain[1] = +domain[1] + (min - domain[0]);
                    domain[0] = min;
                }
                if (max <= domain[1]) {
                    domain[0] = +domain[0] - (domain[1] - max);
                    domain[1] = max;
                }
                return domain;
            };

            c3_chart_internal_fn.isX = function (key) {
                var $$ = this,
                    config = $$.config;
                return config.data_x && key === config.data_x || notEmpty(config.data_xs) && hasValue(config.data_xs, key);
            };
            c3_chart_internal_fn.isNotX = function (key) {
                return !this.isX(key);
            };
            c3_chart_internal_fn.getXKey = function (id) {
                var $$ = this,
                    config = $$.config;
                return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
            };
            c3_chart_internal_fn.getXValuesOfXKey = function (key, targets) {
                var $$ = this,
                    xValues,
                    ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
                ids.forEach(function (id) {
                    if ($$.getXKey(id) === key) {
                        xValues = $$.data.xs[id];
                    }
                });
                return xValues;
            };
            c3_chart_internal_fn.getIndexByX = function (x) {
                var $$ = this,
                    data = $$.filterByX($$.data.targets, x);
                return data.length ? data[0].index : null;
            };
            c3_chart_internal_fn.getXValue = function (id, i) {
                var $$ = this;
                return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
            };
            c3_chart_internal_fn.getOtherTargetXs = function () {
                var $$ = this,
                    idsForX = Object.keys($$.data.xs);
                return idsForX.length ? $$.data.xs[idsForX[0]] : null;
            };
            c3_chart_internal_fn.getOtherTargetX = function (index) {
                var xs = this.getOtherTargetXs();
                return xs && index < xs.length ? xs[index] : null;
            };
            c3_chart_internal_fn.addXs = function (xs) {
                var $$ = this;
                Object.keys(xs).forEach(function (id) {
                    $$.config.data_xs[id] = xs[id];
                });
            };
            c3_chart_internal_fn.hasMultipleX = function (xs) {
                return this.d3.set(Object.keys(xs).map(function (id) {
                    return xs[id];
                })).size() > 1;
            };
            c3_chart_internal_fn.isMultipleX = function () {
                return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');
            };
            c3_chart_internal_fn.addName = function (data) {
                var $$ = this,
                    name;
                if (data) {
                    name = $$.config.data_names[data.id];
                    data.name = name !== undefined ? name : data.id;
                }
                return data;
            };
            c3_chart_internal_fn.getValueOnIndex = function (values, index) {
                var valueOnIndex = values.filter(function (v) {
                    return v.index === index;
                });
                return valueOnIndex.length ? valueOnIndex[0] : null;
            };
            c3_chart_internal_fn.updateTargetX = function (targets, x) {
                var $$ = this;
                targets.forEach(function (t) {
                    t.values.forEach(function (v, i) {
                        v.x = $$.generateTargetX(x[i], t.id, i);
                    });
                    $$.data.xs[t.id] = x;
                });
            };
            c3_chart_internal_fn.updateTargetXs = function (targets, xs) {
                var $$ = this;
                targets.forEach(function (t) {
                    if (xs[t.id]) {
                        $$.updateTargetX([t], xs[t.id]);
                    }
                });
            };
            c3_chart_internal_fn.generateTargetX = function (rawX, id, index) {
                var $$ = this,
                    x;
                if ($$.isTimeSeries()) {
                    x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
                } else if ($$.isCustomX() && !$$.isCategorized()) {
                    x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
                } else {
                    x = index;
                }
                return x;
            };
            c3_chart_internal_fn.cloneTarget = function (target) {
                return {
                    id: target.id,
                    id_org: target.id_org,
                    values: target.values.map(function (d) {
                        return { x: d.x, value: d.value, id: d.id };
                    })
                };
            };
            c3_chart_internal_fn.updateXs = function () {
                var $$ = this;
                if ($$.data.targets.length) {
                    $$.xs = [];
                    $$.data.targets[0].values.forEach(function (v) {
                        $$.xs[v.index] = v.x;
                    });
                }
            };
            c3_chart_internal_fn.getPrevX = function (i) {
                var x = this.xs[i - 1];
                return typeof x !== 'undefined' ? x : null;
            };
            c3_chart_internal_fn.getNextX = function (i) {
                var x = this.xs[i + 1];
                return typeof x !== 'undefined' ? x : null;
            };
            c3_chart_internal_fn.getMaxDataCount = function () {
                var $$ = this;
                return $$.d3.max($$.data.targets, function (t) {
                    return t.values.length;
                });
            };
            c3_chart_internal_fn.getMaxDataCountTarget = function (targets) {
                var length = targets.length,
                    max = 0,
                    maxTarget;
                if (length > 1) {
                    targets.forEach(function (t) {
                        if (t.values.length > max) {
                            maxTarget = t;
                            max = t.values.length;
                        }
                    });
                } else {
                    maxTarget = length ? targets[0] : null;
                }
                return maxTarget;
            };
            c3_chart_internal_fn.getEdgeX = function (targets) {
                var $$ = this;
                return !targets.length ? [0, 0] : [$$.d3.min(targets, function (t) {
                    return t.values[0].x;
                }), $$.d3.max(targets, function (t) {
                    return t.values[t.values.length - 1].x;
                })];
            };
            c3_chart_internal_fn.mapToIds = function (targets) {
                return targets.map(function (d) {
                    return d.id;
                });
            };
            c3_chart_internal_fn.mapToTargetIds = function (ids) {
                var $$ = this;
                return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
            };
            c3_chart_internal_fn.hasTarget = function (targets, id) {
                var ids = this.mapToIds(targets),
                    i;
                for (i = 0; i < ids.length; i++) {
                    if (ids[i] === id) {
                        return true;
                    }
                }
                return false;
            };
            c3_chart_internal_fn.isTargetToShow = function (targetId) {
                return this.hiddenTargetIds.indexOf(targetId) < 0;
            };
            c3_chart_internal_fn.isLegendToShow = function (targetId) {
                return this.hiddenLegendIds.indexOf(targetId) < 0;
            };
            c3_chart_internal_fn.filterTargetsToShow = function (targets) {
                var $$ = this;
                return targets.filter(function (t) {
                    return $$.isTargetToShow(t.id);
                });
            };
            c3_chart_internal_fn.mapTargetsToUniqueXs = function (targets) {
                var $$ = this;
                var xs = $$.d3.set($$.d3.merge(targets.map(function (t) {
                    return t.values.map(function (v) {
                        return +v.x;
                    });
                }))).values();
                xs = $$.isTimeSeries() ? xs.map(function (x) {
                    return new Date(+x);
                }) : xs.map(function (x) {
                    return +x;
                });
                return xs.sort(function (a, b) {
                    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
                });
            };
            c3_chart_internal_fn.addHiddenTargetIds = function (targetIds) {
                this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
            };
            c3_chart_internal_fn.removeHiddenTargetIds = function (targetIds) {
                this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };
            c3_chart_internal_fn.addHiddenLegendIds = function (targetIds) {
                this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
            };
            c3_chart_internal_fn.removeHiddenLegendIds = function (targetIds) {
                this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };
            c3_chart_internal_fn.getValuesAsIdKeyed = function (targets) {
                var ys = {};
                targets.forEach(function (t) {
                    ys[t.id] = [];
                    t.values.forEach(function (v) {
                        ys[t.id].push(v.value);
                    });
                });
                return ys;
            };
            c3_chart_internal_fn.checkValueInTargets = function (targets, checker) {
                var ids = Object.keys(targets),
                    i,
                    j,
                    values;
                for (i = 0; i < ids.length; i++) {
                    values = targets[ids[i]].values;
                    for (j = 0; j < values.length; j++) {
                        if (checker(values[j].value)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            c3_chart_internal_fn.hasNegativeValueInTargets = function (targets) {
                return this.checkValueInTargets(targets, function (v) {
                    return v < 0;
                });
            };
            c3_chart_internal_fn.hasPositiveValueInTargets = function (targets) {
                return this.checkValueInTargets(targets, function (v) {
                    return v > 0;
                });
            };
            c3_chart_internal_fn.isOrderDesc = function () {
                var config = this.config;
                return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc';
            };
            c3_chart_internal_fn.isOrderAsc = function () {
                var config = this.config;
                return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc';
            };
            c3_chart_internal_fn.orderTargets = function (targets) {
                var $$ = this,
                    config = $$.config,
                    orderAsc = $$.isOrderAsc(),
                    orderDesc = $$.isOrderDesc();
                if (orderAsc || orderDesc) {
                    targets.sort(function (t1, t2) {
                        var reducer = function (p, c) {
                            return p + Math.abs(c.value);
                        };
                        var t1Sum = t1.values.reduce(reducer, 0),
                            t2Sum = t2.values.reduce(reducer, 0);
                        return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
                    });
                } else if (isFunction(config.data_order)) {
                    targets.sort(config.data_order);
                } // TODO: accept name array for order
                return targets;
            };
            c3_chart_internal_fn.filterByX = function (targets, x) {
                return this.d3.merge(targets.map(function (t) {
                    return t.values;
                })).filter(function (v) {
                    return v.x - x === 0;
                });
            };
            c3_chart_internal_fn.filterRemoveNull = function (data) {
                return data.filter(function (d) {
                    return isValue(d.value);
                });
            };
            c3_chart_internal_fn.filterByXDomain = function (targets, xDomain) {
                return targets.map(function (t) {
                    return {
                        id: t.id,
                        id_org: t.id_org,
                        values: t.values.filter(function (v) {
                            return xDomain[0] <= v.x && v.x <= xDomain[1];
                        })
                    };
                });
            };
            c3_chart_internal_fn.hasDataLabel = function () {
                var config = this.config;
                if (typeof config.data_labels === 'boolean' && config.data_labels) {
                    return true;
                } else if (typeof config.data_labels === 'object' && notEmpty(config.data_labels)) {
                    return true;
                }
                return false;
            };
            c3_chart_internal_fn.getDataLabelLength = function (min, max, key) {
                var $$ = this,
                    lengths = [0, 0],
                    paddingCoef = 1.3;
                $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function (d) {
                    return $$.dataLabelFormat(d.id)(d);
                }).each(function (d, i) {
                    lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;
                }).remove();
                return lengths;
            };
            c3_chart_internal_fn.isNoneArc = function (d) {
                return this.hasTarget(this.data.targets, d.id);
            }, c3_chart_internal_fn.isArc = function (d) {
                return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
            };
            c3_chart_internal_fn.findSameXOfValues = function (values, index) {
                var i,
                    targetX = values[index].x,
                    sames = [];
                for (i = index - 1; i >= 0; i--) {
                    if (targetX !== values[i].x) {
                        break;
                    }
                    sames.push(values[i]);
                }
                for (i = index; i < values.length; i++) {
                    if (targetX !== values[i].x) {
                        break;
                    }
                    sames.push(values[i]);
                }
                return sames;
            };

            c3_chart_internal_fn.findClosestFromTargets = function (targets, pos) {
                var $$ = this,
                    candidates;

                // map to array of closest points of each target
                candidates = targets.map(function (target) {
                    return $$.findClosest(target.values, pos);
                });

                // decide closest point and return
                return $$.findClosest(candidates, pos);
            };
            c3_chart_internal_fn.findClosest = function (values, pos) {
                var $$ = this,
                    minDist = $$.config.point_sensitivity,
                    closest;

                // find mouseovering bar
                values.filter(function (v) {
                    return v && $$.isBarType(v.id);
                }).forEach(function (v) {
                    var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();
                    if (!closest && $$.isWithinBar(shape)) {
                        closest = v;
                    }
                });

                // find closest point from non-bar
                values.filter(function (v) {
                    return v && !$$.isBarType(v.id);
                }).forEach(function (v) {
                    var d = $$.dist(v, pos);
                    if (d < minDist) {
                        minDist = d;
                        closest = v;
                    }
                });

                return closest;
            };
            c3_chart_internal_fn.dist = function (data, pos) {
                var $$ = this,
                    config = $$.config,
                    xIndex = config.axis_rotated ? 1 : 0,
                    yIndex = config.axis_rotated ? 0 : 1,
                    y = $$.circleY(data, data.index),
                    x = $$.x(data.x);
                return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
            };
            c3_chart_internal_fn.convertValuesToStep = function (values) {
                var converted = [].concat(values),
                    i;

                if (!this.isCategorized()) {
                    return values;
                }

                for (i = values.length + 1; 0 < i; i--) {
                    converted[i] = converted[i - 1];
                }

                converted[0] = {
                    x: converted[0].x - 1,
                    value: converted[0].value,
                    id: converted[0].id
                };
                converted[values.length + 1] = {
                    x: converted[values.length].x + 1,
                    value: converted[values.length].value,
                    id: converted[values.length].id
                };

                return converted;
            };
            c3_chart_internal_fn.updateDataAttributes = function (name, attrs) {
                var $$ = this,
                    config = $$.config,
                    current = config['data_' + name];
                if (typeof attrs === 'undefined') {
                    return current;
                }
                Object.keys(attrs).forEach(function (id) {
                    current[id] = attrs[id];
                });
                $$.redraw({ withLegend: true });
                return current;
            };

            c3_chart_internal_fn.convertUrlToData = function (url, mimeType, headers, keys, done) {
                var $$ = this,
                    type = mimeType ? mimeType : 'csv';
                var req = $$.d3.xhr(url);
                if (headers) {
                    Object.keys(headers).forEach(function (header) {
                        req.header(header, headers[header]);
                    });
                }
                req.get(function (error, data) {
                    var d;
                    if (!data) {
                        throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');
                    }
                    if (type === 'json') {
                        d = $$.convertJsonToData(JSON.parse(data.response), keys);
                    } else if (type === 'tsv') {
                        d = $$.convertTsvToData(data.response);
                    } else {
                        d = $$.convertCsvToData(data.response);
                    }
                    done.call($$, d);
                });
            };
            c3_chart_internal_fn.convertXsvToData = function (xsv, parser) {
                var rows = parser.parseRows(xsv),
                    d;
                if (rows.length === 1) {
                    d = [{}];
                    rows[0].forEach(function (id) {
                        d[0][id] = null;
                    });
                } else {
                    d = parser.parse(xsv);
                }
                return d;
            };
            c3_chart_internal_fn.convertCsvToData = function (csv) {
                return this.convertXsvToData(csv, this.d3.csv);
            };
            c3_chart_internal_fn.convertTsvToData = function (tsv) {
                return this.convertXsvToData(tsv, this.d3.tsv);
            };
            c3_chart_internal_fn.convertJsonToData = function (json, keys) {
                var $$ = this,
                    new_rows = [],
                    targetKeys,
                    data;
                if (keys) {
                    // when keys specified, json would be an array that includes objects
                    if (keys.x) {
                        targetKeys = keys.value.concat(keys.x);
                        $$.config.data_x = keys.x;
                    } else {
                        targetKeys = keys.value;
                    }
                    new_rows.push(targetKeys);
                    json.forEach(function (o) {
                        var new_row = [];
                        targetKeys.forEach(function (key) {
                            // convert undefined to null because undefined data will be removed in convertDataToTargets()
                            var v = $$.findValueInJson(o, key);
                            if (isUndefined(v)) {
                                v = null;
                            }
                            new_row.push(v);
                        });
                        new_rows.push(new_row);
                    });
                    data = $$.convertRowsToData(new_rows);
                } else {
                    Object.keys(json).forEach(function (key) {
                        new_rows.push([key].concat(json[key]));
                    });
                    data = $$.convertColumnsToData(new_rows);
                }
                return data;
            };
            c3_chart_internal_fn.findValueInJson = function (object, path) {
                path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties (replace [] with .)
                path = path.replace(/^\./, ''); // strip a leading dot
                var pathArray = path.split('.');
                for (var i = 0; i < pathArray.length; ++i) {
                    var k = pathArray[i];
                    if (k in object) {
                        object = object[k];
                    } else {
                        return;
                    }
                }
                return object;
            };
            c3_chart_internal_fn.convertRowsToData = function (rows) {
                var keys = rows[0],
                    new_row = {},
                    new_rows = [],
                    i,
                    j;
                for (i = 1; i < rows.length; i++) {
                    new_row = {};
                    for (j = 0; j < rows[i].length; j++) {
                        if (isUndefined(rows[i][j])) {
                            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                        }
                        new_row[keys[j]] = rows[i][j];
                    }
                    new_rows.push(new_row);
                }
                return new_rows;
            };
            c3_chart_internal_fn.convertColumnsToData = function (columns) {
                var new_rows = [],
                    i,
                    j,
                    key;
                for (i = 0; i < columns.length; i++) {
                    key = columns[i][0];
                    for (j = 1; j < columns[i].length; j++) {
                        if (isUndefined(new_rows[j - 1])) {
                            new_rows[j - 1] = {};
                        }
                        if (isUndefined(columns[i][j])) {
                            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                        }
                        new_rows[j - 1][key] = columns[i][j];
                    }
                }
                return new_rows;
            };
            c3_chart_internal_fn.convertDataToTargets = function (data, appendXs) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),
                    xs = $$.d3.keys(data[0]).filter($$.isX, $$),
                    targets;

                // save x for update data by load when custom x and c3.x API
                ids.forEach(function (id) {
                    var xKey = $$.getXKey(id);

                    if ($$.isCustomX() || $$.isTimeSeries()) {
                        // if included in input data
                        if (xs.indexOf(xKey) >= 0) {
                            $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function (d) {
                                return d[xKey];
                            }).filter(isValue).map(function (rawX, i) {
                                return $$.generateTargetX(rawX, id, i);
                            }));
                        }
                        // if not included in input data, find from preloaded data of other id's x
                        else if (config.data_x) {
                                $$.data.xs[id] = $$.getOtherTargetXs();
                            }
                            // if not included in input data, find from preloaded data
                            else if (notEmpty(config.data_xs)) {
                                    $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
                                }
                        // MEMO: if no x included, use same x of current will be used
                    } else {
                        $$.data.xs[id] = data.map(function (d, i) {
                            return i;
                        });
                    }
                });

                // check x is defined
                ids.forEach(function (id) {
                    if (!$$.data.xs[id]) {
                        throw new Error('x is not defined for id = "' + id + '".');
                    }
                });

                // convert to target
                targets = ids.map(function (id, index) {
                    var convertedId = config.data_idConverter(id);
                    return {
                        id: convertedId,
                        id_org: id,
                        values: data.map(function (d, i) {
                            var xKey = $$.getXKey(id),
                                rawX = d[xKey],
                                value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,
                                x;
                            // use x as categories if custom x and categorized
                            if ($$.isCustomX() && $$.isCategorized() && index === 0 && !isUndefined(rawX)) {
                                if (index === 0 && i === 0) {
                                    config.axis_x_categories = [];
                                }
                                x = config.axis_x_categories.indexOf(rawX);
                                if (x === -1) {
                                    x = config.axis_x_categories.length;
                                    config.axis_x_categories.push(rawX);
                                }
                            } else {
                                x = $$.generateTargetX(rawX, id, i);
                            }
                            // mark as x = undefined if value is undefined and filter to remove after mapped
                            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
                                x = undefined;
                            }
                            return { x: x, value: value, id: convertedId };
                        }).filter(function (v) {
                            return isDefined(v.x);
                        })
                    };
                });

                // finish targets
                targets.forEach(function (t) {
                    var i;
                    // sort values by its x
                    if (config.data_xSort) {
                        t.values = t.values.sort(function (v1, v2) {
                            var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
                                x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
                            return x1 - x2;
                        });
                    }
                    // indexing each value
                    i = 0;
                    t.values.forEach(function (v) {
                        v.index = i++;
                    });
                    // this needs to be sorted because its index and value.index is identical
                    $$.data.xs[t.id].sort(function (v1, v2) {
                        return v1 - v2;
                    });
                });

                // cache information about values
                $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
                $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);

                // set target types
                if (config.data_type) {
                    $$.setTargetType($$.mapToIds(targets).filter(function (id) {
                        return !(id in config.data_types);
                    }), config.data_type);
                }

                // cache as original id keyed
                targets.forEach(function (d) {
                    $$.addCache(d.id_org, d);
                });

                return targets;
            };

            c3_chart_internal_fn.load = function (targets, args) {
                var $$ = this;
                if (targets) {
                    // filter loading targets if needed
                    if (args.filter) {
                        targets = targets.filter(args.filter);
                    }
                    // set type if args.types || args.type specified
                    if (args.type || args.types) {
                        targets.forEach(function (t) {
                            var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
                            $$.setTargetType(t.id, type);
                        });
                    }
                    // Update/Add data
                    $$.data.targets.forEach(function (d) {
                        for (var i = 0; i < targets.length; i++) {
                            if (d.id === targets[i].id) {
                                d.values = targets[i].values;
                                targets.splice(i, 1);
                                break;
                            }
                        }
                    });
                    $$.data.targets = $$.data.targets.concat(targets); // add remained
                }

                // Set targets
                $$.updateTargets($$.data.targets);

                // Redraw with new targets
                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });

                if (args.done) {
                    args.done();
                }
            };
            c3_chart_internal_fn.loadFromArgs = function (args) {
                var $$ = this;
                if (args.data) {
                    $$.load($$.convertDataToTargets(args.data), args);
                } else if (args.url) {
                    $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {
                        $$.load($$.convertDataToTargets(data), args);
                    });
                } else if (args.json) {
                    $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
                } else if (args.rows) {
                    $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
                } else if (args.columns) {
                    $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
                } else {
                    $$.load(null, args);
                }
            };
            c3_chart_internal_fn.unload = function (targetIds, done) {
                var $$ = this;
                if (!done) {
                    done = function () {};
                }
                // filter existing target
                targetIds = targetIds.filter(function (id) {
                    return $$.hasTarget($$.data.targets, id);
                });
                // If no target, call done and return
                if (!targetIds || targetIds.length === 0) {
                    done();
                    return;
                }
                $$.svg.selectAll(targetIds.map(function (id) {
                    return $$.selectorTarget(id);
                })).transition().style('opacity', 0).remove().call($$.endall, done);
                targetIds.forEach(function (id) {
                    // Reset fadein for future load
                    $$.withoutFadeIn[id] = false;
                    // Remove target's elements
                    if ($$.legend) {
                        $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();
                    }
                    // Remove target
                    $$.data.targets = $$.data.targets.filter(function (t) {
                        return t.id !== id;
                    });
                });
            };

            c3_chart_internal_fn.categoryName = function (i) {
                var config = this.config;
                return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
            };

            c3_chart_internal_fn.initEventRect = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.eventRects).style('fill-opacity', 0);
            };
            c3_chart_internal_fn.redrawEventRect = function () {
                var $$ = this,
                    config = $$.config,
                    eventRectUpdate,
                    maxDataCountTarget,
                    isMultipleX = $$.isMultipleX();

                // rects for mouseover
                var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX);

                // clear old rects
                eventRects.selectAll('.' + CLASS.eventRect).remove();

                // open as public variable
                $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);

                if (isMultipleX) {
                    eventRectUpdate = $$.eventRect.data([0]);
                    // enter : only one rect will be added
                    $$.generateEventRectsForMultipleXs(eventRectUpdate.enter());
                    // update
                    $$.updateEventRect(eventRectUpdate);
                    // exit : not needed because always only one rect exists
                } else {
                    // Set data and update $$.eventRect
                    maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
                    eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);
                    $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
                    eventRectUpdate = $$.eventRect.data(function (d) {
                        return d;
                    });
                    // enter
                    $$.generateEventRectsForSingleX(eventRectUpdate.enter());
                    // update
                    $$.updateEventRect(eventRectUpdate);
                    // exit
                    eventRectUpdate.exit().remove();
                }
            };
            c3_chart_internal_fn.updateEventRect = function (eventRectUpdate) {
                var $$ = this,
                    config = $$.config,
                    x,
                    y,
                    w,
                    h,
                    rectW,
                    rectX;

                // set update selection if null
                eventRectUpdate = eventRectUpdate || $$.eventRect.data(function (d) {
                    return d;
                });

                if ($$.isMultipleX()) {
                    // TODO: rotated not supported yet
                    x = 0;
                    y = 0;
                    w = $$.width;
                    h = $$.height;
                } else {
                    if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {

                        // update index for x that is used by prevX and nextX
                        $$.updateXs();

                        rectW = function (d) {
                            var prevX = $$.getPrevX(d.index),
                                nextX = $$.getNextX(d.index);

                            // if there this is a single data point make the eventRect full width (or height)
                            if (prevX === null && nextX === null) {
                                return config.axis_rotated ? $$.height : $$.width;
                            }

                            if (prevX === null) {
                                prevX = $$.x.domain()[0];
                            }
                            if (nextX === null) {
                                nextX = $$.x.domain()[1];
                            }

                            return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);
                        };
                        rectX = function (d) {
                            var prevX = $$.getPrevX(d.index),
                                nextX = $$.getNextX(d.index),
                                thisX = $$.data.xs[d.id][d.index];

                            // if there this is a single data point position the eventRect at 0
                            if (prevX === null && nextX === null) {
                                return 0;
                            }

                            if (prevX === null) {
                                prevX = $$.x.domain()[0];
                            }

                            return ($$.x(thisX) + $$.x(prevX)) / 2;
                        };
                    } else {
                        rectW = $$.getEventRectWidth();
                        rectX = function (d) {
                            return $$.x(d.x) - rectW / 2;
                        };
                    }
                    x = config.axis_rotated ? 0 : rectX;
                    y = config.axis_rotated ? rectX : 0;
                    w = config.axis_rotated ? $$.width : rectW;
                    h = config.axis_rotated ? rectW : $$.height;
                }

                eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
            };
            c3_chart_internal_fn.generateEventRectsForSingleX = function (eventRectEnter) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on('mouseover', function (d) {
                    var index = d.index;

                    if ($$.dragging || $$.flowing) {
                        return;
                    } // do nothing while dragging/flowing
                    if ($$.hasArcType()) {
                        return;
                    }

                    // Expand shapes for selection
                    if (config.point_focus_expand_enabled) {
                        $$.expandCircles(index, null, true);
                    }
                    $$.expandBars(index, null, true);

                    // Call event handler
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        config.data_onmouseover.call($$.api, d);
                    });
                }).on('mouseout', function (d) {
                    var index = d.index;
                    if (!$$.config) {
                        return;
                    } // chart is destroyed
                    if ($$.hasArcType()) {
                        return;
                    }
                    $$.hideXGridFocus();
                    $$.hideTooltip();
                    // Undo expanded shapes
                    $$.unexpandCircles();
                    $$.unexpandBars();
                    // Call event handler
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        config.data_onmouseout.call($$.api, d);
                    });
                }).on('mousemove', function (d) {
                    var selectedData,
                        index = d.index,
                        eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);

                    if ($$.dragging || $$.flowing) {
                        return;
                    } // do nothing while dragging/flowing
                    if ($$.hasArcType()) {
                        return;
                    }

                    if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                        index -= 1;
                    }

                    // Show tooltip
                    selectedData = $$.filterTargetsToShow($$.data.targets).map(function (t) {
                        return $$.addName($$.getValueOnIndex(t.values, index));
                    });

                    if (config.tooltip_grouped) {
                        $$.showTooltip(selectedData, this);
                        $$.showXGridFocus(selectedData);
                    }

                    if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {
                        return;
                    }

                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function () {
                        d3.select(this).classed(CLASS.EXPANDED, true);
                        if (config.data_selection_enabled) {
                            eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);
                        }
                        if (!config.tooltip_grouped) {
                            $$.hideXGridFocus();
                            $$.hideTooltip();
                            if (!config.data_selection_grouped) {
                                $$.unexpandCircles(index);
                                $$.unexpandBars(index);
                            }
                        }
                    }).filter(function (d) {
                        return $$.isWithinShape(this, d);
                    }).each(function (d) {
                        if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {
                            eventRect.style('cursor', 'pointer');
                        }
                        if (!config.tooltip_grouped) {
                            $$.showTooltip([d], this);
                            $$.showXGridFocus([d]);
                            if (config.point_focus_expand_enabled) {
                                $$.expandCircles(index, d.id, true);
                            }
                            $$.expandBars(index, d.id, true);
                        }
                    });
                }).on('click', function (d) {
                    var index = d.index;
                    if ($$.hasArcType() || !$$.toggleShape) {
                        return;
                    }
                    if ($$.cancelClick) {
                        $$.cancelClick = false;
                        return;
                    }
                    if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                        index -= 1;
                    }
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        if (config.data_selection_grouped || $$.isWithinShape(this, d)) {
                            $$.toggleShape(this, d, index);
                            $$.config.data_onclick.call($$.api, d, this);
                        }
                    });
                }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
                    $$.drag(d3.mouse(this));
                }).on('dragstart', function () {
                    $$.dragstart(d3.mouse(this));
                }).on('dragend', function () {
                    $$.dragend();
                }) : function () {});
            };

            c3_chart_internal_fn.generateEventRectsForMultipleXs = function (eventRectEnter) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;

                function mouseout() {
                    $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
                    $$.hideXGridFocus();
                    $$.hideTooltip();
                    $$.unexpandCircles();
                    $$.unexpandBars();
                }

                eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function () {
                    if (!$$.config) {
                        return;
                    } // chart is destroyed
                    if ($$.hasArcType()) {
                        return;
                    }
                    mouseout();
                }).on('mousemove', function () {
                    var targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    var mouse, closest, sameXData, selectedData;

                    if ($$.dragging) {
                        return;
                    } // do nothing when dragging
                    if ($$.hasArcType(targetsToShow)) {
                        return;
                    }

                    mouse = d3.mouse(this);
                    closest = $$.findClosestFromTargets(targetsToShow, mouse);

                    if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {
                        config.data_onmouseout.call($$.api, $$.mouseover);
                        $$.mouseover = undefined;
                    }

                    if (!closest) {
                        mouseout();
                        return;
                    }

                    if ($$.isScatterType(closest) || !config.tooltip_grouped) {
                        sameXData = [closest];
                    } else {
                        sameXData = $$.filterByX(targetsToShow, closest.x);
                    }

                    // show tooltip when cursor is close to some point
                    selectedData = sameXData.map(function (d) {
                        return $$.addName(d);
                    });
                    $$.showTooltip(selectedData, this);

                    // expand points
                    if (config.point_focus_expand_enabled) {
                        $$.expandCircles(closest.index, closest.id, true);
                    }
                    $$.expandBars(closest.index, closest.id, true);

                    // Show xgrid focus line
                    $$.showXGridFocus(selectedData);

                    // Show cursor as pointer if point is close to mouse position
                    if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                        $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');
                        if (!$$.mouseover) {
                            config.data_onmouseover.call($$.api, closest);
                            $$.mouseover = closest;
                        }
                    }
                }).on('click', function () {
                    var targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    var mouse, closest;
                    if ($$.hasArcType(targetsToShow)) {
                        return;
                    }

                    mouse = d3.mouse(this);
                    closest = $$.findClosestFromTargets(targetsToShow, mouse);
                    if (!closest) {
                        return;
                    }
                    // select if selection enabled
                    if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                        $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function () {
                            if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {
                                $$.toggleShape(this, closest, closest.index);
                                $$.config.data_onclick.call($$.api, closest, this);
                            }
                        });
                    }
                }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
                    $$.drag(d3.mouse(this));
                }).on('dragstart', function () {
                    $$.dragstart(d3.mouse(this));
                }).on('dragend', function () {
                    $$.dragend();
                }) : function () {});
            };
            c3_chart_internal_fn.dispatchEvent = function (type, index, mouse) {
                var $$ = this,
                    selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),
                    eventRect = $$.main.select(selector).node(),
                    box = eventRect.getBoundingClientRect(),
                    x = box.left + (mouse ? mouse[0] : 0),
                    y = box.top + (mouse ? mouse[1] : 0),
                    event = document.createEvent("MouseEvents");

                event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
                eventRect.dispatchEvent(event);
            };

            c3_chart_internal_fn.getCurrentWidth = function () {
                var $$ = this,
                    config = $$.config;
                return config.size_width ? config.size_width : $$.getParentWidth();
            };
            c3_chart_internal_fn.getCurrentHeight = function () {
                var $$ = this,
                    config = $$.config,
                    h = config.size_height ? config.size_height : $$.getParentHeight();
                return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);
            };
            c3_chart_internal_fn.getCurrentPaddingTop = function () {
                var $$ = this,
                    config = $$.config,
                    padding = isValue(config.padding_top) ? config.padding_top : 0;
                if ($$.title && $$.title.node()) {
                    padding += $$.getTitlePadding();
                }
                return padding;
            };
            c3_chart_internal_fn.getCurrentPaddingBottom = function () {
                var config = this.config;
                return isValue(config.padding_bottom) ? config.padding_bottom : 0;
            };
            c3_chart_internal_fn.getCurrentPaddingLeft = function (withoutRecompute) {
                var $$ = this,
                    config = $$.config;
                if (isValue(config.padding_left)) {
                    return config.padding_left;
                } else if (config.axis_rotated) {
                    return !config.axis_x_show ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
                } else if (!config.axis_y_show || config.axis_y_inner) {
                    // && !config.axis_rotated
                    return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
                } else {
                    return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
                }
            };
            c3_chart_internal_fn.getCurrentPaddingRight = function () {
                var $$ = this,
                    config = $$.config,
                    defaultPadding = 10,
                    legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
                if (isValue(config.padding_right)) {
                    return config.padding_right + 1; // 1 is needed not to hide tick line
                } else if (config.axis_rotated) {
                    return defaultPadding + legendWidthOnRight;
                } else if (!config.axis_y2_show || config.axis_y2_inner) {
                    // && !config.axis_rotated
                    return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
                } else {
                    return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
                }
            };

            c3_chart_internal_fn.getParentRectValue = function (key) {
                var parent = this.selectChart.node(),
                    v;
                while (parent && parent.tagName !== 'BODY') {
                    try {
                        v = parent.getBoundingClientRect()[key];
                    } catch (e) {
                        if (key === 'width') {
                            // In IE in certain cases getBoundingClientRect
                            // will cause an "unspecified error"
                            v = parent.offsetWidth;
                        }
                    }
                    if (v) {
                        break;
                    }
                    parent = parent.parentNode;
                }
                return v;
            };
            c3_chart_internal_fn.getParentWidth = function () {
                return this.getParentRectValue('width');
            };
            c3_chart_internal_fn.getParentHeight = function () {
                var h = this.selectChart.style('height');
                return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
            };

            c3_chart_internal_fn.getSvgLeft = function (withoutRecompute) {
                var $$ = this,
                    config = $$.config,
                    hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
                    leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,
                    leftAxis = $$.main.select('.' + leftAxisClass).node(),
                    svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : { right: 0 },
                    chartRect = $$.selectChart.node().getBoundingClientRect(),
                    hasArc = $$.hasArcType(),
                    svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
                return svgLeft > 0 ? svgLeft : 0;
            };

            c3_chart_internal_fn.getAxisWidthByAxisId = function (id, withoutRecompute) {
                var $$ = this,
                    position = $$.axis.getLabelPositionById(id);
                return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
            };
            c3_chart_internal_fn.getHorizontalAxisHeight = function (axisId) {
                var $$ = this,
                    config = $$.config,
                    h = 30;
                if (axisId === 'x' && !config.axis_x_show) {
                    return 8;
                }
                if (axisId === 'x' && config.axis_x_height) {
                    return config.axis_x_height;
                }
                if (axisId === 'y' && !config.axis_y_show) {
                    return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
                }
                if (axisId === 'y2' && !config.axis_y2_show) {
                    return $$.rotated_padding_top;
                }
                // Calculate x axis height when tick rotated
                if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
                    h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);
                }
                // Calculate y axis height when tick rotated
                if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {
                    h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_y_tick_rotate) / 180);
                }
                return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);
            };

            c3_chart_internal_fn.getEventRectWidth = function () {
                return Math.max(0, this.xAxis.tickInterval());
            };

            c3_chart_internal_fn.getShapeIndices = function (typeFilter) {
                var $$ = this,
                    config = $$.config,
                    indices = {},
                    i = 0,
                    j,
                    k;
                $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
                    for (j = 0; j < config.data_groups.length; j++) {
                        if (config.data_groups[j].indexOf(d.id) < 0) {
                            continue;
                        }
                        for (k = 0; k < config.data_groups[j].length; k++) {
                            if (config.data_groups[j][k] in indices) {
                                indices[d.id] = indices[config.data_groups[j][k]];
                                break;
                            }
                        }
                    }
                    if (isUndefined(indices[d.id])) {
                        indices[d.id] = i++;
                    }
                });
                indices.__max__ = i - 1;
                return indices;
            };
            c3_chart_internal_fn.getShapeX = function (offset, targetsNum, indices, isSub) {
                var $$ = this,
                    scale = isSub ? $$.subX : $$.x;
                return function (d) {
                    var index = d.id in indices ? indices[d.id] : 0;
                    return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
                };
            };
            c3_chart_internal_fn.getShapeY = function (isSub) {
                var $$ = this;
                return function (d) {
                    var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
                    return scale(d.value);
                };
            };
            c3_chart_internal_fn.getShapeOffset = function (typeFilter, indices, isSub) {
                var $$ = this,
                    targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
                    targetIds = targets.map(function (t) {
                    return t.id;
                });
                return function (d, i) {
                    var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
                        y0 = scale(0),
                        offset = y0;
                    targets.forEach(function (t) {
                        var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;
                        if (t.id === d.id || indices[t.id] !== indices[d.id]) {
                            return;
                        }
                        if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
                            // check if the x values line up
                            if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {
                                // "+" for timeseries
                                // if not, try to find the value that does line up
                                i = -1;
                                values.forEach(function (v, j) {
                                    if (v.x === d.x) {
                                        i = j;
                                    }
                                });
                            }
                            if (i in values && values[i].value * d.value >= 0) {
                                offset += scale(values[i].value) - y0;
                            }
                        }
                    });
                    return offset;
                };
            };
            c3_chart_internal_fn.isWithinShape = function (that, d) {
                var $$ = this,
                    shape = $$.d3.select(that),
                    isWithin;
                if (!$$.isTargetToShow(d.id)) {
                    isWithin = false;
                } else if (that.nodeName === 'circle') {
                    isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
                } else if (that.nodeName === 'path') {
                    isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;
                }
                return isWithin;
            };

            c3_chart_internal_fn.getInterpolate = function (d) {
                var $$ = this,
                    interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : 'cardinal';
                return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
            };

            c3_chart_internal_fn.initLine = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
            };
            c3_chart_internal_fn.updateTargetsForLine = function (targets) {
                var $$ = this,
                    config = $$.config,
                    mainLineUpdate,
                    mainLineEnter,
                    classChartLine = $$.classChartLine.bind($$),
                    classLines = $$.classLines.bind($$),
                    classAreas = $$.classAreas.bind($$),
                    classCircles = $$.classCircles.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function (d) {
                    return classChartLine(d) + classFocus(d);
                });
                mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style("pointer-events", "none");
                // Lines for each data
                mainLineEnter.append('g').attr("class", classLines);
                // Areas
                mainLineEnter.append('g').attr('class', classAreas);
                // Circles for each data point on lines
                mainLineEnter.append('g').attr("class", function (d) {
                    return $$.generateClass(CLASS.selectedCircles, d.id);
                });
                mainLineEnter.append('g').attr("class", classCircles).style("cursor", function (d) {
                    return config.data_selection_isselectable(d) ? "pointer" : null;
                });
                // Update date for selected circles
                targets.forEach(function (t) {
                    $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function (d) {
                        d.value = t.values[d.index].value;
                    });
                });
                // MEMO: can not keep same color...
                //mainLineUpdate.exit().remove();
            };
            c3_chart_internal_fn.updateLine = function (durationForExit) {
                var $$ = this;
                $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
                $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style("stroke", $$.color);
                $$.mainLine.style("opacity", $$.initialOpacity.bind($$)).style('shape-rendering', function (d) {
                    return $$.isStepType(d) ? 'crispEdges' : '';
                }).attr('transform', null);
                $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawLine = function (drawLine, withTransition) {
                return [(withTransition ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", 1)];
            };
            c3_chart_internal_fn.generateDrawLine = function (lineIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    line = $$.d3.svg.line(),
                    getPoints = $$.generateGetLinePoints(lineIndices, isSub),
                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                    xValue = function (d) {
                    return (isSub ? $$.subxx : $$.xx).call($$, d);
                },
                    yValue = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
                };

                line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
                if (!config.line_connectNull) {
                    line = line.defined(function (d) {
                        return d.value != null;
                    });
                }
                return function (d) {
                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                        x = isSub ? $$.x : $$.subX,
                        y = yScaleGetter.call($$, d.id),
                        x0 = 0,
                        y0 = 0,
                        path;
                    if ($$.isLineType(d)) {
                        if (config.data_regions[d.id]) {
                            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                        } else {
                            if ($$.isStepType(d)) {
                                values = $$.convertValuesToStep(values);
                            }
                            path = line.interpolate($$.getInterpolate(d))(values);
                        }
                    } else {
                        if (values[0]) {
                            x0 = x(values[0].x);
                            y0 = y(values[0].value);
                        }
                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                    }
                    return path ? path : "M 0 0";
                };
            };
            c3_chart_internal_fn.generateGetLinePoints = function (lineIndices, isSub) {
                // partial duplication of generateGetBarPoints
                var $$ = this,
                    config = $$.config,
                    lineTargetsNum = lineIndices.__max__ + 1,
                    x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),
                    y = $$.getShapeY(!!isSub),
                    lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = lineOffset(d, i) || y0,
                        // offset is for stacked area chart
                    posX = x(d),
                        posY = y(d);
                    // fix posY not to overflow opposite quadrant
                    if (config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 1 point that marks the line position
                    return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, posY - (y0 - offset)] // needed for compatibility
                    ];
                };
            };

            c3_chart_internal_fn.lineWithRegions = function (d, x, y, _regions) {
                var $$ = this,
                    config = $$.config,
                    prev = -1,
                    i,
                    j,
                    s = "M",
                    sWithRegion,
                    xp,
                    yp,
                    dx,
                    dy,
                    dd,
                    diff,
                    diffx2,
                    xOffset = $$.isCategorized() ? 0.5 : 0,
                    xValue,
                    yValue,
                    regions = [];

                function isWithinRegions(x, regions) {
                    var i;
                    for (i = 0; i < regions.length; i++) {
                        if (regions[i].start < x && x <= regions[i].end) {
                            return true;
                        }
                    }
                    return false;
                }

                // Check start/end of regions
                if (isDefined(_regions)) {
                    for (i = 0; i < _regions.length; i++) {
                        regions[i] = {};
                        if (isUndefined(_regions[i].start)) {
                            regions[i].start = d[0].x;
                        } else {
                            regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;
                        }
                        if (isUndefined(_regions[i].end)) {
                            regions[i].end = d[d.length - 1].x;
                        } else {
                            regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;
                        }
                    }
                }

                // Set scales
                xValue = config.axis_rotated ? function (d) {
                    return y(d.value);
                } : function (d) {
                    return x(d.x);
                };
                yValue = config.axis_rotated ? function (d) {
                    return x(d.x);
                } : function (d) {
                    return y(d.value);
                };

                // Define svg generator function for region
                function generateM(points) {
                    return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];
                }
                if ($$.isTimeSeries()) {
                    sWithRegion = function (d0, d1, j, diff) {
                        var x0 = d0.x.getTime(),
                            x_diff = d1.x - d0.x,
                            xv0 = new Date(x0 + x_diff * j),
                            xv1 = new Date(x0 + x_diff * (j + diff)),
                            points;
                        if (config.axis_rotated) {
                            points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];
                        } else {
                            points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];
                        }
                        return generateM(points);
                    };
                } else {
                    sWithRegion = function (d0, d1, j, diff) {
                        var points;
                        if (config.axis_rotated) {
                            points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];
                        } else {
                            points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];
                        }
                        return generateM(points);
                    };
                }

                // Generate
                for (i = 0; i < d.length; i++) {

                    // Draw as normal
                    if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
                        s += " " + xValue(d[i]) + " " + yValue(d[i]);
                    }
                    // Draw with region // TODO: Fix for horizotal charts
                    else {
                            xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
                            yp = $$.getScale(d[i - 1].value, d[i].value);

                            dx = x(d[i].x) - x(d[i - 1].x);
                            dy = y(d[i].value) - y(d[i - 1].value);
                            dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                            diff = 2 / dd;
                            diffx2 = diff * 2;

                            for (j = diff; j <= 1; j += diffx2) {
                                s += sWithRegion(d[i - 1], d[i], j, diff);
                            }
                        }
                    prev = d[i].x;
                }

                return s;
            };

            c3_chart_internal_fn.updateArea = function (durationForExit) {
                var $$ = this,
                    d3 = $$.d3;
                $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
                $$.mainArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
                    $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
                });
                $$.mainArea.style("opacity", $$.orgAreaOpacity);
                $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawArea = function (drawArea, withTransition) {
                return [(withTransition ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", this.orgAreaOpacity)];
            };
            c3_chart_internal_fn.generateDrawArea = function (areaIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    area = $$.d3.svg.area(),
                    getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                    xValue = function (d) {
                    return (isSub ? $$.subxx : $$.xx).call($$, d);
                },
                    value0 = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
                },
                    value1 = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
                };

                area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1);
                if (!config.line_connectNull) {
                    area = area.defined(function (d) {
                        return d.value !== null;
                    });
                }

                return function (d) {
                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                        x0 = 0,
                        y0 = 0,
                        path;
                    if ($$.isAreaType(d)) {
                        if ($$.isStepType(d)) {
                            values = $$.convertValuesToStep(values);
                        }
                        path = area.interpolate($$.getInterpolate(d))(values);
                    } else {
                        if (values[0]) {
                            x0 = $$.x(values[0].x);
                            y0 = $$.getYScale(d.id)(values[0].value);
                        }
                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                    }
                    return path ? path : "M 0 0";
                };
            };
            c3_chart_internal_fn.getAreaBaseValue = function () {
                return 0;
            };
            c3_chart_internal_fn.generateGetAreaPoints = function (areaIndices, isSub) {
                // partial duplication of generateGetBarPoints
                var $$ = this,
                    config = $$.config,
                    areaTargetsNum = areaIndices.__max__ + 1,
                    x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
                    y = $$.getShapeY(!!isSub),
                    areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = areaOffset(d, i) || y0,
                        // offset is for stacked area chart
                    posX = x(d),
                        posY = y(d);
                    // fix posY not to overflow opposite quadrant
                    if (config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 1 point that marks the area position
                    return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, offset] // needed for compatibility
                    ];
                };
            };

            c3_chart_internal_fn.updateCircle = function () {
                var $$ = this;
                $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));
                $$.mainCircle.enter().append("circle").attr("class", $$.classCircle.bind($$)).attr("r", $$.pointR.bind($$)).style("fill", $$.color);
                $$.mainCircle.style("opacity", $$.initialOpacityForCircle.bind($$));
                $$.mainCircle.exit().remove();
            };
            c3_chart_internal_fn.redrawCircle = function (cx, cy, withTransition) {
                var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);
                return [(withTransition ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style("fill", this.color).attr("cx", cx).attr("cy", cy), (withTransition ? selectedCircles.transition(Math.random().toString()) : selectedCircles).attr("cx", cx).attr("cy", cy)];
            };
            c3_chart_internal_fn.circleX = function (d) {
                return d.x || d.x === 0 ? this.x(d.x) : null;
            };
            c3_chart_internal_fn.updateCircleY = function () {
                var $$ = this,
                    lineIndices,
                    getPoints;
                if ($$.config.data_groups.length > 0) {
                    lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);
                    $$.circleY = function (d, i) {
                        return getPoints(d, i)[0][1];
                    };
                } else {
                    $$.circleY = function (d) {
                        return $$.getYScale(d.id)(d.value);
                    };
                }
            };
            c3_chart_internal_fn.getCircles = function (i, id) {
                var $$ = this;
                return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
            };
            c3_chart_internal_fn.expandCircles = function (i, id, reset) {
                var $$ = this,
                    r = $$.pointExpandedR.bind($$);
                if (reset) {
                    $$.unexpandCircles();
                }
                $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);
            };
            c3_chart_internal_fn.unexpandCircles = function (i) {
                var $$ = this,
                    r = $$.pointR.bind($$);
                $$.getCircles(i).filter(function () {
                    return $$.d3.select(this).classed(CLASS.EXPANDED);
                }).classed(CLASS.EXPANDED, false).attr('r', r);
            };
            c3_chart_internal_fn.pointR = function (d) {
                var $$ = this,
                    config = $$.config;
                return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r;
            };
            c3_chart_internal_fn.pointExpandedR = function (d) {
                var $$ = this,
                    config = $$.config;
                return config.point_focus_expand_enabled ? config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75 : $$.pointR(d);
            };
            c3_chart_internal_fn.pointSelectR = function (d) {
                var $$ = this,
                    config = $$.config;
                return isFunction(config.point_select_r) ? config.point_select_r(d) : config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;
            };
            c3_chart_internal_fn.isWithinCircle = function (that, r) {
                var d3 = this.d3,
                    mouse = d3.mouse(that),
                    d3_this = d3.select(that),
                    cx = +d3_this.attr("cx"),
                    cy = +d3_this.attr("cy");
                return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
            };
            c3_chart_internal_fn.isWithinStep = function (that, y) {
                return Math.abs(y - this.d3.mouse(that)[1]) < 30;
            };

            c3_chart_internal_fn.initBar = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
            };
            c3_chart_internal_fn.updateTargetsForBar = function (targets) {
                var $$ = this,
                    config = $$.config,
                    mainBarUpdate,
                    mainBarEnter,
                    classChartBar = $$.classChartBar.bind($$),
                    classBars = $$.classBars.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function (d) {
                    return classChartBar(d) + classFocus(d);
                });
                mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style('opacity', 0).style("pointer-events", "none");
                // Bars for each data
                mainBarEnter.append('g').attr("class", classBars).style("cursor", function (d) {
                    return config.data_selection_isselectable(d) ? "pointer" : null;
                });
            };
            c3_chart_internal_fn.updateBar = function (durationForExit) {
                var $$ = this,
                    barData = $$.barData.bind($$),
                    classBar = $$.classBar.bind($$),
                    initialOpacity = $$.initialOpacity.bind($$),
                    color = function (d) {
                    return $$.color(d.id);
                };
                $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);
                $$.mainBar.enter().append('path').attr("class", classBar).style("stroke", color).style("fill", color);
                $$.mainBar.style("opacity", initialOpacity);
                $$.mainBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawBar = function (drawBar, withTransition) {
                return [(withTransition ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr('d', drawBar).style("fill", this.color).style("opacity", 1)];
            };
            c3_chart_internal_fn.getBarW = function (axis, barTargetsNum) {
                var $$ = this,
                    config = $$.config,
                    w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? axis.tickInterval() * config.bar_width_ratio / barTargetsNum : 0;
                return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
            };
            c3_chart_internal_fn.getBars = function (i, id) {
                var $$ = this;
                return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
            };
            c3_chart_internal_fn.expandBars = function (i, id, reset) {
                var $$ = this;
                if (reset) {
                    $$.unexpandBars();
                }
                $$.getBars(i, id).classed(CLASS.EXPANDED, true);
            };
            c3_chart_internal_fn.unexpandBars = function (i) {
                var $$ = this;
                $$.getBars(i).classed(CLASS.EXPANDED, false);
            };
            c3_chart_internal_fn.generateDrawBar = function (barIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    getPoints = $$.generateGetBarPoints(barIndices, isSub);
                return function (d, i) {
                    // 4 points that make a bar
                    var points = getPoints(d, i);

                    // switch points if axis is rotated, not applicable for sub chart
                    var indexX = config.axis_rotated ? 1 : 0;
                    var indexY = config.axis_rotated ? 0 : 1;

                    var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';

                    return path;
                };
            };
            c3_chart_internal_fn.generateGetBarPoints = function (barIndices, isSub) {
                var $$ = this,
                    axis = isSub ? $$.subXAxis : $$.xAxis,
                    barTargetsNum = barIndices.__max__ + 1,
                    barW = $$.getBarW(axis, barTargetsNum),
                    barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
                    barY = $$.getShapeY(!!isSub),
                    barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = barOffset(d, i) || y0,
                        // offset is for stacked bar chart
                    posX = barX(d),
                        posY = barY(d);
                    // fix posY not to overflow opposite quadrant
                    if ($$.config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 4 points that make a bar
                    return [[posX, offset], [posX, posY - (y0 - offset)], [posX + barW, posY - (y0 - offset)], [posX + barW, offset]];
                };
            };
            c3_chart_internal_fn.isWithinBar = function (that) {
                var mouse = this.d3.mouse(that),
                    box = that.getBoundingClientRect(),
                    seg0 = that.pathSegList.getItem(0),
                    seg1 = that.pathSegList.getItem(1),
                    x = Math.min(seg0.x, seg1.x),
                    y = Math.min(seg0.y, seg1.y),
                    w = box.width,
                    h = box.height,
                    offset = 2,
                    sx = x - offset,
                    ex = x + w + offset,
                    sy = y + h + offset,
                    ey = y - offset;
                return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;
            };

            c3_chart_internal_fn.initText = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartTexts);
                $$.mainText = $$.d3.selectAll([]);
            };
            c3_chart_internal_fn.updateTargetsForText = function (targets) {
                var $$ = this,
                    mainTextUpdate,
                    mainTextEnter,
                    classChartText = $$.classChartText.bind($$),
                    classTexts = $$.classTexts.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function (d) {
                    return classChartText(d) + classFocus(d);
                });
                mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style("pointer-events", "none");
                mainTextEnter.append('g').attr('class', classTexts);
            };
            c3_chart_internal_fn.updateText = function (durationForExit) {
                var $$ = this,
                    config = $$.config,
                    barOrLineData = $$.barOrLineData.bind($$),
                    classText = $$.classText.bind($$);
                $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);
                $$.mainText.enter().append('text').attr("class", classText).attr('text-anchor', function (d) {
                    return config.axis_rotated ? d.value < 0 ? 'end' : 'start' : 'middle';
                }).style("stroke", 'none').style("fill", function (d) {
                    return $$.color(d);
                }).style("fill-opacity", 0);
                $$.mainText.text(function (d, i, j) {
                    return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
                });
                $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawText = function (xForText, yForText, forFlow, withTransition) {
                return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
            };
            c3_chart_internal_fn.getTextRect = function (text, cls, element) {
                var dummy = this.d3.select('body').append('div').classed('c3', true),
                    svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),
                    font = this.d3.select(element).style('font'),
                    rect;
                svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : "", true).style('font', font).text(text).each(function () {
                    rect = this.getBoundingClientRect();
                });
                dummy.remove();
                return rect;
            };
            c3_chart_internal_fn.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {
                var $$ = this,
                    getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),
                    getBarPoints = $$.generateGetBarPoints(barIndices, false),
                    getLinePoints = $$.generateGetLinePoints(lineIndices, false),
                    getter = forX ? $$.getXForText : $$.getYForText;
                return function (d, i) {
                    var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;
                    return getter.call($$, getPoints(d, i), d, this);
                };
            };
            c3_chart_internal_fn.getXForText = function (points, d, textElement) {
                var $$ = this,
                    box = textElement.getBoundingClientRect(),
                    xPos,
                    padding;
                if ($$.config.axis_rotated) {
                    padding = $$.isBarType(d) ? 4 : 6;
                    xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
                } else {
                    xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
                }
                // show labels regardless of the domain if value is null
                if (d.value === null) {
                    if (xPos > $$.width) {
                        xPos = $$.width - box.width;
                    } else if (xPos < 0) {
                        xPos = 4;
                    }
                }
                return xPos;
            };
            c3_chart_internal_fn.getYForText = function (points, d, textElement) {
                var $$ = this,
                    box = textElement.getBoundingClientRect(),
                    yPos;
                if ($$.config.axis_rotated) {
                    yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
                } else {
                    yPos = points[2][1];
                    if (d.value < 0 || d.value === 0 && !$$.hasPositiveValue) {
                        yPos += box.height;
                        if ($$.isBarType(d) && $$.isSafari()) {
                            yPos -= 3;
                        } else if (!$$.isBarType(d) && $$.isChrome()) {
                            yPos += 3;
                        }
                    } else {
                        yPos += $$.isBarType(d) ? -3 : -6;
                    }
                }
                // show labels regardless of the domain if value is null
                if (d.value === null && !$$.config.axis_rotated) {
                    if (yPos < box.height) {
                        yPos = box.height;
                    } else if (yPos > this.height) {
                        yPos = this.height - 4;
                    }
                }
                return yPos;
            };

            c3_chart_internal_fn.setTargetType = function (targetIds, type) {
                var $$ = this,
                    config = $$.config;
                $$.mapToTargetIds(targetIds).forEach(function (id) {
                    $$.withoutFadeIn[id] = type === config.data_types[id];
                    config.data_types[id] = type;
                });
                if (!targetIds) {
                    config.data_type = type;
                }
            };
            c3_chart_internal_fn.hasType = function (type, targets) {
                var $$ = this,
                    types = $$.config.data_types,
                    has = false;
                targets = targets || $$.data.targets;
                if (targets && targets.length) {
                    targets.forEach(function (target) {
                        var t = types[target.id];
                        if (t && t.indexOf(type) >= 0 || !t && type === 'line') {
                            has = true;
                        }
                    });
                } else if (Object.keys(types).length) {
                    Object.keys(types).forEach(function (id) {
                        if (types[id] === type) {
                            has = true;
                        }
                    });
                } else {
                    has = $$.config.data_type === type;
                }
                return has;
            };
            c3_chart_internal_fn.hasArcType = function (targets) {
                return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);
            };
            c3_chart_internal_fn.isLineType = function (d) {
                var config = this.config,
                    id = isString(d) ? d : d.id;
                return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isStepType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isSplineType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isAreaType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isBarType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'bar';
            };
            c3_chart_internal_fn.isScatterType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'scatter';
            };
            c3_chart_internal_fn.isPieType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'pie';
            };
            c3_chart_internal_fn.isGaugeType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'gauge';
            };
            c3_chart_internal_fn.isDonutType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'donut';
            };
            c3_chart_internal_fn.isArcType = function (d) {
                return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
            };
            c3_chart_internal_fn.lineData = function (d) {
                return this.isLineType(d) ? [d] : [];
            };
            c3_chart_internal_fn.arcData = function (d) {
                return this.isArcType(d.data) ? [d] : [];
            };
            /* not used
             function scatterData(d) {
             return isScatterType(d) ? d.values : [];
             }
             */
            c3_chart_internal_fn.barData = function (d) {
                return this.isBarType(d) ? d.values : [];
            };
            c3_chart_internal_fn.lineOrScatterData = function (d) {
                return this.isLineType(d) || this.isScatterType(d) ? d.values : [];
            };
            c3_chart_internal_fn.barOrLineData = function (d) {
                return this.isBarType(d) || this.isLineType(d) ? d.values : [];
            };
            c3_chart_internal_fn.isInterpolationType = function (type) {
                return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(type) >= 0;
            };

            c3_chart_internal_fn.initGrid = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;
                $$.grid = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid);
                if (config.grid_x_show) {
                    $$.grid.append("g").attr("class", CLASS.xgrids);
                }
                if (config.grid_y_show) {
                    $$.grid.append('g').attr('class', CLASS.ygrids);
                }
                if (config.grid_focus_show) {
                    $$.grid.append('g').attr("class", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);
                }
                $$.xgrid = d3.selectAll([]);
                if (!config.grid_lines_front) {
                    $$.initGridLines();
                }
            };
            c3_chart_internal_fn.initGridLines = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.gridLines = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);
                $$.gridLines.append('g').attr("class", CLASS.xgridLines);
                $$.gridLines.append('g').attr('class', CLASS.ygridLines);
                $$.xgridLines = d3.selectAll([]);
            };
            c3_chart_internal_fn.updateXGrid = function (withoutUpdate) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    xgridData = $$.generateGridData(config.grid_x_type, $$.x),
                    tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;

                $$.xgridAttr = config.axis_rotated ? {
                    'x1': 0,
                    'x2': $$.width,
                    'y1': function (d) {
                        return $$.x(d) - tickOffset;
                    },
                    'y2': function (d) {
                        return $$.x(d) - tickOffset;
                    }
                } : {
                    'x1': function (d) {
                        return $$.x(d) + tickOffset;
                    },
                    'x2': function (d) {
                        return $$.x(d) + tickOffset;
                    },
                    'y1': 0,
                    'y2': $$.height
                };

                $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);
                $$.xgrid.enter().append('line').attr("class", CLASS.xgrid);
                if (!withoutUpdate) {
                    $$.xgrid.attr($$.xgridAttr).style("opacity", function () {
                        return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
                    });
                }
                $$.xgrid.exit().remove();
            };

            c3_chart_internal_fn.updateYGrid = function () {
                var $$ = this,
                    config = $$.config,
                    gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
                $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);
                $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);
                $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y);
                $$.ygrid.exit().remove();
                $$.smoothLines($$.ygrid, 'grid');
            };

            c3_chart_internal_fn.gridTextAnchor = function (d) {
                return d.position ? d.position : "end";
            };
            c3_chart_internal_fn.gridTextDx = function (d) {
                return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
            };
            c3_chart_internal_fn.xGridTextX = function (d) {
                return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;
            };
            c3_chart_internal_fn.yGridTextX = function (d) {
                return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;
            };
            c3_chart_internal_fn.updateGrid = function (duration) {
                var $$ = this,
                    main = $$.main,
                    config = $$.config,
                    xgridLine,
                    ygridLine,
                    yv;

                // hide if arc type
                $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

                main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
                if (config.grid_x_show) {
                    $$.updateXGrid();
                }
                $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines);
                // enter
                xgridLine = $$.xgridLines.enter().append('g').attr("class", function (d) {
                    return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
                });
                xgridLine.append('line').style("opacity", 0);
                xgridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
                // udpate
                // done in d3.transition() of the end of this function
                // exit
                $$.xgridLines.exit().transition().duration(duration).style("opacity", 0).remove();

                // Y-Grid
                if (config.grid_y_show) {
                    $$.updateYGrid();
                }
                $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines);
                // enter
                ygridLine = $$.ygridLines.enter().append('g').attr("class", function (d) {
                    return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
                });
                ygridLine.append('line').style("opacity", 0);
                ygridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
                // update
                yv = $$.yv.bind($$);
                $$.ygridLines.select('line').transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).style("opacity", 1);
                $$.ygridLines.select('text').transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function (d) {
                    return d.text;
                }).style("opacity", 1);
                // exit
                $$.ygridLines.exit().transition().duration(duration).style("opacity", 0).remove();
            };
            c3_chart_internal_fn.redrawGrid = function (withTransition) {
                var $$ = this,
                    config = $$.config,
                    xv = $$.xv.bind($$),
                    lines = $$.xgridLines.select('line'),
                    texts = $$.xgridLines.select('text');
                return [(withTransition ? lines.transition() : lines).attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv).attr("y1", config.axis_rotated ? xv : 0).attr("y2", config.axis_rotated ? xv : $$.height).style("opacity", 1), (withTransition ? texts.transition() : texts).attr("x", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function (d) {
                    return d.text;
                }).style("opacity", 1)];
            };
            c3_chart_internal_fn.showXGridFocus = function (selectedData) {
                var $$ = this,
                    config = $$.config,
                    dataToShow = selectedData.filter(function (d) {
                    return d && isValue(d.value);
                }),
                    focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),
                    xx = $$.xx.bind($$);
                if (!config.tooltip_show) {
                    return;
                }
                // Hide when scatter plot exists
                if ($$.hasType('scatter') || $$.hasArcType()) {
                    return;
                }
                focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);
                $$.smoothLines(focusEl, 'grid');
            };
            c3_chart_internal_fn.hideXGridFocus = function () {
                this.main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
            };
            c3_chart_internal_fn.updateXgridFocus = function () {
                var $$ = this,
                    config = $$.config;
                $$.main.select('line.' + CLASS.xgridFocus).attr("x1", config.axis_rotated ? 0 : -10).attr("x2", config.axis_rotated ? $$.width : -10).attr("y1", config.axis_rotated ? -10 : 0).attr("y2", config.axis_rotated ? -10 : $$.height);
            };
            c3_chart_internal_fn.generateGridData = function (type, scale) {
                var $$ = this,
                    gridData = [],
                    xDomain,
                    firstYear,
                    lastYear,
                    i,
                    tickNum = $$.main.select("." + CLASS.axisX).selectAll('.tick').size();
                if (type === 'year') {
                    xDomain = $$.getXDomain();
                    firstYear = xDomain[0].getFullYear();
                    lastYear = xDomain[1].getFullYear();
                    for (i = firstYear; i <= lastYear; i++) {
                        gridData.push(new Date(i + '-01-01 00:00:00'));
                    }
                } else {
                    gridData = scale.ticks(10);
                    if (gridData.length > tickNum) {
                        // use only int
                        gridData = gridData.filter(function (d) {
                            return ("" + d).indexOf('.') < 0;
                        });
                    }
                }
                return gridData;
            };
            c3_chart_internal_fn.getGridFilterToRemove = function (params) {
                return params ? function (line) {
                    var found = false;
                    [].concat(params).forEach(function (param) {
                        if ('value' in param && line.value === param.value || 'class' in param && line['class'] === param['class']) {
                            found = true;
                        }
                    });
                    return found;
                } : function () {
                    return true;
                };
            };
            c3_chart_internal_fn.removeGridLines = function (params, forX) {
                var $$ = this,
                    config = $$.config,
                    toRemove = $$.getGridFilterToRemove(params),
                    toShow = function (line) {
                    return !toRemove(line);
                },
                    classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,
                    classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
                $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();
                if (forX) {
                    config.grid_x_lines = config.grid_x_lines.filter(toShow);
                } else {
                    config.grid_y_lines = config.grid_y_lines.filter(toShow);
                }
            };

            c3_chart_internal_fn.initTooltip = function () {
                var $$ = this,
                    config = $$.config,
                    i;
                $$.tooltip = $$.selectChart.style("position", "relative").append("div").attr('class', CLASS.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none");
                // Show tooltip if needed
                if (config.tooltip_init_show) {
                    if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
                        config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
                        for (i = 0; i < $$.data.targets[0].values.length; i++) {
                            if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {
                                break;
                            }
                        }
                        config.tooltip_init_x = i;
                    }
                    $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
                        return $$.addName(d.values[config.tooltip_init_x]);
                    }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
                    $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
                }
            };
            c3_chart_internal_fn.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {
                var $$ = this,
                    config = $$.config,
                    titleFormat = config.tooltip_format_title || defaultTitleFormat,
                    nameFormat = config.tooltip_format_name || function (name) {
                    return name;
                },
                    valueFormat = config.tooltip_format_value || defaultValueFormat,
                    text,
                    i,
                    title,
                    value,
                    name,
                    bgcolor,
                    orderAsc = $$.isOrderAsc();

                if (config.data_groups.length === 0) {
                    d.sort(function (a, b) {
                        var v1 = a ? a.value : null,
                            v2 = b ? b.value : null;
                        return orderAsc ? v1 - v2 : v2 - v1;
                    });
                } else {
                    var ids = $$.orderTargets($$.data.targets).map(function (i) {
                        return i.id;
                    });
                    d.sort(function (a, b) {
                        var v1 = a ? a.value : null,
                            v2 = b ? b.value : null;
                        if (v1 > 0 && v2 > 0) {
                            v1 = a ? ids.indexOf(a.id) : null;
                            v2 = b ? ids.indexOf(b.id) : null;
                        }
                        return orderAsc ? v1 - v2 : v2 - v1;
                    });
                }

                for (i = 0; i < d.length; i++) {
                    if (!(d[i] && (d[i].value || d[i].value === 0))) {
                        continue;
                    }

                    if (!text) {
                        title = sanitise(titleFormat ? titleFormat(d[i].x) : d[i].x);
                        text = "<table class='" + $$.CLASS.tooltip + "'>" + (title || title === 0 ? "<tr><th colspan='2'>" + title + "</th></tr>" : "");
                    }

                    value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));
                    if (value !== undefined) {
                        // Skip elements when their name is set to null
                        if (d[i].name === null) {
                            continue;
                        }
                        name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));
                        bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);

                        text += "<tr class='" + $$.CLASS.tooltipName + "-" + $$.getTargetSelectorSuffix(d[i].id) + "'>";
                        text += "<td class='name'><span style='background-color:" + bgcolor + "'></span>" + name + "</td>";
                        text += "<td class='value'>" + value + "</td>";
                        text += "</tr>";
                    }
                }
                return text + "</table>";
            };
            c3_chart_internal_fn.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;
                var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;
                var forArc = $$.hasArcType(),
                    mouse = d3.mouse(element);
                // Determin tooltip position
                if (forArc) {
                    tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];
                    tooltipTop = $$.height / 2 + mouse[1] + 20;
                } else {
                    svgLeft = $$.getSvgLeft(true);
                    if (config.axis_rotated) {
                        tooltipLeft = svgLeft + mouse[0] + 100;
                        tooltipRight = tooltipLeft + tWidth;
                        chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
                        tooltipTop = $$.x(dataToShow[0].x) + 20;
                    } else {
                        tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
                        tooltipRight = tooltipLeft + tWidth;
                        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
                        tooltipTop = mouse[1] + 15;
                    }

                    if (tooltipRight > chartRight) {
                        // 20 is needed for Firefox to keep tooltip width
                        tooltipLeft -= tooltipRight - chartRight + 20;
                    }
                    if (tooltipTop + tHeight > $$.currentHeight) {
                        tooltipTop -= tHeight + 30;
                    }
                }
                if (tooltipTop < 0) {
                    tooltipTop = 0;
                }
                return { top: tooltipTop, left: tooltipLeft };
            };
            c3_chart_internal_fn.showTooltip = function (selectedData, element) {
                var $$ = this,
                    config = $$.config;
                var tWidth, tHeight, position;
                var forArc = $$.hasArcType(),
                    dataToShow = selectedData.filter(function (d) {
                    return d && isValue(d.value);
                }),
                    positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;
                if (dataToShow.length === 0 || !config.tooltip_show) {
                    return;
                }
                $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", "block");

                // Get tooltip dimensions
                tWidth = $$.tooltip.property('offsetWidth');
                tHeight = $$.tooltip.property('offsetHeight');

                position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
                // Set tooltip
                $$.tooltip.style("top", position.top + "px").style("left", position.left + 'px');
            };
            c3_chart_internal_fn.hideTooltip = function () {
                this.tooltip.style("display", "none");
            };

            c3_chart_internal_fn.initLegend = function () {
                var $$ = this;
                $$.legendItemTextBox = {};
                $$.legendHasRendered = false;
                $$.legend = $$.svg.append("g").attr("transform", $$.getTranslate('legend'));
                if (!$$.config.legend_show) {
                    $$.legend.style('visibility', 'hidden');
                    $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
                    return;
                }
                // MEMO: call here to update legend box and tranlate for all
                // MEMO: translate will be upated by this, so transform not needed in updateLegend()
                $$.updateLegendWithDefaults();
            };
            c3_chart_internal_fn.updateLegendWithDefaults = function () {
                var $$ = this;
                $$.updateLegend($$.mapToIds($$.data.targets), { withTransform: false, withTransitionForTransform: false, withTransition: false });
            };
            c3_chart_internal_fn.updateSizeForLegend = function (legendHeight, legendWidth) {
                var $$ = this,
                    config = $$.config,
                    insetLegendPosition = {
                    top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
                    left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5
                };

                $$.margin3 = {
                    top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
                    right: NaN,
                    bottom: 0,
                    left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
                };
            };
            c3_chart_internal_fn.transformLegend = function (withTransition) {
                var $$ = this;
                (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate('legend'));
            };
            c3_chart_internal_fn.updateLegendStep = function (step) {
                this.legendStep = step;
            };
            c3_chart_internal_fn.updateLegendItemWidth = function (w) {
                this.legendItemWidth = w;
            };
            c3_chart_internal_fn.updateLegendItemHeight = function (h) {
                this.legendItemHeight = h;
            };
            c3_chart_internal_fn.getLegendWidth = function () {
                var $$ = this;
                return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
            };
            c3_chart_internal_fn.getLegendHeight = function () {
                var $$ = this,
                    h = 0;
                if ($$.config.legend_show) {
                    if ($$.isLegendRight) {
                        h = $$.currentHeight;
                    } else {
                        h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
                    }
                }
                return h;
            };
            c3_chart_internal_fn.opacityForLegend = function (legendItem) {
                return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
            };
            c3_chart_internal_fn.opacityForUnfocusedLegend = function (legendItem) {
                return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
            };
            c3_chart_internal_fn.toggleFocusLegend = function (targetIds, focus) {
                var $$ = this;
                targetIds = $$.mapToTargetIds(targetIds);
                $$.legend.selectAll('.' + CLASS.legendItem).filter(function (id) {
                    return targetIds.indexOf(id) >= 0;
                }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function () {
                    var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
                    return opacity.call($$, $$.d3.select(this));
                });
            };
            c3_chart_internal_fn.revertLegend = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function () {
                    return $$.opacityForLegend(d3.select(this));
                });
            };
            c3_chart_internal_fn.showLegend = function (targetIds) {
                var $$ = this,
                    config = $$.config;
                if (!config.legend_show) {
                    config.legend_show = true;
                    $$.legend.style('visibility', 'visible');
                    if (!$$.legendHasRendered) {
                        $$.updateLegendWithDefaults();
                    }
                }
                $$.removeHiddenLegendIds(targetIds);
                $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function () {
                    return $$.opacityForLegend($$.d3.select(this));
                });
            };
            c3_chart_internal_fn.hideLegend = function (targetIds) {
                var $$ = this,
                    config = $$.config;
                if (config.legend_show && isEmpty(targetIds)) {
                    config.legend_show = false;
                    $$.legend.style('visibility', 'hidden');
                }
                $$.addHiddenLegendIds(targetIds);
                $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');
            };
            c3_chart_internal_fn.clearLegendItemTextBoxCache = function () {
                this.legendItemTextBox = {};
            };
            c3_chart_internal_fn.updateLegend = function (targetIds, options, transitions) {
                var $$ = this,
                    config = $$.config;
                var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;
                var paddingTop = 4,
                    paddingRight = 10,
                    maxWidth = 0,
                    maxHeight = 0,
                    posMin = 10,
                    tileWidth = config.legend_item_tile_width + 5;
                var l,
                    totalLength = 0,
                    offsets = {},
                    widths = {},
                    heights = {},
                    margins = [0],
                    steps = {},
                    step = 0;
                var withTransition, withTransitionForTransform;
                var texts, rects, tiles, background;

                // Skip elements when their name is set to null
                targetIds = targetIds.filter(function (id) {
                    return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
                });

                options = options || {};
                withTransition = getOption(options, "withTransition", true);
                withTransitionForTransform = getOption(options, "withTransitionForTransform", true);

                function getTextBox(textElement, id) {
                    if (!$$.legendItemTextBox[id]) {
                        $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
                    }
                    return $$.legendItemTextBox[id];
                }

                function updatePositions(textElement, id, index) {
                    var reset = index === 0,
                        isLast = index === targetIds.length - 1,
                        box = getTextBox(textElement, id),
                        itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) + config.legend_padding,
                        itemHeight = box.height + paddingTop,
                        itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,
                        areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),
                        margin,
                        maxLength;

                    // MEMO: care about condifion of step, totalLength
                    function updateValues(id, withoutStep) {
                        if (!withoutStep) {
                            margin = (areaLength - totalLength - itemLength) / 2;
                            if (margin < posMin) {
                                margin = (areaLength - itemLength) / 2;
                                totalLength = 0;
                                step++;
                            }
                        }
                        steps[id] = step;
                        margins[step] = $$.isLegendInset ? 10 : margin;
                        offsets[id] = totalLength;
                        totalLength += itemLength;
                    }

                    if (reset) {
                        totalLength = 0;
                        step = 0;
                        maxWidth = 0;
                        maxHeight = 0;
                    }

                    if (config.legend_show && !$$.isLegendToShow(id)) {
                        widths[id] = heights[id] = steps[id] = offsets[id] = 0;
                        return;
                    }

                    widths[id] = itemWidth;
                    heights[id] = itemHeight;

                    if (!maxWidth || itemWidth >= maxWidth) {
                        maxWidth = itemWidth;
                    }
                    if (!maxHeight || itemHeight >= maxHeight) {
                        maxHeight = itemHeight;
                    }
                    maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;

                    if (config.legend_equally) {
                        Object.keys(widths).forEach(function (id) {
                            widths[id] = maxWidth;
                        });
                        Object.keys(heights).forEach(function (id) {
                            heights[id] = maxHeight;
                        });
                        margin = (areaLength - maxLength * targetIds.length) / 2;
                        if (margin < posMin) {
                            totalLength = 0;
                            step = 0;
                            targetIds.forEach(function (id) {
                                updateValues(id);
                            });
                        } else {
                            updateValues(id, true);
                        }
                    } else {
                        updateValues(id);
                    }
                }

                if ($$.isLegendInset) {
                    step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;
                    $$.updateLegendStep(step);
                }

                if ($$.isLegendRight) {
                    xForLegend = function (id) {
                        return maxWidth * steps[id];
                    };
                    yForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                } else if ($$.isLegendInset) {
                    xForLegend = function (id) {
                        return maxWidth * steps[id] + 10;
                    };
                    yForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                } else {
                    xForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                    yForLegend = function (id) {
                        return maxHeight * steps[id];
                    };
                }
                xForLegendText = function (id, i) {
                    return xForLegend(id, i) + 4 + config.legend_item_tile_width;
                };
                yForLegendText = function (id, i) {
                    return yForLegend(id, i) + 9;
                };
                xForLegendRect = function (id, i) {
                    return xForLegend(id, i);
                };
                yForLegendRect = function (id, i) {
                    return yForLegend(id, i) - 5;
                };
                x1ForLegendTile = function (id, i) {
                    return xForLegend(id, i) - 2;
                };
                x2ForLegendTile = function (id, i) {
                    return xForLegend(id, i) - 2 + config.legend_item_tile_width;
                };
                yForLegendTile = function (id, i) {
                    return yForLegend(id, i) + 4;
                };

                // Define g for legend area
                l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function (id) {
                    return $$.generateClass(CLASS.legendItem, id);
                }).style('visibility', function (id) {
                    return $$.isLegendToShow(id) ? 'visible' : 'hidden';
                }).style('cursor', 'pointer').on('click', function (id) {
                    if (config.legend_item_onclick) {
                        config.legend_item_onclick.call($$, id);
                    } else {
                        if ($$.d3.event.altKey) {
                            $$.api.hide();
                            $$.api.show(id);
                        } else {
                            $$.api.toggle(id);
                            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
                        }
                    }
                }).on('mouseover', function (id) {
                    if (config.legend_item_onmouseover) {
                        config.legend_item_onmouseover.call($$, id);
                    } else {
                        $$.d3.select(this).classed(CLASS.legendItemFocused, true);
                        if (!$$.transiting && $$.isTargetToShow(id)) {
                            $$.api.focus(id);
                        }
                    }
                }).on('mouseout', function (id) {
                    if (config.legend_item_onmouseout) {
                        config.legend_item_onmouseout.call($$, id);
                    } else {
                        $$.d3.select(this).classed(CLASS.legendItemFocused, false);
                        $$.api.revert();
                    }
                });
                l.append('text').text(function (id) {
                    return isDefined(config.data_names[id]) ? config.data_names[id] : id;
                }).each(function (id, i) {
                    updatePositions(this, id, i);
                }).style("pointer-events", "none").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
                l.append('rect').attr("class", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
                l.append('line').attr('class', CLASS.legendItemTile).style('stroke', $$.color).style("pointer-events", "none").attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200).attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200).attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('stroke-width', config.legend_item_tile_height);

                // Set background for inset legend
                background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
                if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
                    background = $$.legend.insert('g', '.' + CLASS.legendItem).attr("class", CLASS.legendBackground).append('rect');
                }

                texts = $$.legend.selectAll('text').data(targetIds).text(function (id) {
                    return isDefined(config.data_names[id]) ? config.data_names[id] : id;
                }) // MEMO: needed for update
                .each(function (id, i) {
                    updatePositions(this, id, i);
                });
                (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);

                rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
                (withTransition ? rects.transition() : rects).attr('width', function (id) {
                    return widths[id];
                }).attr('height', function (id) {
                    return heights[id];
                }).attr('x', xForLegendRect).attr('y', yForLegendRect);

                tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
                (withTransition ? tiles.transition() : tiles).style('stroke', $$.color).attr('x1', x1ForLegendTile).attr('y1', yForLegendTile).attr('x2', x2ForLegendTile).attr('y2', yForLegendTile);

                if (background) {
                    (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);
                }

                // toggle legend state
                $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {
                    return !$$.isTargetToShow(id);
                });

                // Update all to reflect change of legend
                $$.updateLegendItemWidth(maxWidth);
                $$.updateLegendItemHeight(maxHeight);
                $$.updateLegendStep(step);
                // Update size and scale
                $$.updateSizes();
                $$.updateScales();
                $$.updateSvgSize();
                // Update g positions
                $$.transformAll(withTransitionForTransform, transitions);
                $$.legendHasRendered = true;
            };

            c3_chart_internal_fn.initTitle = function () {
                var $$ = this;
                $$.title = $$.svg.append("text").text($$.config.title_text).attr("class", $$.CLASS.title);
            };
            c3_chart_internal_fn.redrawTitle = function () {
                var $$ = this;
                $$.title.attr("x", $$.xForTitle.bind($$)).attr("y", $$.yForTitle.bind($$));
            };
            c3_chart_internal_fn.xForTitle = function () {
                var $$ = this,
                    config = $$.config,
                    position = config.title_position || 'left',
                    x;
                if (position.indexOf('right') >= 0) {
                    x = $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right;
                } else if (position.indexOf('center') >= 0) {
                    x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2;
                } else {
                    // left
                    x = config.title_padding.left;
                }
                return x;
            };
            c3_chart_internal_fn.yForTitle = function () {
                var $$ = this;
                return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;
            };
            c3_chart_internal_fn.getTitlePadding = function () {
                var $$ = this;
                return $$.yForTitle() + $$.config.title_padding.bottom;
            };

            function Axis(owner) {
                API.call(this, owner);
            }

            inherit(API, Axis);

            Axis.prototype.init = function init() {

                var $$ = this.owner,
                    config = $$.config,
                    main = $$.main;
                $$.axes.x = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisX).attr("clip-path", $$.clipPathForXAxis).attr("transform", $$.getTranslate('x')).style("visibility", config.axis_x_show ? 'visible' : 'hidden');
                $$.axes.x.append("text").attr("class", CLASS.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this));
                $$.axes.y = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate('y')).style("visibility", config.axis_y_show ? 'visible' : 'hidden');
                $$.axes.y.append("text").attr("class", CLASS.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this));

                $$.axes.y2 = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY2)
                // clip-path?
                .attr("transform", $$.getTranslate('y2')).style("visibility", config.axis_y2_show ? 'visible' : 'hidden');
                $$.axes.y2.append("text").attr("class", CLASS.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
            };
            Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
                var $$ = this.owner,
                    config = $$.config,
                    axisParams = {
                    isCategory: $$.isCategorized(),
                    withOuterTick: withOuterTick,
                    tickMultiline: config.axis_x_tick_multiline,
                    tickWidth: config.axis_x_tick_width,
                    tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
                    withoutTransition: withoutTransition
                },
                    axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient);

                if ($$.isTimeSeries() && tickValues && typeof tickValues !== "function") {
                    tickValues = tickValues.map(function (v) {
                        return $$.parseDate(v);
                    });
                }

                // Set tick
                axis.tickFormat(tickFormat).tickValues(tickValues);
                if ($$.isCategorized()) {
                    axis.tickCentered(config.axis_x_tick_centered);
                    if (isEmpty(config.axis_x_tick_culling)) {
                        config.axis_x_tick_culling = false;
                    }
                }

                return axis;
            };
            Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
                var $$ = this.owner,
                    config = $$.config,
                    tickValues;
                if (config.axis_x_tick_fit || config.axis_x_tick_count) {
                    tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
                }
                if (axis) {
                    axis.tickValues(tickValues);
                } else {
                    $$.xAxis.tickValues(tickValues);
                    $$.subXAxis.tickValues(tickValues);
                }
                return tickValues;
            };
            Axis.prototype.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
                var $$ = this.owner,
                    config = $$.config,
                    axisParams = {
                    withOuterTick: withOuterTick,
                    withoutTransition: withoutTransition,
                    tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
                },
                    axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient).tickFormat(tickFormat);
                if ($$.isTimeSeriesY()) {
                    axis.ticks($$.d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);
                } else {
                    axis.tickValues(tickValues);
                }
                return axis;
            };
            Axis.prototype.getId = function getId(id) {
                var config = this.owner.config;
                return id in config.data_axes ? config.data_axes[id] : 'y';
            };
            Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
                var $$ = this.owner,
                    config = $$.config,
                    format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function (v) {
                    return v < 0 ? v.toFixed(0) : v;
                };
                if (config.axis_x_tick_format) {
                    if (isFunction(config.axis_x_tick_format)) {
                        format = config.axis_x_tick_format;
                    } else if ($$.isTimeSeries()) {
                        format = function (date) {
                            return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : "";
                        };
                    }
                }
                return isFunction(format) ? function (v) {
                    return format.call($$, v);
                } : format;
            };
            Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
                return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
            };
            Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
                return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
            };
            Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
                return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
            };
            Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
                return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
            };
            Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
                var $$ = this.owner,
                    config = $$.config,
                    option;
                if (axisId === 'y') {
                    option = config.axis_y_label;
                } else if (axisId === 'y2') {
                    option = config.axis_y2_label;
                } else if (axisId === 'x') {
                    option = config.axis_x_label;
                }
                return option;
            };
            Axis.prototype.getLabelText = function getLabelText(axisId) {
                var option = this.getLabelOptionByAxisId(axisId);
                return isString(option) ? option : option ? option.text : null;
            };
            Axis.prototype.setLabelText = function setLabelText(axisId, text) {
                var $$ = this.owner,
                    config = $$.config,
                    option = this.getLabelOptionByAxisId(axisId);
                if (isString(option)) {
                    if (axisId === 'y') {
                        config.axis_y_label = text;
                    } else if (axisId === 'y2') {
                        config.axis_y2_label = text;
                    } else if (axisId === 'x') {
                        config.axis_x_label = text;
                    }
                } else if (option) {
                    option.text = text;
                }
            };
            Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
                var option = this.getLabelOptionByAxisId(axisId),
                    position = option && typeof option === 'object' && option.position ? option.position : defaultPosition;
                return {
                    isInner: position.indexOf('inner') >= 0,
                    isOuter: position.indexOf('outer') >= 0,
                    isLeft: position.indexOf('left') >= 0,
                    isCenter: position.indexOf('center') >= 0,
                    isRight: position.indexOf('right') >= 0,
                    isTop: position.indexOf('top') >= 0,
                    isMiddle: position.indexOf('middle') >= 0,
                    isBottom: position.indexOf('bottom') >= 0
                };
            };
            Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
                return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
            };
            Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
                return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
            };
            Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
                return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
            };
            Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
                return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();
            };
            Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
                return this.getLabelText('x');
            };
            Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
                return this.getLabelText('y');
            };
            Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
                return this.getLabelText('y2');
            };
            Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
                var $$ = this.owner;
                if (forHorizontal) {
                    return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
                } else {
                    return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;
                }
            };
            Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
                if (forHorizontal) {
                    return position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0";
                } else {
                    return position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0";
                }
            };
            Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
                if (forHorizontal) {
                    return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
                } else {
                    return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
                }
            };
            Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
                return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
                return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
                return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
                return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
                return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
                return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
                var $$ = this.owner,
                    config = $$.config,
                    position = this.getXAxisLabelPosition();
                if (config.axis_rotated) {
                    return position.isInner ? "1.2em" : -25 - this.getMaxTickWidth('x');
                } else {
                    return position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
                }
            };
            Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
                var $$ = this.owner,
                    position = this.getYAxisLabelPosition();
                if ($$.config.axis_rotated) {
                    return position.isInner ? "-0.5em" : "3em";
                } else {
                    return position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);
                }
            };
            Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
                var $$ = this.owner,
                    position = this.getY2AxisLabelPosition();
                if ($$.config.axis_rotated) {
                    return position.isInner ? "1.2em" : "-2.2em";
                } else {
                    return position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);
                }
            };
            Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
                var $$ = this.owner,
                    config = $$.config,
                    maxWidth = 0,
                    targetsToShow,
                    scale,
                    axis,
                    dummy,
                    svg;
                if (withoutRecompute && $$.currentMaxTickWidths[id]) {
                    return $$.currentMaxTickWidths[id];
                }
                if ($$.svg) {
                    targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    if (id === 'y') {
                        scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
                        axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true);
                    } else if (id === 'y2') {
                        scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
                        axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true);
                    } else {
                        scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
                        axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
                        this.updateXAxisTickValues(targetsToShow, axis);
                    }
                    dummy = $$.d3.select('body').append('div').classed('c3', true);
                    svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function () {
                        $$.d3.select(this).selectAll('text').each(function () {
                            var box = this.getBoundingClientRect();
                            if (maxWidth < box.width) {
                                maxWidth = box.width;
                            }
                        });
                        dummy.remove();
                    });
                }
                $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
                return $$.currentMaxTickWidths[id];
            };

            Axis.prototype.updateLabels = function updateLabels(withTransition) {
                var $$ = this.owner;
                var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),
                    axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),
                    axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
                (withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));
                (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));
                (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
            };
            Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
                var p = typeof padding === 'number' ? padding : padding[key];
                if (!isValue(p)) {
                    return defaultValue;
                }
                if (padding.unit === 'ratio') {
                    return padding[key] * domainLength;
                }
                // assume padding is pixels if unit is not specified
                return this.convertPixelsToAxisPadding(p, domainLength);
            };
            Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
                var $$ = this.owner,
                    length = $$.config.axis_rotated ? $$.width : $$.height;
                return domainLength * (pixels / length);
            };
            Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
                var tickValues = values,
                    targetCount,
                    start,
                    end,
                    count,
                    interval,
                    i,
                    tickValue;
                if (tickCount) {
                    targetCount = isFunction(tickCount) ? tickCount() : tickCount;
                    // compute ticks according to tickCount
                    if (targetCount === 1) {
                        tickValues = [values[0]];
                    } else if (targetCount === 2) {
                        tickValues = [values[0], values[values.length - 1]];
                    } else if (targetCount > 2) {
                        count = targetCount - 2;
                        start = values[0];
                        end = values[values.length - 1];
                        interval = (end - start) / (count + 1);
                        // re-construct unique values
                        tickValues = [start];
                        for (i = 0; i < count; i++) {
                            tickValue = +start + interval * (i + 1);
                            tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
                        }
                        tickValues.push(end);
                    }
                }
                if (!forTimeSeries) {
                    tickValues = tickValues.sort(function (a, b) {
                        return a - b;
                    });
                }
                return tickValues;
            };
            Axis.prototype.generateTransitions = function generateTransitions(duration) {
                var $$ = this.owner,
                    axes = $$.axes;
                return {
                    axisX: duration ? axes.x.transition().duration(duration) : axes.x,
                    axisY: duration ? axes.y.transition().duration(duration) : axes.y,
                    axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
                    axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
                };
            };
            Axis.prototype.redraw = function redraw(transitions, isHidden) {
                var $$ = this.owner;
                $$.axes.x.style("opacity", isHidden ? 0 : 1);
                $$.axes.y.style("opacity", isHidden ? 0 : 1);
                $$.axes.y2.style("opacity", isHidden ? 0 : 1);
                $$.axes.subx.style("opacity", isHidden ? 0 : 1);
                transitions.axisX.call($$.xAxis);
                transitions.axisY.call($$.yAxis);
                transitions.axisY2.call($$.y2Axis);
                transitions.axisSubX.call($$.subXAxis);
            };

            c3_chart_internal_fn.getClipPath = function (id) {
                var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
                return "url(" + (isIE9 ? "" : document.URL.split('#')[0]) + "#" + id + ")";
            };
            c3_chart_internal_fn.appendClip = function (parent, id) {
                return parent.append("clipPath").attr("id", id).append("rect");
            };
            c3_chart_internal_fn.getAxisClipX = function (forHorizontal) {
                // axis line width + padding for left
                var left = Math.max(30, this.margin.left);
                return forHorizontal ? -(1 + left) : -(left - 1);
            };
            c3_chart_internal_fn.getAxisClipY = function (forHorizontal) {
                return forHorizontal ? -20 : -this.margin.top;
            };
            c3_chart_internal_fn.getXAxisClipX = function () {
                var $$ = this;
                return $$.getAxisClipX(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getXAxisClipY = function () {
                var $$ = this;
                return $$.getAxisClipY(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipX = function () {
                var $$ = this;
                return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipY = function () {
                var $$ = this;
                return $$.getAxisClipY($$.config.axis_rotated);
            };
            c3_chart_internal_fn.getAxisClipWidth = function (forHorizontal) {
                var $$ = this,
                    left = Math.max(30, $$.margin.left),
                    right = Math.max(30, $$.margin.right);
                // width + axis line width + padding for left/right
                return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
            };
            c3_chart_internal_fn.getAxisClipHeight = function (forHorizontal) {
                // less than 20 is not enough to show the axis label 'outer' without legend
                return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
            };
            c3_chart_internal_fn.getXAxisClipWidth = function () {
                var $$ = this;
                return $$.getAxisClipWidth(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getXAxisClipHeight = function () {
                var $$ = this;
                return $$.getAxisClipHeight(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipWidth = function () {
                var $$ = this;
                return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
            };
            c3_chart_internal_fn.getYAxisClipHeight = function () {
                var $$ = this;
                return $$.getAxisClipHeight($$.config.axis_rotated);
            };

            c3_chart_internal_fn.initPie = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                $$.pie = d3.layout.pie().value(function (d) {
                    return d.values.reduce(function (a, b) {
                        return a + b.value;
                    }, 0);
                });
                if (!config.data_order) {
                    $$.pie.sort(null);
                }
            };

            c3_chart_internal_fn.updateRadius = function () {
                var $$ = this,
                    config = $$.config,
                    w = config.gauge_width || config.donut_width;
                $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2;
                $$.radius = $$.radiusExpanded * 0.95;
                $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
                $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;
            };

            c3_chart_internal_fn.updateArc = function () {
                var $$ = this;
                $$.svgArc = $$.getSvgArc();
                $$.svgArcExpanded = $$.getSvgArcExpanded();
                $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
            };

            c3_chart_internal_fn.updateAngle = function (d) {
                var $$ = this,
                    config = $$.config,
                    found = false,
                    index = 0,
                    gMin,
                    gMax,
                    gTic,
                    gValue;

                if (!config) {
                    return null;
                }

                $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
                    if (!found && t.data.id === d.data.id) {
                        found = true;
                        d = t;
                        d.index = index;
                    }
                    index++;
                });
                if (isNaN(d.startAngle)) {
                    d.startAngle = 0;
                }
                if (isNaN(d.endAngle)) {
                    d.endAngle = d.startAngle;
                }
                if ($$.isGaugeType(d.data)) {
                    gMin = config.gauge_min;
                    gMax = config.gauge_max;
                    gTic = Math.PI * (config.gauge_fullCircle ? 2 : 1) / (gMax - gMin);
                    gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
                    d.startAngle = config.gauge_startingAngle;
                    d.endAngle = d.startAngle + gTic * gValue;
                }
                return found ? d : null;
            };

            c3_chart_internal_fn.getSvgArc = function () {
                var $$ = this,
                    arc = $$.d3.svg.arc().outerRadius($$.radius).innerRadius($$.innerRadius),
                    newArc = function (d, withoutUpdate) {
                    var updated;
                    if (withoutUpdate) {
                        return arc(d);
                    } // for interpolate
                    updated = $$.updateAngle(d);
                    return updated ? arc(updated) : "M 0 0";
                };
                // TODO: extends all function
                newArc.centroid = arc.centroid;
                return newArc;
            };

            c3_chart_internal_fn.getSvgArcExpanded = function (rate) {
                var $$ = this,
                    arc = $$.d3.svg.arc().outerRadius($$.radiusExpanded * (rate ? rate : 1)).innerRadius($$.innerRadius);
                return function (d) {
                    var updated = $$.updateAngle(d);
                    return updated ? arc(updated) : "M 0 0";
                };
            };

            c3_chart_internal_fn.getArc = function (d, withoutUpdate, force) {
                return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
            };

            c3_chart_internal_fn.transformForArcLabel = function (d) {
                var $$ = this,
                    config = $$.config,
                    updated = $$.updateAngle(d),
                    c,
                    x,
                    y,
                    h,
                    ratio,
                    translate = "";
                if (updated && !$$.hasType('gauge')) {
                    c = this.svgArc.centroid(updated);
                    x = isNaN(c[0]) ? 0 : c[0];
                    y = isNaN(c[1]) ? 0 : c[1];
                    h = Math.sqrt(x * x + y * y);
                    if ($$.hasType('donut') && config.donut_label_ratio) {
                        ratio = isFunction(config.donut_label_ratio) ? config.donut_label_ratio(d, $$.radius, h) : config.donut_label_ratio;
                    } else if ($$.hasType('pie') && config.pie_label_ratio) {
                        ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio;
                    } else {
                        ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;
                    }
                    translate = "translate(" + x * ratio + ',' + y * ratio + ")";
                }
                return translate;
            };

            c3_chart_internal_fn.getArcRatio = function (d) {
                var $$ = this,
                    config = $$.config,
                    whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2);
                return d ? (d.endAngle - d.startAngle) / whole : null;
            };

            c3_chart_internal_fn.convertToArcData = function (d) {
                return this.addName({
                    id: d.data.id,
                    value: d.value,
                    ratio: this.getArcRatio(d),
                    index: d.index
                });
            };

            c3_chart_internal_fn.textForArcLabel = function (d) {
                var $$ = this,
                    updated,
                    value,
                    ratio,
                    id,
                    format;
                if (!$$.shouldShowArcLabel()) {
                    return "";
                }
                updated = $$.updateAngle(d);
                value = updated ? updated.value : null;
                ratio = $$.getArcRatio(updated);
                id = d.data.id;
                if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
                    return "";
                }
                format = $$.getArcLabelFormat();
                return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
            };

            c3_chart_internal_fn.expandArc = function (targetIds) {
                var $$ = this,
                    interval;

                // MEMO: avoid to cancel transition
                if ($$.transiting) {
                    interval = window.setInterval(function () {
                        if (!$$.transiting) {
                            window.clearInterval(interval);
                            if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
                                $$.expandArc(targetIds);
                            }
                        }
                    }, 10);
                    return;
                }

                targetIds = $$.mapToTargetIds(targetIds);

                $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {
                    if (!$$.shouldExpand(d.data.id)) {
                        return;
                    }
                    $$.d3.select(this).selectAll('path').transition().duration($$.expandDuration(d.data.id)).attr("d", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr("d", $$.svgArcExpandedSub).each(function (d) {
                        if ($$.isDonutType(d.data)) {
                            // callback here
                        }
                    });
                });
            };

            c3_chart_internal_fn.unexpandArc = function (targetIds) {
                var $$ = this;

                if ($$.transiting) {
                    return;
                }

                targetIds = $$.mapToTargetIds(targetIds);

                $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(function (d) {
                    return $$.expandDuration(d.data.id);
                }).attr("d", $$.svgArc);
                $$.svg.selectAll('.' + CLASS.arc).style("opacity", 1);
            };

            c3_chart_internal_fn.expandDuration = function (id) {
                var $$ = this,
                    config = $$.config;

                if ($$.isDonutType(id)) {
                    return config.donut_expand_duration;
                } else if ($$.isGaugeType(id)) {
                    return config.gauge_expand_duration;
                } else if ($$.isPieType(id)) {
                    return config.pie_expand_duration;
                } else {
                    return 50;
                }
            };

            c3_chart_internal_fn.shouldExpand = function (id) {
                var $$ = this,
                    config = $$.config;
                return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
            };

            c3_chart_internal_fn.shouldShowArcLabel = function () {
                var $$ = this,
                    config = $$.config,
                    shouldShow = true;
                if ($$.hasType('donut')) {
                    shouldShow = config.donut_label_show;
                } else if ($$.hasType('pie')) {
                    shouldShow = config.pie_label_show;
                }
                // when gauge, always true
                return shouldShow;
            };

            c3_chart_internal_fn.meetsArcLabelThreshold = function (ratio) {
                var $$ = this,
                    config = $$.config,
                    threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;
                return ratio >= threshold;
            };

            c3_chart_internal_fn.getArcLabelFormat = function () {
                var $$ = this,
                    config = $$.config,
                    format = config.pie_label_format;
                if ($$.hasType('gauge')) {
                    format = config.gauge_label_format;
                } else if ($$.hasType('donut')) {
                    format = config.donut_label_format;
                }
                return format;
            };

            c3_chart_internal_fn.getArcTitle = function () {
                var $$ = this;
                return $$.hasType('donut') ? $$.config.donut_title : "";
            };

            c3_chart_internal_fn.updateTargetsForArc = function (targets) {
                var $$ = this,
                    main = $$.main,
                    mainPieUpdate,
                    mainPieEnter,
                    classChartArc = $$.classChartArc.bind($$),
                    classArcs = $$.classArcs.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr("class", function (d) {
                    return classChartArc(d) + classFocus(d.data);
                });
                mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
                mainPieEnter.append('g').attr('class', classArcs);
                mainPieEnter.append("text").attr("dy", $$.hasType('gauge') ? "-.1em" : ".35em").style("opacity", 0).style("text-anchor", "middle").style("pointer-events", "none");
                // MEMO: can not keep same color..., but not bad to update color in redraw
                //mainPieUpdate.exit().remove();
            };

            c3_chart_internal_fn.initArc = function () {
                var $$ = this;
                $$.arcs = $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
                $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style("text-anchor", "middle").text($$.getArcTitle());
            };

            c3_chart_internal_fn.redrawArc = function (duration, durationForExit, withTransform) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    main = $$.main,
                    mainArc;
                mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));
                mainArc.enter().append('path').attr("class", $$.classArc.bind($$)).style("fill", function (d) {
                    return $$.color(d.data);
                }).style("cursor", function (d) {
                    return config.interaction_enabled && config.data_selection_isselectable(d) ? "pointer" : null;
                }).style("opacity", 0).each(function (d) {
                    if ($$.isGaugeType(d.data)) {
                        d.startAngle = d.endAngle = config.gauge_startingAngle;
                    }
                    this._current = d;
                });
                mainArc.attr("transform", function (d) {
                    return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
                }).style("opacity", function (d) {
                    return d === this._current ? 0 : 1;
                }).on('mouseover', config.interaction_enabled ? function (d) {
                    var updated, arcData;
                    if ($$.transiting) {
                        // skip while transiting
                        return;
                    }
                    updated = $$.updateAngle(d);
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        // transitions
                        $$.expandArc(updated.data.id);
                        $$.api.focus(updated.data.id);
                        $$.toggleFocusLegend(updated.data.id, true);
                        $$.config.data_onmouseover(arcData, this);
                    }
                } : null).on('mousemove', config.interaction_enabled ? function (d) {
                    var updated = $$.updateAngle(d),
                        arcData,
                        selectedData;
                    if (updated) {
                        arcData = $$.convertToArcData(updated), selectedData = [arcData];
                        $$.showTooltip(selectedData, this);
                    }
                } : null).on('mouseout', config.interaction_enabled ? function (d) {
                    var updated, arcData;
                    if ($$.transiting) {
                        // skip while transiting
                        return;
                    }
                    updated = $$.updateAngle(d);
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        // transitions
                        $$.unexpandArc(updated.data.id);
                        $$.api.revert();
                        $$.revertLegend();
                        $$.hideTooltip();
                        $$.config.data_onmouseout(arcData, this);
                    }
                } : null).on('click', config.interaction_enabled ? function (d, i) {
                    var updated = $$.updateAngle(d),
                        arcData;
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        if ($$.toggleShape) {
                            $$.toggleShape(this, arcData, i);
                        }
                        $$.config.data_onclick.call($$.api, arcData, this);
                    }
                } : null).each(function () {
                    $$.transiting = true;
                }).transition().duration(duration).attrTween("d", function (d) {
                    var updated = $$.updateAngle(d),
                        interpolate;
                    if (!updated) {
                        return function () {
                            return "M 0 0";
                        };
                    }
                    //                if (this._current === d) {
                    //                    this._current = {
                    //                        startAngle: Math.PI*2,
                    //                        endAngle: Math.PI*2,
                    //                    };
                    //                }
                    if (isNaN(this._current.startAngle)) {
                        this._current.startAngle = 0;
                    }
                    if (isNaN(this._current.endAngle)) {
                        this._current.endAngle = this._current.startAngle;
                    }
                    interpolate = d3.interpolate(this._current, updated);
                    this._current = interpolate(0);
                    return function (t) {
                        var interpolated = interpolate(t);
                        interpolated.data = d.data; // data.id will be updated by interporator
                        return $$.getArc(interpolated, true);
                    };
                }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
                    return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
                }) // Where gauge reading color would receive customization.
                .style("opacity", 1).call($$.endall, function () {
                    $$.transiting = false;
                });
                mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();
                main.selectAll('.' + CLASS.chartArc).select('text').style("opacity", 0).attr('class', function (d) {
                    return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
                }).text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style('font-size', function (d) {
                    return $$.isGaugeType(d.data) ? Math.round($$.radius / 5) + 'px' : '';
                }).transition().duration(duration).style("opacity", function (d) {
                    return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
                });
                main.select('.' + CLASS.chartArcsTitle).style("opacity", $$.hasType('donut') || $$.hasType('gauge') ? 1 : 0);

                if ($$.hasType('gauge')) {
                    $$.arcs.select('.' + CLASS.chartArcsBackground).attr("d", function () {
                        var d = {
                            data: [{ value: config.gauge_max }],
                            startAngle: config.gauge_startingAngle,
                            endAngle: -1 * config.gauge_startingAngle
                        };
                        return $$.getArc(d, true, true);
                    });
                    $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : '');
                    $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_min : '');
                    $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr("dx", $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_max : '');
                }
            };
            c3_chart_internal_fn.initGauge = function () {
                var arcs = this.arcs;
                if (this.hasType('gauge')) {
                    arcs.append('path').attr("class", CLASS.chartArcsBackground);
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none");
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none");
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none");
                }
            };
            c3_chart_internal_fn.getGaugeLabelHeight = function () {
                return this.config.gauge_label_show ? 20 : 0;
            };

            c3_chart_internal_fn.initRegion = function () {
                var $$ = this;
                $$.region = $$.main.append('g').attr("clip-path", $$.clipPath).attr("class", CLASS.regions);
            };
            c3_chart_internal_fn.updateRegion = function (duration) {
                var $$ = this,
                    config = $$.config;

                // hide if arc type
                $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

                $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);
                $$.mainRegion.enter().append('g').append('rect').style("fill-opacity", 0);
                $$.mainRegion.attr('class', $$.classRegion.bind($$));
                $$.mainRegion.exit().transition().duration(duration).style("opacity", 0).remove();
            };
            c3_chart_internal_fn.redrawRegion = function (withTransition) {
                var $$ = this,
                    regions = $$.mainRegion.selectAll('rect').each(function () {
                    // data is binded to g and it's not transferred to rect (child node) automatically,
                    // then data of each rect has to be updated manually.
                    // TODO: there should be more efficient way to solve this?
                    var parentData = $$.d3.select(this.parentNode).datum();
                    $$.d3.select(this).datum(parentData);
                }),
                    x = $$.regionX.bind($$),
                    y = $$.regionY.bind($$),
                    w = $$.regionWidth.bind($$),
                    h = $$.regionHeight.bind($$);
                return [(withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h).style("fill-opacity", function (d) {
                    return isValue(d.opacity) ? d.opacity : 0.1;
                })];
            };
            c3_chart_internal_fn.regionX = function (d) {
                var $$ = this,
                    config = $$.config,
                    xPos,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    xPos = config.axis_rotated ? 'start' in d ? yScale(d.start) : 0 : 0;
                } else {
                    xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0;
                }
                return xPos;
            };
            c3_chart_internal_fn.regionY = function (d) {
                var $$ = this,
                    config = $$.config,
                    yPos,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;
                } else {
                    yPos = config.axis_rotated ? 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0 : 0;
                }
                return yPos;
            };
            c3_chart_internal_fn.regionWidth = function (d) {
                var $$ = this,
                    config = $$.config,
                    start = $$.regionX(d),
                    end,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    end = config.axis_rotated ? 'end' in d ? yScale(d.end) : $$.width : $$.width;
                } else {
                    end = config.axis_rotated ? $$.width : 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width;
                }
                return end < start ? 0 : end - start;
            };
            c3_chart_internal_fn.regionHeight = function (d) {
                var $$ = this,
                    config = $$.config,
                    start = this.regionY(d),
                    end,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height;
                } else {
                    end = config.axis_rotated ? 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height : $$.height;
                }
                return end < start ? 0 : end - start;
            };
            c3_chart_internal_fn.isRegionOnX = function (d) {
                return !d.axis || d.axis === 'x';
            };

            c3_chart_internal_fn.drag = function (mouse) {
                var $$ = this,
                    config = $$.config,
                    main = $$.main,
                    d3 = $$.d3;
                var sx, sy, mx, my, minX, maxX, minY, maxY;

                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                if (config.zoom_enabled && !$$.zoom.altDomain) {
                    return;
                } // skip if zoomable because of conflict drag dehavior
                if (!config.data_selection_multiple) {
                    return;
                } // skip when single selection because drag is used for multiple selection

                sx = $$.dragStart[0];
                sy = $$.dragStart[1];
                mx = mouse[0];
                my = mouse[1];
                minX = Math.min(sx, mx);
                maxX = Math.max(sx, mx);
                minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);
                maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

                main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY);
                // TODO: binary search when multiple xs
                main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function (d) {
                    return config.data_selection_isselectable(d);
                }).each(function (d, i) {
                    var shape = d3.select(this),
                        isSelected = shape.classed(CLASS.SELECTED),
                        isIncluded = shape.classed(CLASS.INCLUDED),
                        _x,
                        _y,
                        _w,
                        _h,
                        toggle,
                        isWithin = false,
                        box;
                    if (shape.classed(CLASS.circle)) {
                        _x = shape.attr("cx") * 1;
                        _y = shape.attr("cy") * 1;
                        toggle = $$.togglePoint;
                        isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
                    } else if (shape.classed(CLASS.bar)) {
                        box = getPathBox(this);
                        _x = box.x;
                        _y = box.y;
                        _w = box.width;
                        _h = box.height;
                        toggle = $$.togglePath;
                        isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
                    } else {
                        // line/area selection not supported yet
                        return;
                    }
                    if (isWithin ^ isIncluded) {
                        shape.classed(CLASS.INCLUDED, !isIncluded);
                        // TODO: included/unincluded callback here
                        shape.classed(CLASS.SELECTED, !isSelected);
                        toggle.call($$, !isSelected, shape, d, i);
                    }
                });
            };

            c3_chart_internal_fn.dragstart = function (mouse) {
                var $$ = this,
                    config = $$.config;
                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                $$.dragStart = mouse;
                $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);
                $$.dragging = true;
            };

            c3_chart_internal_fn.dragend = function () {
                var $$ = this,
                    config = $$.config;
                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();
                $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
                $$.dragging = false;
            };

            c3_chart_internal_fn.selectPoint = function (target, d, i) {
                var $$ = this,
                    config = $$.config,
                    cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
                    cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
                    r = $$.pointSelectR.bind($$);
                config.data_onselected.call($$.api, d, target.node());
                // add selected-circle on low layer g
                $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr("class", function () {
                    return $$.generateClass(CLASS.selectedCircle, i);
                }).attr("cx", cx).attr("cy", cy).attr("stroke", function () {
                    return $$.color(d);
                }).attr("r", function (d) {
                    return $$.pointSelectR(d) * 1.4;
                }).transition().duration(100).attr("r", r);
            };
            c3_chart_internal_fn.unselectPoint = function (target, d, i) {
                var $$ = this;
                $$.config.data_onunselected.call($$.api, d, target.node());
                // remove selected-circle from low layer g
                $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();
            };
            c3_chart_internal_fn.togglePoint = function (selected, target, d, i) {
                selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
            };
            c3_chart_internal_fn.selectPath = function (target, d) {
                var $$ = this;
                $$.config.data_onselected.call($$, d, target.node());
                if ($$.config.interaction_brighten) {
                    target.transition().duration(100).style("fill", function () {
                        return $$.d3.rgb($$.color(d)).brighter(0.75);
                    });
                }
            };
            c3_chart_internal_fn.unselectPath = function (target, d) {
                var $$ = this;
                $$.config.data_onunselected.call($$, d, target.node());
                if ($$.config.interaction_brighten) {
                    target.transition().duration(100).style("fill", function () {
                        return $$.color(d);
                    });
                }
            };
            c3_chart_internal_fn.togglePath = function (selected, target, d, i) {
                selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
            };
            c3_chart_internal_fn.getToggle = function (that, d) {
                var $$ = this,
                    toggle;
                if (that.nodeName === 'circle') {
                    if ($$.isStepType(d)) {
                        // circle is hidden in step chart, so treat as within the click area
                        toggle = function () {}; // TODO: how to select step chart?
                    } else {
                        toggle = $$.togglePoint;
                    }
                } else if (that.nodeName === 'path') {
                    toggle = $$.togglePath;
                }
                return toggle;
            };
            c3_chart_internal_fn.toggleShape = function (that, d, i) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    shape = d3.select(that),
                    isSelected = shape.classed(CLASS.SELECTED),
                    toggle = $$.getToggle(that, d).bind($$);

                if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
                    if (!config.data_selection_multiple) {
                        $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : "")).selectAll('.' + CLASS.shape).each(function (d, i) {
                            var shape = d3.select(this);
                            if (shape.classed(CLASS.SELECTED)) {
                                toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                            }
                        });
                    }
                    shape.classed(CLASS.SELECTED, !isSelected);
                    toggle(!isSelected, shape, d, i);
                }
            };

            c3_chart_internal_fn.initBrush = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.brush = d3.svg.brush().on("brush", function () {
                    $$.redrawForBrush();
                });
                $$.brush.update = function () {
                    if ($$.context) {
                        $$.context.select('.' + CLASS.brush).call(this);
                    }
                    return this;
                };
                $$.brush.scale = function (scale) {
                    return $$.config.axis_rotated ? this.y(scale) : this.x(scale);
                };
            };
            c3_chart_internal_fn.initSubchart = function () {
                var $$ = this,
                    config = $$.config,
                    context = $$.context = $$.svg.append("g").attr("transform", $$.getTranslate('context')),
                    visibility = config.subchart_show ? 'visible' : 'hidden';

                context.style('visibility', visibility);

                // Define g for chart area
                context.append('g').attr("clip-path", $$.clipPathForSubchart).attr('class', CLASS.chart);

                // Define g for bar chart area
                context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);

                // Define g for line chart area
                context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);

                // Add extent rect for Brush
                context.append("g").attr("clip-path", $$.clipPath).attr("class", CLASS.brush).call($$.brush);

                // ATTENTION: This must be called AFTER chart added
                // Add Axis
                $$.axes.subx = context.append("g").attr("class", CLASS.axisX).attr("transform", $$.getTranslate('subx')).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : 'hidden');
            };
            c3_chart_internal_fn.updateTargetsForSubchart = function (targets) {
                var $$ = this,
                    context = $$.context,
                    config = $$.config,
                    contextLineEnter,
                    contextLineUpdate,
                    contextBarEnter,
                    contextBarUpdate,
                    classChartBar = $$.classChartBar.bind($$),
                    classBars = $$.classBars.bind($$),
                    classChartLine = $$.classChartLine.bind($$),
                    classLines = $$.classLines.bind($$),
                    classAreas = $$.classAreas.bind($$);

                if (config.subchart_show) {
                    //-- Bar --//
                    contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);
                    contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar);
                    // Bars for each data
                    contextBarEnter.append('g').attr("class", classBars);

                    //-- Line --//
                    contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);
                    contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine);
                    // Lines for each data
                    contextLineEnter.append("g").attr("class", classLines);
                    // Area
                    contextLineEnter.append("g").attr("class", classAreas);

                    //-- Brush --//
                    context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
                }
            };
            c3_chart_internal_fn.updateBarForSubchart = function (durationForExit) {
                var $$ = this;
                $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));
                $$.contextBar.enter().append('path').attr("class", $$.classBar.bind($$)).style("stroke", 'none').style("fill", $$.color);
                $$.contextBar.style("opacity", $$.initialOpacity.bind($$));
                $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {
                (withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);
            };
            c3_chart_internal_fn.updateLineForSubchart = function (durationForExit) {
                var $$ = this;
                $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
                $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);
                $$.contextLine.style("opacity", $$.initialOpacity.bind($$));
                $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {
                (withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine).attr("d", drawLineOnSub).style('opacity', 1);
            };
            c3_chart_internal_fn.updateAreaForSubchart = function (durationForExit) {
                var $$ = this,
                    d3 = $$.d3;
                $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
                $$.contextArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
                    $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
                });
                $$.contextArea.style("opacity", 0);
                $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {
                (withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
            };
            c3_chart_internal_fn.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    drawAreaOnSub,
                    drawBarOnSub,
                    drawLineOnSub;

                $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden');

                // subchart
                if (config.subchart_show) {
                    // reflect main chart to extent on subchart if zoomed
                    if (d3.event && d3.event.type === 'zoom') {
                        $$.brush.extent($$.x.orgDomain()).update();
                    }
                    // update subchart elements if needed
                    if (withSubchart) {

                        // extent rect
                        if (!$$.brush.empty()) {
                            $$.brush.extent($$.x.orgDomain()).update();
                        }
                        // setup drawer - MEMO: this must be called after axis updated
                        drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
                        drawBarOnSub = $$.generateDrawBar(barIndices, true);
                        drawLineOnSub = $$.generateDrawLine(lineIndices, true);

                        $$.updateBarForSubchart(duration);
                        $$.updateLineForSubchart(duration);
                        $$.updateAreaForSubchart(duration);

                        $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
                        $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
                        $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
                    }
                }
            };
            c3_chart_internal_fn.redrawForBrush = function () {
                var $$ = this,
                    x = $$.x;
                $$.redraw({
                    withTransition: false,
                    withY: $$.config.zoom_rescale,
                    withSubchart: false,
                    withUpdateXDomain: true,
                    withDimension: false
                });
                $$.config.subchart_onbrush.call($$.api, x.orgDomain());
            };
            c3_chart_internal_fn.transformContext = function (withTransition, transitions) {
                var $$ = this,
                    subXAxis;
                if (transitions && transitions.axisSubX) {
                    subXAxis = transitions.axisSubX;
                } else {
                    subXAxis = $$.context.select('.' + CLASS.axisX);
                    if (withTransition) {
                        subXAxis = subXAxis.transition();
                    }
                }
                $$.context.attr("transform", $$.getTranslate('context'));
                subXAxis.attr("transform", $$.getTranslate('subx'));
            };
            c3_chart_internal_fn.getDefaultExtent = function () {
                var $$ = this,
                    config = $$.config,
                    extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;
                if ($$.isTimeSeries()) {
                    extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];
                }
                return extent;
            };

            c3_chart_internal_fn.initZoom = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    startEvent;

                $$.zoom = d3.behavior.zoom().on("zoomstart", function () {
                    startEvent = d3.event.sourceEvent;
                    $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;
                    config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
                }).on("zoom", function () {
                    $$.redrawForZoom.call($$);
                }).on('zoomend', function () {
                    var event = d3.event.sourceEvent;
                    // if click, do nothing. otherwise, click interaction will be canceled.
                    if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {
                        return;
                    }
                    $$.redrawEventRect();
                    $$.updateZoom();
                    config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
                });
                $$.zoom.scale = function (scale) {
                    return config.axis_rotated ? this.y(scale) : this.x(scale);
                };
                $$.zoom.orgScaleExtent = function () {
                    var extent = config.zoom_extent ? config.zoom_extent : [1, 10];
                    return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
                };
                $$.zoom.updateScaleExtent = function () {
                    var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
                        extent = this.orgScaleExtent();
                    this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);
                    return this;
                };
            };
            c3_chart_internal_fn.getZoomDomain = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),
                    max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
                return [min, max];
            };
            c3_chart_internal_fn.updateZoom = function () {
                var $$ = this,
                    z = $$.config.zoom_enabled ? $$.zoom : function () {};
                $$.main.select('.' + CLASS.zoomRect).call(z).on("dblclick.zoom", null);
                $$.main.selectAll('.' + CLASS.eventRect).call(z).on("dblclick.zoom", null);
            };
            c3_chart_internal_fn.redrawForZoom = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    zoom = $$.zoom,
                    x = $$.x;
                if (!config.zoom_enabled) {
                    return;
                }
                if ($$.filterTargetsToShow($$.data.targets).length === 0) {
                    return;
                }
                if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {
                    x.domain(zoom.altDomain);
                    zoom.scale(x).updateScaleExtent();
                    return;
                }
                if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
                    x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
                }
                $$.redraw({
                    withTransition: false,
                    withY: config.zoom_rescale,
                    withSubchart: false,
                    withEventRect: false,
                    withDimension: false
                });
                if (d3.event.sourceEvent.type === 'mousemove') {
                    $$.cancelClick = true;
                }
                config.zoom_onzoom.call($$.api, x.orgDomain());
            };

            c3_chart_internal_fn.generateColor = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    colors = config.data_colors,
                    pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),
                    callback = config.data_color,
                    ids = [];

                return function (d) {
                    var id = d.id || d.data && d.data.id || d,
                        color;

                    // if callback function is provided
                    if (colors[id] instanceof Function) {
                        color = colors[id](d);
                    }
                    // if specified, choose that color
                    else if (colors[id]) {
                            color = colors[id];
                        }
                        // if not specified, choose from pattern
                        else {
                                if (ids.indexOf(id) < 0) {
                                    ids.push(id);
                                }
                                color = pattern[ids.indexOf(id) % pattern.length];
                                colors[id] = color;
                            }
                    return callback instanceof Function ? callback(color, d) : color;
                };
            };
            c3_chart_internal_fn.generateLevelColor = function () {
                var $$ = this,
                    config = $$.config,
                    colors = config.color_pattern,
                    threshold = config.color_threshold,
                    asValue = threshold.unit === 'value',
                    values = threshold.values && threshold.values.length ? threshold.values : [],
                    max = threshold.max || 100;
                return notEmpty(config.color_threshold) ? function (value) {
                    var i,
                        v,
                        color = colors[colors.length - 1];
                    for (i = 0; i < values.length; i++) {
                        v = asValue ? value : value * 100 / max;
                        if (v < values[i]) {
                            color = colors[i];
                            break;
                        }
                    }
                    return color;
                } : null;
            };

            c3_chart_internal_fn.getYFormat = function (forArc) {
                var $$ = this,
                    formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,
                    formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
                return function (v, ratio, id) {
                    var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
                    return format.call($$, v, ratio);
                };
            };
            c3_chart_internal_fn.yFormat = function (v) {
                var $$ = this,
                    config = $$.config,
                    format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;
                return format(v);
            };
            c3_chart_internal_fn.y2Format = function (v) {
                var $$ = this,
                    config = $$.config,
                    format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;
                return format(v);
            };
            c3_chart_internal_fn.defaultValueFormat = function (v) {
                return isValue(v) ? +v : "";
            };
            c3_chart_internal_fn.defaultArcValueFormat = function (v, ratio) {
                return (ratio * 100).toFixed(1) + '%';
            };
            c3_chart_internal_fn.dataLabelFormat = function (targetId) {
                var $$ = this,
                    data_labels = $$.config.data_labels,
                    format,
                    defaultFormat = function (v) {
                    return isValue(v) ? +v : "";
                };
                // find format according to axis id
                if (typeof data_labels.format === 'function') {
                    format = data_labels.format;
                } else if (typeof data_labels.format === 'object') {
                    if (data_labels.format[targetId]) {
                        format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];
                    } else {
                        format = function () {
                            return '';
                        };
                    }
                } else {
                    format = defaultFormat;
                }
                return format;
            };

            c3_chart_internal_fn.hasCaches = function (ids) {
                for (var i = 0; i < ids.length; i++) {
                    if (!(ids[i] in this.cache)) {
                        return false;
                    }
                }
                return true;
            };
            c3_chart_internal_fn.addCache = function (id, target) {
                this.cache[id] = this.cloneTarget(target);
            };
            c3_chart_internal_fn.getCaches = function (ids) {
                var targets = [],
                    i;
                for (i = 0; i < ids.length; i++) {
                    if (ids[i] in this.cache) {
                        targets.push(this.cloneTarget(this.cache[ids[i]]));
                    }
                }
                return targets;
            };

            var CLASS = c3_chart_internal_fn.CLASS = {
                target: 'c3-target',
                chart: 'c3-chart',
                chartLine: 'c3-chart-line',
                chartLines: 'c3-chart-lines',
                chartBar: 'c3-chart-bar',
                chartBars: 'c3-chart-bars',
                chartText: 'c3-chart-text',
                chartTexts: 'c3-chart-texts',
                chartArc: 'c3-chart-arc',
                chartArcs: 'c3-chart-arcs',
                chartArcsTitle: 'c3-chart-arcs-title',
                chartArcsBackground: 'c3-chart-arcs-background',
                chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
                chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
                chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
                selectedCircle: 'c3-selected-circle',
                selectedCircles: 'c3-selected-circles',
                eventRect: 'c3-event-rect',
                eventRects: 'c3-event-rects',
                eventRectsSingle: 'c3-event-rects-single',
                eventRectsMultiple: 'c3-event-rects-multiple',
                zoomRect: 'c3-zoom-rect',
                brush: 'c3-brush',
                focused: 'c3-focused',
                defocused: 'c3-defocused',
                region: 'c3-region',
                regions: 'c3-regions',
                title: 'c3-title',
                tooltipContainer: 'c3-tooltip-container',
                tooltip: 'c3-tooltip',
                tooltipName: 'c3-tooltip-name',
                shape: 'c3-shape',
                shapes: 'c3-shapes',
                line: 'c3-line',
                lines: 'c3-lines',
                bar: 'c3-bar',
                bars: 'c3-bars',
                circle: 'c3-circle',
                circles: 'c3-circles',
                arc: 'c3-arc',
                arcs: 'c3-arcs',
                area: 'c3-area',
                areas: 'c3-areas',
                empty: 'c3-empty',
                text: 'c3-text',
                texts: 'c3-texts',
                gaugeValue: 'c3-gauge-value',
                grid: 'c3-grid',
                gridLines: 'c3-grid-lines',
                xgrid: 'c3-xgrid',
                xgrids: 'c3-xgrids',
                xgridLine: 'c3-xgrid-line',
                xgridLines: 'c3-xgrid-lines',
                xgridFocus: 'c3-xgrid-focus',
                ygrid: 'c3-ygrid',
                ygrids: 'c3-ygrids',
                ygridLine: 'c3-ygrid-line',
                ygridLines: 'c3-ygrid-lines',
                axis: 'c3-axis',
                axisX: 'c3-axis-x',
                axisXLabel: 'c3-axis-x-label',
                axisY: 'c3-axis-y',
                axisYLabel: 'c3-axis-y-label',
                axisY2: 'c3-axis-y2',
                axisY2Label: 'c3-axis-y2-label',
                legendBackground: 'c3-legend-background',
                legendItem: 'c3-legend-item',
                legendItemEvent: 'c3-legend-item-event',
                legendItemTile: 'c3-legend-item-tile',
                legendItemHidden: 'c3-legend-item-hidden',
                legendItemFocused: 'c3-legend-item-focused',
                dragarea: 'c3-dragarea',
                EXPANDED: '_expanded_',
                SELECTED: '_selected_',
                INCLUDED: '_included_'
            };
            c3_chart_internal_fn.generateClass = function (prefix, targetId) {
                return " " + prefix + " " + prefix + this.getTargetSelectorSuffix(targetId);
            };
            c3_chart_internal_fn.classText = function (d) {
                return this.generateClass(CLASS.text, d.index);
            };
            c3_chart_internal_fn.classTexts = function (d) {
                return this.generateClass(CLASS.texts, d.id);
            };
            c3_chart_internal_fn.classShape = function (d) {
                return this.generateClass(CLASS.shape, d.index);
            };
            c3_chart_internal_fn.classShapes = function (d) {
                return this.generateClass(CLASS.shapes, d.id);
            };
            c3_chart_internal_fn.classLine = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.line, d.id);
            };
            c3_chart_internal_fn.classLines = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
            };
            c3_chart_internal_fn.classCircle = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
            };
            c3_chart_internal_fn.classCircles = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
            };
            c3_chart_internal_fn.classBar = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
            };
            c3_chart_internal_fn.classBars = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
            };
            c3_chart_internal_fn.classArc = function (d) {
                return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
            };
            c3_chart_internal_fn.classArcs = function (d) {
                return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
            };
            c3_chart_internal_fn.classArea = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.area, d.id);
            };
            c3_chart_internal_fn.classAreas = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
            };
            c3_chart_internal_fn.classRegion = function (d, i) {
                return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');
            };
            c3_chart_internal_fn.classEvent = function (d) {
                return this.generateClass(CLASS.eventRect, d.index);
            };
            c3_chart_internal_fn.classTarget = function (id) {
                var $$ = this;
                var additionalClassSuffix = $$.config.data_classes[id],
                    additionalClass = '';
                if (additionalClassSuffix) {
                    additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
                }
                return $$.generateClass(CLASS.target, id) + additionalClass;
            };
            c3_chart_internal_fn.classFocus = function (d) {
                return this.classFocused(d) + this.classDefocused(d);
            };
            c3_chart_internal_fn.classFocused = function (d) {
                return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
            };
            c3_chart_internal_fn.classDefocused = function (d) {
                return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');
            };
            c3_chart_internal_fn.classChartText = function (d) {
                return CLASS.chartText + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartLine = function (d) {
                return CLASS.chartLine + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartBar = function (d) {
                return CLASS.chartBar + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartArc = function (d) {
                return CLASS.chartArc + this.classTarget(d.data.id);
            };
            c3_chart_internal_fn.getTargetSelectorSuffix = function (targetId) {
                return targetId || targetId === 0 ? ('-' + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : '';
            };
            c3_chart_internal_fn.selectorTarget = function (id, prefix) {
                return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
            };
            c3_chart_internal_fn.selectorTargets = function (ids, prefix) {
                var $$ = this;
                ids = ids || [];
                return ids.length ? ids.map(function (id) {
                    return $$.selectorTarget(id, prefix);
                }) : null;
            };
            c3_chart_internal_fn.selectorLegend = function (id) {
                return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
            };
            c3_chart_internal_fn.selectorLegends = function (ids) {
                var $$ = this;
                return ids && ids.length ? ids.map(function (id) {
                    return $$.selectorLegend(id);
                }) : null;
            };

            var isValue = c3_chart_internal_fn.isValue = function (v) {
                return v || v === 0;
            },
                isFunction = c3_chart_internal_fn.isFunction = function (o) {
                return typeof o === 'function';
            },
                isString = c3_chart_internal_fn.isString = function (o) {
                return typeof o === 'string';
            },
                isUndefined = c3_chart_internal_fn.isUndefined = function (v) {
                return typeof v === 'undefined';
            },
                isDefined = c3_chart_internal_fn.isDefined = function (v) {
                return typeof v !== 'undefined';
            },
                ceil10 = c3_chart_internal_fn.ceil10 = function (v) {
                return Math.ceil(v / 10) * 10;
            },
                asHalfPixel = c3_chart_internal_fn.asHalfPixel = function (n) {
                return Math.ceil(n) + 0.5;
            },
                diffDomain = c3_chart_internal_fn.diffDomain = function (d) {
                return d[1] - d[0];
            },
                isEmpty = c3_chart_internal_fn.isEmpty = function (o) {
                return typeof o === 'undefined' || o === null || isString(o) && o.length === 0 || typeof o === 'object' && Object.keys(o).length === 0;
            },
                notEmpty = c3_chart_internal_fn.notEmpty = function (o) {
                return !c3_chart_internal_fn.isEmpty(o);
            },
                getOption = c3_chart_internal_fn.getOption = function (options, key, defaultValue) {
                return isDefined(options[key]) ? options[key] : defaultValue;
            },
                hasValue = c3_chart_internal_fn.hasValue = function (dict, value) {
                var found = false;
                Object.keys(dict).forEach(function (key) {
                    if (dict[key] === value) {
                        found = true;
                    }
                });
                return found;
            },
                sanitise = c3_chart_internal_fn.sanitise = function (str) {
                return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str;
            },
                getPathBox = c3_chart_internal_fn.getPathBox = function (path) {
                var box = path.getBoundingClientRect(),
                    items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],
                    minX = items[0].x,
                    minY = Math.min(items[0].y, items[1].y);
                return { x: minX, y: minY, width: box.width, height: box.height };
            };

            c3_chart_fn.focus = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();
                this.defocus();
                candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
                if ($$.hasArcType()) {
                    $$.expandArc(targetIds);
                }
                $$.toggleFocusLegend(targetIds, true);

                $$.focusedTargetIds = targetIds;
                $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };

            c3_chart_fn.defocus = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
                if ($$.hasArcType()) {
                    $$.unexpandArc(targetIds);
                }
                $$.toggleFocusLegend(targetIds, false);

                $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
                $$.defocusedTargetIds = targetIds;
            };

            c3_chart_fn.revert = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets

                candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
                if ($$.hasArcType()) {
                    $$.unexpandArc(targetIds);
                }
                if ($$.config.legend_show) {
                    $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
                    $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
                        return $$.d3.select(this).classed(CLASS.legendItemFocused);
                    }).classed(CLASS.legendItemFocused, false);
                }

                $$.focusedTargetIds = [];
                $$.defocusedTargetIds = [];
            };

            c3_chart_fn.show = function (targetIds, options) {
                var $$ = this.internal,
                    targets;

                targetIds = $$.mapToTargetIds(targetIds);
                options = options || {};

                $$.removeHiddenTargetIds(targetIds);
                targets = $$.svg.selectAll($$.selectorTargets(targetIds));

                targets.transition().style('opacity', 1, 'important').call($$.endall, function () {
                    targets.style('opacity', null).style('opacity', 1);
                });

                if (options.withLegend) {
                    $$.showLegend(targetIds);
                }

                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
            };

            c3_chart_fn.hide = function (targetIds, options) {
                var $$ = this.internal,
                    targets;

                targetIds = $$.mapToTargetIds(targetIds);
                options = options || {};

                $$.addHiddenTargetIds(targetIds);
                targets = $$.svg.selectAll($$.selectorTargets(targetIds));

                targets.transition().style('opacity', 0, 'important').call($$.endall, function () {
                    targets.style('opacity', null).style('opacity', 0);
                });

                if (options.withLegend) {
                    $$.hideLegend(targetIds);
                }

                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
            };

            c3_chart_fn.toggle = function (targetIds, options) {
                var that = this,
                    $$ = this.internal;
                $$.mapToTargetIds(targetIds).forEach(function (targetId) {
                    $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
                });
            };

            c3_chart_fn.zoom = function (domain) {
                var $$ = this.internal;
                if (domain) {
                    if ($$.isTimeSeries()) {
                        domain = domain.map(function (x) {
                            return $$.parseDate(x);
                        });
                    }
                    $$.brush.extent(domain);
                    $$.redraw({ withUpdateXDomain: true, withY: $$.config.zoom_rescale });
                    $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
                }
                return $$.brush.extent();
            };
            c3_chart_fn.zoom.enable = function (enabled) {
                var $$ = this.internal;
                $$.config.zoom_enabled = enabled;
                $$.updateAndRedraw();
            };
            c3_chart_fn.unzoom = function () {
                var $$ = this.internal;
                $$.brush.clear().update();
                $$.redraw({ withUpdateXDomain: true });
            };

            c3_chart_fn.zoom.max = function (max) {
                var $$ = this.internal,
                    config = $$.config,
                    d3 = $$.d3;
                if (max === 0 || max) {
                    config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
                } else {
                    return config.zoom_x_max;
                }
            };

            c3_chart_fn.zoom.min = function (min) {
                var $$ = this.internal,
                    config = $$.config,
                    d3 = $$.d3;
                if (min === 0 || min) {
                    config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
                } else {
                    return config.zoom_x_min;
                }
            };

            c3_chart_fn.zoom.range = function (range) {
                if (arguments.length) {
                    if (isDefined(range.max)) {
                        this.domain.max(range.max);
                    }
                    if (isDefined(range.min)) {
                        this.domain.min(range.min);
                    }
                } else {
                    return {
                        max: this.domain.max(),
                        min: this.domain.min()
                    };
                }
            };

            c3_chart_fn.load = function (args) {
                var $$ = this.internal,
                    config = $$.config;
                // update xs if specified
                if (args.xs) {
                    $$.addXs(args.xs);
                }
                // update names if exists
                if ('names' in args) {
                    c3_chart_fn.data.names.bind(this)(args.names);
                }
                // update classes if exists
                if ('classes' in args) {
                    Object.keys(args.classes).forEach(function (id) {
                        config.data_classes[id] = args.classes[id];
                    });
                }
                // update categories if exists
                if ('categories' in args && $$.isCategorized()) {
                    config.axis_x_categories = args.categories;
                }
                // update axes if exists
                if ('axes' in args) {
                    Object.keys(args.axes).forEach(function (id) {
                        config.data_axes[id] = args.axes[id];
                    });
                }
                // update colors if exists
                if ('colors' in args) {
                    Object.keys(args.colors).forEach(function (id) {
                        config.data_colors[id] = args.colors[id];
                    });
                }
                // use cache if exists
                if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
                    $$.load($$.getCaches(args.cacheIds), args.done);
                    return;
                }
                // unload if needed
                if ('unload' in args) {
                    // TODO: do not unload if target will load (included in url/rows/columns)
                    $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {
                        $$.loadFromArgs(args);
                    });
                } else {
                    $$.loadFromArgs(args);
                }
            };

            c3_chart_fn.unload = function (args) {
                var $$ = this.internal;
                args = args || {};
                if (args instanceof Array) {
                    args = { ids: args };
                } else if (typeof args === 'string') {
                    args = { ids: [args] };
                }
                $$.unload($$.mapToTargetIds(args.ids), function () {
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
                    if (args.done) {
                        args.done();
                    }
                });
            };

            c3_chart_fn.flow = function (args) {
                var $$ = this.internal,
                    targets,
                    data,
                    notfoundIds = [],
                    orgDataCount = $$.getMaxDataCount(),
                    dataCount,
                    domain,
                    baseTarget,
                    baseValue,
                    length = 0,
                    tail = 0,
                    diff,
                    to;

                if (args.json) {
                    data = $$.convertJsonToData(args.json, args.keys);
                } else if (args.rows) {
                    data = $$.convertRowsToData(args.rows);
                } else if (args.columns) {
                    data = $$.convertColumnsToData(args.columns);
                } else {
                    return;
                }
                targets = $$.convertDataToTargets(data, true);

                // Update/Add data
                $$.data.targets.forEach(function (t) {
                    var found = false,
                        i,
                        j;
                    for (i = 0; i < targets.length; i++) {
                        if (t.id === targets[i].id) {
                            found = true;

                            if (t.values[t.values.length - 1]) {
                                tail = t.values[t.values.length - 1].index + 1;
                            }
                            length = targets[i].values.length;

                            for (j = 0; j < length; j++) {
                                targets[i].values[j].index = tail + j;
                                if (!$$.isTimeSeries()) {
                                    targets[i].values[j].x = tail + j;
                                }
                            }
                            t.values = t.values.concat(targets[i].values);

                            targets.splice(i, 1);
                            break;
                        }
                    }
                    if (!found) {
                        notfoundIds.push(t.id);
                    }
                });

                // Append null for not found targets
                $$.data.targets.forEach(function (t) {
                    var i, j;
                    for (i = 0; i < notfoundIds.length; i++) {
                        if (t.id === notfoundIds[i]) {
                            tail = t.values[t.values.length - 1].index + 1;
                            for (j = 0; j < length; j++) {
                                t.values.push({
                                    id: t.id,
                                    index: tail + j,
                                    x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                                    value: null
                                });
                            }
                        }
                    }
                });

                // Generate null values for new target
                if ($$.data.targets.length) {
                    targets.forEach(function (t) {
                        var i,
                            missing = [];
                        for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
                            missing.push({
                                id: t.id,
                                index: i,
                                x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
                                value: null
                            });
                        }
                        t.values.forEach(function (v) {
                            v.index += tail;
                            if (!$$.isTimeSeries()) {
                                v.x += tail;
                            }
                        });
                        t.values = missing.concat(t.values);
                    });
                }
                $$.data.targets = $$.data.targets.concat(targets); // add remained

                // check data count because behavior needs to change when it's only one
                dataCount = $$.getMaxDataCount();
                baseTarget = $$.data.targets[0];
                baseValue = baseTarget.values[0];

                // Update length to flow if needed
                if (isDefined(args.to)) {
                    length = 0;
                    to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
                    baseTarget.values.forEach(function (v) {
                        if (v.x < to) {
                            length++;
                        }
                    });
                } else if (isDefined(args.length)) {
                    length = args.length;
                }

                // If only one data, update the domain to flow from left edge of the chart
                if (!orgDataCount) {
                    if ($$.isTimeSeries()) {
                        if (baseTarget.values.length > 1) {
                            diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
                        } else {
                            diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
                        }
                    } else {
                        diff = 1;
                    }
                    domain = [baseValue.x - diff, baseValue.x];
                    $$.updateXDomain(null, true, true, false, domain);
                } else if (orgDataCount === 1) {
                    if ($$.isTimeSeries()) {
                        diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
                        domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
                        $$.updateXDomain(null, true, true, false, domain);
                    }
                }

                // Set targets
                $$.updateTargets($$.data.targets);

                // Redraw with new targets
                $$.redraw({
                    flow: {
                        index: baseValue.index,
                        length: length,
                        duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
                        done: args.done,
                        orgDataCount: orgDataCount
                    },
                    withLegend: true,
                    withTransition: orgDataCount > 1,
                    withTrimXDomain: false,
                    withUpdateXAxis: true
                });
            };

            c3_chart_internal_fn.generateFlow = function (args) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;

                return function () {
                    var targets = args.targets,
                        flow = args.flow,
                        drawBar = args.drawBar,
                        drawLine = args.drawLine,
                        drawArea = args.drawArea,
                        cx = args.cx,
                        cy = args.cy,
                        xv = args.xv,
                        xForText = args.xForText,
                        yForText = args.yForText,
                        duration = args.duration;

                    var translateX,
                        scaleX = 1,
                        transform,
                        flowIndex = flow.index,
                        flowLength = flow.length,
                        flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
                        flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
                        orgDomain = $$.x.domain(),
                        domain,
                        durationForFlow = flow.duration || duration,
                        done = flow.done || function () {},
                        wait = $$.generateWait();

                    var xgrid = $$.xgrid || d3.selectAll([]),
                        xgridLines = $$.xgridLines || d3.selectAll([]),
                        mainRegion = $$.mainRegion || d3.selectAll([]),
                        mainText = $$.mainText || d3.selectAll([]),
                        mainBar = $$.mainBar || d3.selectAll([]),
                        mainLine = $$.mainLine || d3.selectAll([]),
                        mainArea = $$.mainArea || d3.selectAll([]),
                        mainCircle = $$.mainCircle || d3.selectAll([]);

                    // set flag
                    $$.flowing = true;

                    // remove head data after rendered
                    $$.data.targets.forEach(function (d) {
                        d.values.splice(0, flowLength);
                    });

                    // update x domain to generate axis elements for flow
                    domain = $$.updateXDomain(targets, true, true);
                    // update elements related to x scale
                    if ($$.updateXGrid) {
                        $$.updateXGrid(true);
                    }

                    // generate transform to flow
                    if (!flow.orgDataCount) {
                        // if empty
                        if ($$.data.targets[0].values.length !== 1) {
                            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                        } else {
                            if ($$.isTimeSeries()) {
                                flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
                                flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
                                translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                            } else {
                                translateX = diffDomain(domain) / 2;
                            }
                        }
                    } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {
                        translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                    } else {
                        if ($$.isTimeSeries()) {
                            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                        } else {
                            translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                        }
                    }
                    scaleX = diffDomain(orgDomain) / diffDomain(domain);
                    transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';

                    $$.hideXGridFocus();

                    d3.transition().ease('linear').duration(durationForFlow).each(function () {
                        wait.add($$.axes.x.transition().call($$.xAxis));
                        wait.add(mainBar.transition().attr('transform', transform));
                        wait.add(mainLine.transition().attr('transform', transform));
                        wait.add(mainArea.transition().attr('transform', transform));
                        wait.add(mainCircle.transition().attr('transform', transform));
                        wait.add(mainText.transition().attr('transform', transform));
                        wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));
                        wait.add(xgrid.transition().attr('transform', transform));
                        wait.add(xgridLines.transition().attr('transform', transform));
                    }).call(wait, function () {
                        var i,
                            shapes = [],
                            texts = [],
                            eventRects = [];

                        // remove flowed elements
                        if (flowLength) {
                            for (i = 0; i < flowLength; i++) {
                                shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
                                texts.push('.' + CLASS.text + '-' + (flowIndex + i));
                                eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));
                            }
                            $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();
                            $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();
                            $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();
                            $$.svg.select('.' + CLASS.xgrid).remove();
                        }

                        // draw again for removing flowed elements and reverting attr
                        xgrid.attr('transform', null).attr($$.xgridAttr);
                        xgridLines.attr('transform', null);
                        xgridLines.select('line').attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv);
                        xgridLines.select('text').attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv);
                        mainBar.attr('transform', null).attr("d", drawBar);
                        mainLine.attr('transform', null).attr("d", drawLine);
                        mainArea.attr('transform', null).attr("d", drawArea);
                        mainCircle.attr('transform', null).attr("cx", cx).attr("cy", cy);
                        mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));
                        mainRegion.attr('transform', null);
                        mainRegion.select('rect').filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));

                        if (config.interaction_enabled) {
                            $$.redrawEventRect();
                        }

                        // callback for end of flow
                        done();

                        $$.flowing = false;
                    });
                };
            };

            c3_chart_fn.selected = function (targetId) {
                var $$ = this.internal,
                    d3 = $$.d3;
                return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function () {
                    return d3.select(this).classed(CLASS.SELECTED);
                }).map(function (d) {
                    return d.map(function (d) {
                        var data = d.__data__;return data.data ? data.data : data;
                    });
                }));
            };
            c3_chart_fn.select = function (ids, indices, resetOther) {
                var $$ = this.internal,
                    d3 = $$.d3,
                    config = $$.config;
                if (!config.data_selection_enabled) {
                    return;
                }
                $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
                    var shape = d3.select(this),
                        id = d.data ? d.data.id : d.id,
                        toggle = $$.getToggle(this, d).bind($$),
                        isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                        isTargetIndex = !indices || indices.indexOf(i) >= 0,
                        isSelected = shape.classed(CLASS.SELECTED);
                    // line/area selection not supported yet
                    if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                        return;
                    }
                    if (isTargetId && isTargetIndex) {
                        if (config.data_selection_isselectable(d) && !isSelected) {
                            toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
                        }
                    } else if (isDefined(resetOther) && resetOther) {
                        if (isSelected) {
                            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                        }
                    }
                });
            };
            c3_chart_fn.unselect = function (ids, indices) {
                var $$ = this.internal,
                    d3 = $$.d3,
                    config = $$.config;
                if (!config.data_selection_enabled) {
                    return;
                }
                $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
                    var shape = d3.select(this),
                        id = d.data ? d.data.id : d.id,
                        toggle = $$.getToggle(this, d).bind($$),
                        isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                        isTargetIndex = !indices || indices.indexOf(i) >= 0,
                        isSelected = shape.classed(CLASS.SELECTED);
                    // line/area selection not supported yet
                    if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                        return;
                    }
                    if (isTargetId && isTargetIndex) {
                        if (config.data_selection_isselectable(d)) {
                            if (isSelected) {
                                toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                            }
                        }
                    }
                });
            };

            c3_chart_fn.transform = function (type, targetIds) {
                var $$ = this.internal,
                    options = ['pie', 'donut'].indexOf(type) >= 0 ? { withTransform: true } : null;
                $$.transformTo(targetIds, type, options);
            };

            c3_chart_internal_fn.transformTo = function (targetIds, type, optionsForRedraw) {
                var $$ = this,
                    withTransitionForAxis = !$$.hasArcType(),
                    options = optionsForRedraw || { withTransitionForAxis: withTransitionForAxis };
                options.withTransitionForTransform = false;
                $$.transiting = false;
                $$.setTargetType(targetIds, type);
                $$.updateTargets($$.data.targets); // this is needed when transforming to arc
                $$.updateAndRedraw(options);
            };

            c3_chart_fn.groups = function (groups) {
                var $$ = this.internal,
                    config = $$.config;
                if (isUndefined(groups)) {
                    return config.data_groups;
                }
                config.data_groups = groups;
                $$.redraw();
                return config.data_groups;
            };

            c3_chart_fn.xgrids = function (grids) {
                var $$ = this.internal,
                    config = $$.config;
                if (!grids) {
                    return config.grid_x_lines;
                }
                config.grid_x_lines = grids;
                $$.redrawWithoutRescale();
                return config.grid_x_lines;
            };
            c3_chart_fn.xgrids.add = function (grids) {
                var $$ = this.internal;
                return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
            };
            c3_chart_fn.xgrids.remove = function (params) {
                // TODO: multiple
                var $$ = this.internal;
                $$.removeGridLines(params, true);
            };

            c3_chart_fn.ygrids = function (grids) {
                var $$ = this.internal,
                    config = $$.config;
                if (!grids) {
                    return config.grid_y_lines;
                }
                config.grid_y_lines = grids;
                $$.redrawWithoutRescale();
                return config.grid_y_lines;
            };
            c3_chart_fn.ygrids.add = function (grids) {
                var $$ = this.internal;
                return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
            };
            c3_chart_fn.ygrids.remove = function (params) {
                // TODO: multiple
                var $$ = this.internal;
                $$.removeGridLines(params, false);
            };

            c3_chart_fn.regions = function (regions) {
                var $$ = this.internal,
                    config = $$.config;
                if (!regions) {
                    return config.regions;
                }
                config.regions = regions;
                $$.redrawWithoutRescale();
                return config.regions;
            };
            c3_chart_fn.regions.add = function (regions) {
                var $$ = this.internal,
                    config = $$.config;
                if (!regions) {
                    return config.regions;
                }
                config.regions = config.regions.concat(regions);
                $$.redrawWithoutRescale();
                return config.regions;
            };
            c3_chart_fn.regions.remove = function (options) {
                var $$ = this.internal,
                    config = $$.config,
                    duration,
                    classes,
                    regions;

                options = options || {};
                duration = $$.getOption(options, "duration", config.transition_duration);
                classes = $$.getOption(options, "classes", [CLASS.region]);

                regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {
                    return '.' + c;
                }));
                (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();

                config.regions = config.regions.filter(function (region) {
                    var found = false;
                    if (!region['class']) {
                        return true;
                    }
                    region['class'].split(' ').forEach(function (c) {
                        if (classes.indexOf(c) >= 0) {
                            found = true;
                        }
                    });
                    return !found;
                });

                return config.regions;
            };

            c3_chart_fn.data = function (targetIds) {
                var targets = this.internal.data.targets;
                return typeof targetIds === 'undefined' ? targets : targets.filter(function (t) {
                    return [].concat(targetIds).indexOf(t.id) >= 0;
                });
            };
            c3_chart_fn.data.shown = function (targetIds) {
                return this.internal.filterTargetsToShow(this.data(targetIds));
            };
            c3_chart_fn.data.values = function (targetId) {
                var targets,
                    values = null;
                if (targetId) {
                    targets = this.data(targetId);
                    values = targets[0] ? targets[0].values.map(function (d) {
                        return d.value;
                    }) : null;
                }
                return values;
            };
            c3_chart_fn.data.names = function (names) {
                this.internal.clearLegendItemTextBoxCache();
                return this.internal.updateDataAttributes('names', names);
            };
            c3_chart_fn.data.colors = function (colors) {
                return this.internal.updateDataAttributes('colors', colors);
            };
            c3_chart_fn.data.axes = function (axes) {
                return this.internal.updateDataAttributes('axes', axes);
            };

            c3_chart_fn.category = function (i, category) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length > 1) {
                    config.axis_x_categories[i] = category;
                    $$.redraw();
                }
                return config.axis_x_categories[i];
            };
            c3_chart_fn.categories = function (categories) {
                var $$ = this.internal,
                    config = $$.config;
                if (!arguments.length) {
                    return config.axis_x_categories;
                }
                config.axis_x_categories = categories;
                $$.redraw();
                return config.axis_x_categories;
            };

            // TODO: fix
            c3_chart_fn.color = function (id) {
                var $$ = this.internal;
                return $$.color(id); // more patterns
            };

            c3_chart_fn.x = function (x) {
                var $$ = this.internal;
                if (arguments.length) {
                    $$.updateTargetX($$.data.targets, x);
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                }
                return $$.data.xs;
            };
            c3_chart_fn.xs = function (xs) {
                var $$ = this.internal;
                if (arguments.length) {
                    $$.updateTargetXs($$.data.targets, xs);
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                }
                return $$.data.xs;
            };

            c3_chart_fn.axis = function () {};
            c3_chart_fn.axis.labels = function (labels) {
                var $$ = this.internal;
                if (arguments.length) {
                    Object.keys(labels).forEach(function (axisId) {
                        $$.axis.setLabelText(axisId, labels[axisId]);
                    });
                    $$.axis.updateLabels();
                }
                // TODO: return some values?
            };
            c3_chart_fn.axis.max = function (max) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length) {
                    if (typeof max === 'object') {
                        if (isValue(max.x)) {
                            config.axis_x_max = max.x;
                        }
                        if (isValue(max.y)) {
                            config.axis_y_max = max.y;
                        }
                        if (isValue(max.y2)) {
                            config.axis_y2_max = max.y2;
                        }
                    } else {
                        config.axis_y_max = config.axis_y2_max = max;
                    }
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                } else {
                    return {
                        x: config.axis_x_max,
                        y: config.axis_y_max,
                        y2: config.axis_y2_max
                    };
                }
            };
            c3_chart_fn.axis.min = function (min) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length) {
                    if (typeof min === 'object') {
                        if (isValue(min.x)) {
                            config.axis_x_min = min.x;
                        }
                        if (isValue(min.y)) {
                            config.axis_y_min = min.y;
                        }
                        if (isValue(min.y2)) {
                            config.axis_y2_min = min.y2;
                        }
                    } else {
                        config.axis_y_min = config.axis_y2_min = min;
                    }
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                } else {
                    return {
                        x: config.axis_x_min,
                        y: config.axis_y_min,
                        y2: config.axis_y2_min
                    };
                }
            };
            c3_chart_fn.axis.range = function (range) {
                if (arguments.length) {
                    if (isDefined(range.max)) {
                        this.axis.max(range.max);
                    }
                    if (isDefined(range.min)) {
                        this.axis.min(range.min);
                    }
                } else {
                    return {
                        max: this.axis.max(),
                        min: this.axis.min()
                    };
                }
            };

            c3_chart_fn.legend = function () {};
            c3_chart_fn.legend.show = function (targetIds) {
                var $$ = this.internal;
                $$.showLegend($$.mapToTargetIds(targetIds));
                $$.updateAndRedraw({ withLegend: true });
            };
            c3_chart_fn.legend.hide = function (targetIds) {
                var $$ = this.internal;
                $$.hideLegend($$.mapToTargetIds(targetIds));
                $$.updateAndRedraw({ withLegend: true });
            };

            c3_chart_fn.resize = function (size) {
                var $$ = this.internal,
                    config = $$.config;
                config.size_width = size ? size.width : null;
                config.size_height = size ? size.height : null;
                this.flush();
            };

            c3_chart_fn.flush = function () {
                var $$ = this.internal;
                $$.updateAndRedraw({ withLegend: true, withTransition: false, withTransitionForTransform: false });
            };

            c3_chart_fn.destroy = function () {
                var $$ = this.internal;

                window.clearInterval($$.intervalForObserveInserted);

                if ($$.resizeTimeout !== undefined) {
                    window.clearTimeout($$.resizeTimeout);
                }

                if (window.detachEvent) {
                    window.detachEvent('onresize', $$.resizeFunction);
                } else if (window.removeEventListener) {
                    window.removeEventListener('resize', $$.resizeFunction);
                } else {
                    var wrapper = window.onresize;
                    // check if no one else removed our wrapper and remove our resizeFunction from it
                    if (wrapper && wrapper.add && wrapper.remove) {
                        wrapper.remove($$.resizeFunction);
                    }
                }

                $$.selectChart.classed('c3', false).html("");

                // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.
                Object.keys($$).forEach(function (key) {
                    $$[key] = null;
                });

                return null;
            };

            c3_chart_fn.tooltip = function () {};
            c3_chart_fn.tooltip.show = function (args) {
                var $$ = this.internal,
                    index,
                    mouse;

                // determine mouse position on the chart
                if (args.mouse) {
                    mouse = args.mouse;
                }

                // determine focus data
                if (args.data) {
                    if ($$.isMultipleX()) {
                        // if multiple xs, target point will be determined by mouse
                        mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];
                        index = null;
                    } else {
                        // TODO: when tooltip_grouped = false
                        index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);
                    }
                } else if (typeof args.x !== 'undefined') {
                    index = $$.getIndexByX(args.x);
                } else if (typeof args.index !== 'undefined') {
                    index = args.index;
                }

                // emulate mouse events to show
                $$.dispatchEvent('mouseover', index, mouse);
                $$.dispatchEvent('mousemove', index, mouse);

                $$.config.tooltip_onshow.call($$, args.data);
            };
            c3_chart_fn.tooltip.hide = function () {
                // TODO: get target data by checking the state of focus
                this.internal.dispatchEvent('mouseout', 0);

                this.internal.config.tooltip_onhide.call(this);
            };

            // Features:
            // 1. category axis
            // 2. ceil values of translate/x/y to int for half pixel antialiasing
            // 3. multiline tick text
            var tickTextCharSize;
            function c3_axis(d3, params) {
                var scale = d3.scale.linear(),
                    orient = "bottom",
                    innerTickSize = 6,
                    outerTickSize,
                    tickPadding = 3,
                    tickValues = null,
                    tickFormat,
                    tickArguments;

                var tickOffset = 0,
                    tickCulling = true,
                    tickCentered;

                params = params || {};
                outerTickSize = params.withOuterTick ? 6 : 0;

                function axisX(selection, x) {
                    selection.attr("transform", function (d) {
                        return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
                    });
                }
                function axisY(selection, y) {
                    selection.attr("transform", function (d) {
                        return "translate(0," + Math.ceil(y(d)) + ")";
                    });
                }
                function scaleExtent(domain) {
                    var start = domain[0],
                        stop = domain[domain.length - 1];
                    return start < stop ? [start, stop] : [stop, start];
                }
                function generateTicks(scale) {
                    var i,
                        domain,
                        ticks = [];
                    if (scale.ticks) {
                        return scale.ticks.apply(scale, tickArguments);
                    }
                    domain = scale.domain();
                    for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
                        ticks.push(i);
                    }
                    if (ticks.length > 0 && ticks[0] > 0) {
                        ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
                    }
                    return ticks;
                }
                function copyScale() {
                    var newScale = scale.copy(),
                        domain;
                    if (params.isCategory) {
                        domain = scale.domain();
                        newScale.domain([domain[0], domain[1] - 1]);
                    }
                    return newScale;
                }
                function textFormatted(v) {
                    var formatted = tickFormat ? tickFormat(v) : v;
                    return typeof formatted !== 'undefined' ? formatted : '';
                }
                function getSizeFor1Char(tick) {
                    if (tickTextCharSize) {
                        return tickTextCharSize;
                    }
                    var size = {
                        h: 11.5,
                        w: 5.5
                    };
                    tick.select('text').text(textFormatted).each(function (d) {
                        var box = this.getBoundingClientRect(),
                            text = textFormatted(d),
                            h = box.height,
                            w = text ? box.width / text.length : undefined;
                        if (h && w) {
                            size.h = h;
                            size.w = w;
                        }
                    }).text('');
                    tickTextCharSize = size;
                    return size;
                }
                function transitionise(selection) {
                    return params.withoutTransition ? selection : d3.transition(selection);
                }
                function axis(g) {
                    g.each(function () {
                        var g = axis.g = d3.select(this);

                        var scale0 = this.__chart__ || scale,
                            scale1 = this.__chart__ = copyScale();

                        var ticks = tickValues ? tickValues : generateTicks(scale1),
                            tick = g.selectAll(".tick").data(ticks, scale1),
                            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1e-6),

                        // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
                        tickExit = tick.exit().remove(),
                            tickUpdate = transitionise(tick).style("opacity", 1),
                            tickTransform,
                            tickX,
                            tickY;

                        var range = scale.rangeExtent ? scale.rangeExtent() : scaleExtent(scale.range()),
                            path = g.selectAll(".domain").data([0]),
                            pathUpdate = (path.enter().append("path").attr("class", "domain"), transitionise(path));
                        tickEnter.append("line");
                        tickEnter.append("text");

                        var lineEnter = tickEnter.select("line"),
                            lineUpdate = tickUpdate.select("line"),
                            textEnter = tickEnter.select("text"),
                            textUpdate = tickUpdate.select("text");

                        if (params.isCategory) {
                            tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
                            tickX = tickCentered ? 0 : tickOffset;
                            tickY = tickCentered ? tickOffset : 0;
                        } else {
                            tickOffset = tickX = 0;
                        }

                        var text,
                            tspan,
                            sizeFor1Char = getSizeFor1Char(g.select('.tick')),
                            counts = [];
                        var tickLength = Math.max(innerTickSize, 0) + tickPadding,
                            isVertical = orient === 'left' || orient === 'right';

                        // this should be called only when category axis
                        function splitTickText(d, maxWidth) {
                            var tickText = textFormatted(d),
                                subtext,
                                spaceIndex,
                                textWidth,
                                splitted = [];

                            if (Object.prototype.toString.call(tickText) === "[object Array]") {
                                return tickText;
                            }

                            if (!maxWidth || maxWidth <= 0) {
                                maxWidth = isVertical ? 95 : params.isCategory ? Math.ceil(scale1(ticks[1]) - scale1(ticks[0])) - 12 : 110;
                            }

                            function split(splitted, text) {
                                spaceIndex = undefined;
                                for (var i = 1; i < text.length; i++) {
                                    if (text.charAt(i) === ' ') {
                                        spaceIndex = i;
                                    }
                                    subtext = text.substr(0, i + 1);
                                    textWidth = sizeFor1Char.w * subtext.length;
                                    // if text width gets over tick width, split by space index or crrent index
                                    if (maxWidth < textWidth) {
                                        return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                                    }
                                }
                                return splitted.concat(text);
                            }

                            return split(splitted, tickText + "");
                        }

                        function tspanDy(d, i) {
                            var dy = sizeFor1Char.h;
                            if (i === 0) {
                                if (orient === 'left' || orient === 'right') {
                                    dy = -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3);
                                } else {
                                    dy = ".71em";
                                }
                            }
                            return dy;
                        }

                        function tickSize(d) {
                            var tickPosition = scale(d) + (tickCentered ? 0 : tickOffset);
                            return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
                        }

                        text = tick.select("text");
                        tspan = text.selectAll('tspan').data(function (d, i) {
                            var splitted = params.tickMultiline ? splitTickText(d, params.tickWidth) : [].concat(textFormatted(d));
                            counts[i] = splitted.length;
                            return splitted.map(function (s) {
                                return { index: i, splitted: s };
                            });
                        });
                        tspan.enter().append('tspan');
                        tspan.exit().remove();
                        tspan.text(function (d) {
                            return d.splitted;
                        });

                        var rotate = params.tickTextRotate;

                        function textAnchorForText(rotate) {
                            if (!rotate) {
                                return 'middle';
                            }
                            return rotate > 0 ? "start" : "end";
                        }
                        function textTransform(rotate) {
                            if (!rotate) {
                                return '';
                            }
                            return "rotate(" + rotate + ")";
                        }
                        function dxForText(rotate) {
                            if (!rotate) {
                                return 0;
                            }
                            return 8 * Math.sin(Math.PI * (rotate / 180));
                        }
                        function yForText(rotate) {
                            if (!rotate) {
                                return tickLength;
                            }
                            return 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1);
                        }

                        switch (orient) {
                            case "bottom":
                                {
                                    tickTransform = axisX;
                                    lineEnter.attr("y2", innerTickSize);
                                    textEnter.attr("y", tickLength);
                                    lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", tickSize);
                                    textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate));
                                    tspan.attr('x', 0).attr("dy", tspanDy).attr('dx', dxForText(rotate));
                                    pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
                                    break;
                                }
                            case "top":
                                {
                                    // TODO: rotated tick text
                                    tickTransform = axisX;
                                    lineEnter.attr("y2", -innerTickSize);
                                    textEnter.attr("y", -tickLength);
                                    lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
                                    textUpdate.attr("x", 0).attr("y", -tickLength);
                                    text.style("text-anchor", "middle");
                                    tspan.attr('x', 0).attr("dy", "0em");
                                    pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
                                    break;
                                }
                            case "left":
                                {
                                    tickTransform = axisY;
                                    lineEnter.attr("x2", -innerTickSize);
                                    textEnter.attr("x", -tickLength);
                                    lineUpdate.attr("x2", -innerTickSize).attr("y1", tickY).attr("y2", tickY);
                                    textUpdate.attr("x", -tickLength).attr("y", tickOffset);
                                    text.style("text-anchor", "end");
                                    tspan.attr('x', -tickLength).attr("dy", tspanDy);
                                    pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
                                    break;
                                }
                            case "right":
                                {
                                    tickTransform = axisY;
                                    lineEnter.attr("x2", innerTickSize);
                                    textEnter.attr("x", tickLength);
                                    lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
                                    textUpdate.attr("x", tickLength).attr("y", 0);
                                    text.style("text-anchor", "start");
                                    tspan.attr('x', tickLength).attr("dy", tspanDy);
                                    pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
                                    break;
                                }
                        }
                        if (scale1.rangeBand) {
                            var x = scale1,
                                dx = x.rangeBand() / 2;
                            scale0 = scale1 = function (d) {
                                return x(d) + dx;
                            };
                        } else if (scale0.rangeBand) {
                            scale0 = scale1;
                        } else {
                            tickExit.call(tickTransform, scale1);
                        }
                        tickEnter.call(tickTransform, scale0);
                        tickUpdate.call(tickTransform, scale1);
                    });
                }
                axis.scale = function (x) {
                    if (!arguments.length) {
                        return scale;
                    }
                    scale = x;
                    return axis;
                };
                axis.orient = function (x) {
                    if (!arguments.length) {
                        return orient;
                    }
                    orient = x in { top: 1, right: 1, bottom: 1, left: 1 } ? x + "" : "bottom";
                    return axis;
                };
                axis.tickFormat = function (format) {
                    if (!arguments.length) {
                        return tickFormat;
                    }
                    tickFormat = format;
                    return axis;
                };
                axis.tickCentered = function (isCentered) {
                    if (!arguments.length) {
                        return tickCentered;
                    }
                    tickCentered = isCentered;
                    return axis;
                };
                axis.tickOffset = function () {
                    return tickOffset;
                };
                axis.tickInterval = function () {
                    var interval, length;
                    if (params.isCategory) {
                        interval = tickOffset * 2;
                    } else {
                        length = axis.g.select('path.domain').node().getTotalLength() - outerTickSize * 2;
                        interval = length / axis.g.selectAll('line').size();
                    }
                    return interval === Infinity ? 0 : interval;
                };
                axis.ticks = function () {
                    if (!arguments.length) {
                        return tickArguments;
                    }
                    tickArguments = arguments;
                    return axis;
                };
                axis.tickCulling = function (culling) {
                    if (!arguments.length) {
                        return tickCulling;
                    }
                    tickCulling = culling;
                    return axis;
                };
                axis.tickValues = function (x) {
                    if (typeof x === 'function') {
                        tickValues = function () {
                            return x(scale.domain());
                        };
                    } else {
                        if (!arguments.length) {
                            return tickValues;
                        }
                        tickValues = x;
                    }
                    return axis;
                };
                return axis;
            }

            c3_chart_internal_fn.isSafari = function () {
                var ua = window.navigator.userAgent;
                return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
            };
            c3_chart_internal_fn.isChrome = function () {
                var ua = window.navigator.userAgent;
                return ua.indexOf('Chrome') >= 0;
            };

            /* jshint ignore:start */

            // PhantomJS doesn't have support for Function.prototype.bind, which has caused confusion. Use
            // this polyfill to avoid the confusion.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill

            if (!Function.prototype.bind) {
                Function.prototype.bind = function (oThis) {
                    if (typeof this !== 'function') {
                        // closest thing possible to the ECMAScript 5
                        // internal IsCallable function
                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                    }

                    var aArgs = Array.prototype.slice.call(arguments, 1),
                        fToBind = this,
                        fNOP = function () {},
                        fBound = function () {
                        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                    };

                    fNOP.prototype = this.prototype;
                    fBound.prototype = new fNOP();

                    return fBound;
                };
            }

            //SVGPathSeg API polyfill
            //https://github.com/progers/pathseg
            //
            //This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from
            //SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec
            //changes which were implemented in Firefox 43 and Chrome 46.
            //Chrome 48 removes these APIs, so this polyfill is required.

            (function () {
                "use strict";

                if (!("SVGPathSeg" in window)) {
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
                    window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {
                        this.pathSegType = type;
                        this.pathSegTypeAsLetter = typeAsLetter;
                        this._owningPathSegList = owningPathSegList;
                    };

                    SVGPathSeg.PATHSEG_UNKNOWN = 0;
                    SVGPathSeg.PATHSEG_CLOSEPATH = 1;
                    SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
                    SVGPathSeg.PATHSEG_MOVETO_REL = 3;
                    SVGPathSeg.PATHSEG_LINETO_ABS = 4;
                    SVGPathSeg.PATHSEG_LINETO_REL = 5;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
                    SVGPathSeg.PATHSEG_ARC_ABS = 10;
                    SVGPathSeg.PATHSEG_ARC_REL = 11;
                    SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
                    SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
                    SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
                    SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

                    // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
                    SVGPathSeg.prototype._segmentChanged = function () {
                        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);
                    };

                    window.SVGPathSegClosePath = function (owningPathSegList) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);
                    };
                    SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegClosePath.prototype.toString = function () {
                        return "[object SVGPathSegClosePath]";
                    };
                    SVGPathSegClosePath.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter;
                    };
                    SVGPathSegClosePath.prototype.clone = function () {
                        return new SVGPathSegClosePath(undefined);
                    };

                    window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegMovetoAbs.prototype.toString = function () {
                        return "[object SVGPathSegMovetoAbs]";
                    };
                    SVGPathSegMovetoAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegMovetoAbs.prototype.clone = function () {
                        return new SVGPathSegMovetoAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegMovetoAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegMovetoAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegMovetoRel.prototype.toString = function () {
                        return "[object SVGPathSegMovetoRel]";
                    };
                    SVGPathSegMovetoRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegMovetoRel.prototype.clone = function () {
                        return new SVGPathSegMovetoRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegMovetoRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegMovetoRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoAbs]";
                    };
                    SVGPathSegLinetoAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegLinetoAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegLinetoAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoRel]";
                    };
                    SVGPathSegLinetoRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegLinetoRel.prototype.clone = function () {
                        return new SVGPathSegLinetoRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegLinetoRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicAbs]";
                    };
                    SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicRel]";
                    };
                    SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticAbs]";
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticRel]";
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._r1 = r1;
                        this._r2 = r2;
                        this._angle = angle;
                        this._largeArcFlag = largeArcFlag;
                        this._sweepFlag = sweepFlag;
                    };
                    SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegArcAbs.prototype.toString = function () {
                        return "[object SVGPathSegArcAbs]";
                    };
                    SVGPathSegArcAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
                    };
                    SVGPathSegArcAbs.prototype.clone = function () {
                        return new SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
                    };
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "r1", { get: function () {
                            return this._r1;
                        }, set: function (r1) {
                            this._r1 = r1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "r2", { get: function () {
                            return this._r2;
                        }, set: function (r2) {
                            this._r2 = r2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "angle", { get: function () {
                            return this._angle;
                        }, set: function (angle) {
                            this._angle = angle;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function () {
                            return this._largeArcFlag;
                        }, set: function (largeArcFlag) {
                            this._largeArcFlag = largeArcFlag;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "sweepFlag", { get: function () {
                            return this._sweepFlag;
                        }, set: function (sweepFlag) {
                            this._sweepFlag = sweepFlag;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._r1 = r1;
                        this._r2 = r2;
                        this._angle = angle;
                        this._largeArcFlag = largeArcFlag;
                        this._sweepFlag = sweepFlag;
                    };
                    SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegArcRel.prototype.toString = function () {
                        return "[object SVGPathSegArcRel]";
                    };
                    SVGPathSegArcRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
                    };
                    SVGPathSegArcRel.prototype.clone = function () {
                        return new SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
                    };
                    Object.defineProperty(SVGPathSegArcRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "r1", { get: function () {
                            return this._r1;
                        }, set: function (r1) {
                            this._r1 = r1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "r2", { get: function () {
                            return this._r2;
                        }, set: function (r2) {
                            this._r2 = r2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "angle", { get: function () {
                            return this._angle;
                        }, set: function (angle) {
                            this._angle = angle;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "largeArcFlag", { get: function () {
                            return this._largeArcFlag;
                        }, set: function (largeArcFlag) {
                            this._largeArcFlag = largeArcFlag;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "sweepFlag", { get: function () {
                            return this._sweepFlag;
                        }, set: function (sweepFlag) {
                            this._sweepFlag = sweepFlag;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);
                        this._x = x;
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoHorizontalAbs]";
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x;
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoHorizontalAbs(undefined, this._x);
                    };
                    Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);
                        this._x = x;
                    };
                    SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoHorizontalRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoHorizontalRel]";
                    };
                    SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x;
                    };
                    SVGPathSegLinetoHorizontalRel.prototype.clone = function () {
                        return new SVGPathSegLinetoHorizontalRel(undefined, this._x);
                    };
                    Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);
                        this._y = y;
                    };
                    SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoVerticalAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoVerticalAbs]";
                    };
                    SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._y;
                    };
                    SVGPathSegLinetoVerticalAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoVerticalAbs(undefined, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);
                        this._y = y;
                    };
                    SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoVerticalRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoVerticalRel]";
                    };
                    SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._y;
                    };
                    SVGPathSegLinetoVerticalRel.prototype.clone = function () {
                        return new SVGPathSegLinetoVerticalRel(undefined, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicSmoothAbs]";
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicSmoothRel]";
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticSmoothAbs]";
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticSmoothRel]";
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    // Add createSVGPathSeg* functions to SVGPathElement.
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathElement.
                    SVGPathElement.prototype.createSVGPathSegClosePath = function () {
                        return new SVGPathSegClosePath(undefined);
                    };
                    SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
                        return new SVGPathSegMovetoAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
                        return new SVGPathSegMovetoRel(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
                        return new SVGPathSegLinetoAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
                        return new SVGPathSegLinetoRel(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
                        return new SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
                        return new SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
                        return new SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
                        return new SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
                    };
                    SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        return new SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
                    };
                    SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        return new SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
                        return new SVGPathSegLinetoHorizontalAbs(undefined, x);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
                        return new SVGPathSegLinetoHorizontalRel(undefined, x);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
                        return new SVGPathSegLinetoVerticalAbs(undefined, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
                        return new SVGPathSegLinetoVerticalRel(undefined, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
                        return new SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
                        return new SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
                        return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
                        return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
                    };
                }

                if (!("SVGPathSegList" in window)) {
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
                    window.SVGPathSegList = function (pathElement) {
                        this._pathElement = pathElement;
                        this._list = this._parsePath(this._pathElement.getAttribute("d"));

                        // Use a MutationObserver to catch changes to the path's "d" attribute.
                        this._mutationObserverConfig = { "attributes": true, "attributeFilter": ["d"] };
                        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
                        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
                    };

                    Object.defineProperty(SVGPathSegList.prototype, "numberOfItems", {
                        get: function () {
                            this._checkPathSynchronizedToList();
                            return this._list.length;
                        },
                        enumerable: true
                    });

                    // Add the pathSegList accessors to SVGPathElement.
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
                    Object.defineProperty(SVGPathElement.prototype, "pathSegList", {
                        get: function () {
                            if (!this._pathSegList) this._pathSegList = new SVGPathSegList(this);
                            return this._pathSegList;
                        },
                        enumerable: true
                    });
                    // FIXME: The following are not implemented and simply return SVGPathElement.pathSegList.
                    Object.defineProperty(SVGPathElement.prototype, "normalizedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });
                    Object.defineProperty(SVGPathElement.prototype, "animatedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });
                    Object.defineProperty(SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });

                    // Process any pending mutations to the path element and update the list as needed.
                    // This should be the first call of all public functions and is needed because
                    // MutationObservers are not synchronous so we can have pending asynchronous mutations.
                    SVGPathSegList.prototype._checkPathSynchronizedToList = function () {
                        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
                    };

                    SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {
                        if (!this._pathElement) return;
                        var hasPathMutations = false;
                        mutationRecords.forEach(function (record) {
                            if (record.attributeName == "d") hasPathMutations = true;
                        });
                        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute("d"));
                    };

                    // Serialize the list and update the path's 'd' attribute.
                    SVGPathSegList.prototype._writeListToPath = function () {
                        this._pathElementMutationObserver.disconnect();
                        this._pathElement.setAttribute("d", SVGPathSegList._pathSegArrayAsString(this._list));
                        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
                    };

                    // When a path segment changes the list needs to be synchronized back to the path element.
                    SVGPathSegList.prototype.segmentChanged = function (pathSeg) {
                        this._writeListToPath();
                    };

                    SVGPathSegList.prototype.clear = function () {
                        this._checkPathSynchronizedToList();

                        this._list.forEach(function (pathSeg) {
                            pathSeg._owningPathSegList = null;
                        });
                        this._list = [];
                        this._writeListToPath();
                    };

                    SVGPathSegList.prototype.initialize = function (newItem) {
                        this._checkPathSynchronizedToList();

                        this._list = [newItem];
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype._checkValidIndex = function (index) {
                        if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw "INDEX_SIZE_ERR";
                    };

                    SVGPathSegList.prototype.getItem = function (index) {
                        this._checkPathSynchronizedToList();

                        this._checkValidIndex(index);
                        return this._list[index];
                    };

                    SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {
                        this._checkPathSynchronizedToList();

                        // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
                        if (index > this.numberOfItems) index = this.numberOfItems;
                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._list.splice(index, 0, newItem);
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype.replaceItem = function (newItem, index) {
                        this._checkPathSynchronizedToList();

                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._checkValidIndex(index);
                        this._list[index] = newItem;
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype.removeItem = function (index) {
                        this._checkPathSynchronizedToList();

                        this._checkValidIndex(index);
                        var item = this._list[index];
                        this._list.splice(index, 1);
                        this._writeListToPath();
                        return item;
                    };

                    SVGPathSegList.prototype.appendItem = function (newItem) {
                        this._checkPathSynchronizedToList();

                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._list.push(newItem);
                        newItem._owningPathSegList = this;
                        // TODO: Optimize this to just append to the existing attribute.
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {
                        var string = "";
                        var first = true;
                        pathSegArray.forEach(function (pathSeg) {
                            if (first) {
                                first = false;
                                string += pathSeg._asPathString();
                            } else {
                                string += " " + pathSeg._asPathString();
                            }
                        });
                        return string;
                    };

                    // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
                    SVGPathSegList.prototype._parsePath = function (string) {
                        if (!string || string.length == 0) return [];

                        var owningPathSegList = this;

                        var Builder = function () {
                            this.pathSegList = [];
                        };

                        Builder.prototype.appendSegment = function (pathSeg) {
                            this.pathSegList.push(pathSeg);
                        };

                        var Source = function (string) {
                            this._string = string;
                            this._currentIndex = 0;
                            this._endIndex = this._string.length;
                            this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN;

                            this._skipOptionalSpaces();
                        };

                        Source.prototype._isCurrentSpace = function () {
                            var character = this._string[this._currentIndex];
                            return character <= " " && (character == " " || character == "\n" || character == "\t" || character == "\r" || character == "\f");
                        };

                        Source.prototype._skipOptionalSpaces = function () {
                            while (this._currentIndex < this._endIndex && this._isCurrentSpace()) this._currentIndex++;
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype._skipOptionalSpacesOrDelimiter = function () {
                            if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",") return false;
                            if (this._skipOptionalSpaces()) {
                                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {
                                    this._currentIndex++;
                                    this._skipOptionalSpaces();
                                }
                            }
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype.hasMoreData = function () {
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype.peekSegmentType = function () {
                            var lookahead = this._string[this._currentIndex];
                            return this._pathSegTypeFromChar(lookahead);
                        };

                        Source.prototype._pathSegTypeFromChar = function (lookahead) {
                            switch (lookahead) {
                                case "Z":
                                case "z":
                                    return SVGPathSeg.PATHSEG_CLOSEPATH;
                                case "M":
                                    return SVGPathSeg.PATHSEG_MOVETO_ABS;
                                case "m":
                                    return SVGPathSeg.PATHSEG_MOVETO_REL;
                                case "L":
                                    return SVGPathSeg.PATHSEG_LINETO_ABS;
                                case "l":
                                    return SVGPathSeg.PATHSEG_LINETO_REL;
                                case "C":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                                case "c":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                                case "Q":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                                case "q":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                                case "A":
                                    return SVGPathSeg.PATHSEG_ARC_ABS;
                                case "a":
                                    return SVGPathSeg.PATHSEG_ARC_REL;
                                case "H":
                                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                                case "h":
                                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                                case "V":
                                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                                case "v":
                                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                                case "S":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                                case "s":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                                case "T":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                                case "t":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                                default:
                                    return SVGPathSeg.PATHSEG_UNKNOWN;
                            }
                        };

                        Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {
                            // Check for remaining coordinates in the current command.
                            if ((lookahead == "+" || lookahead == "-" || lookahead == "." || lookahead >= "0" && lookahead <= "9") && previousCommand != SVGPathSeg.PATHSEG_CLOSEPATH) {
                                if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_ABS) return SVGPathSeg.PATHSEG_LINETO_ABS;
                                if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_REL) return SVGPathSeg.PATHSEG_LINETO_REL;
                                return previousCommand;
                            }
                            return SVGPathSeg.PATHSEG_UNKNOWN;
                        };

                        Source.prototype.initialCommandIsMoveTo = function () {
                            // If the path is empty it is still valid, so return true.
                            if (!this.hasMoreData()) return true;
                            var command = this.peekSegmentType();
                            // Path must start with moveTo.
                            return command == SVGPathSeg.PATHSEG_MOVETO_ABS || command == SVGPathSeg.PATHSEG_MOVETO_REL;
                        };

                        // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
                        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
                        Source.prototype._parseNumber = function () {
                            var exponent = 0;
                            var integer = 0;
                            var frac = 1;
                            var decimal = 0;
                            var sign = 1;
                            var expsign = 1;

                            var startIndex = this._currentIndex;

                            this._skipOptionalSpaces();

                            // Read the sign.
                            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+") this._currentIndex++;else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {
                                this._currentIndex++;
                                sign = -1;
                            }

                            if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != ".")
                                // The first character of a number must be one of [0-9+-.].
                                return undefined;

                            // Read the integer part, build right-to-left.
                            var startIntPartIndex = this._currentIndex;
                            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") this._currentIndex++; // Advance to first non-digit.

                            if (this._currentIndex != startIntPartIndex) {
                                var scanIntPartIndex = this._currentIndex - 1;
                                var multiplier = 1;
                                while (scanIntPartIndex >= startIntPartIndex) {
                                    integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");
                                    multiplier *= 10;
                                }
                            }

                            // Read the decimals.
                            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {
                                this._currentIndex++;

                                // There must be a least one digit following the .
                                if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;
                                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") decimal += (this._string.charAt(this._currentIndex++) - "0") * (frac *= 0.1);
                            }

                            // Read the exponent part.
                            if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m") {
                                this._currentIndex++;

                                // Read the sign of the exponent.
                                if (this._string.charAt(this._currentIndex) == "+") {
                                    this._currentIndex++;
                                } else if (this._string.charAt(this._currentIndex) == "-") {
                                    this._currentIndex++;
                                    expsign = -1;
                                }

                                // There must be an exponent.
                                if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;

                                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                                    exponent *= 10;
                                    exponent += this._string.charAt(this._currentIndex) - "0";
                                    this._currentIndex++;
                                }
                            }

                            var number = integer + decimal;
                            number *= sign;

                            if (exponent) number *= Math.pow(10, expsign * exponent);

                            if (startIndex == this._currentIndex) return undefined;

                            this._skipOptionalSpacesOrDelimiter();

                            return number;
                        };

                        Source.prototype._parseArcFlag = function () {
                            if (this._currentIndex >= this._endIndex) return undefined;
                            var flag = false;
                            var flagChar = this._string.charAt(this._currentIndex++);
                            if (flagChar == "0") flag = false;else if (flagChar == "1") flag = true;else return undefined;

                            this._skipOptionalSpacesOrDelimiter();
                            return flag;
                        };

                        Source.prototype.parseSegment = function () {
                            var lookahead = this._string[this._currentIndex];
                            var command = this._pathSegTypeFromChar(lookahead);
                            if (command == SVGPathSeg.PATHSEG_UNKNOWN) {
                                // Possibly an implicit command. Not allowed if this is the first command.
                                if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN) return null;
                                command = this._nextCommandHelper(lookahead, this._previousCommand);
                                if (command == SVGPathSeg.PATHSEG_UNKNOWN) return null;
                            } else {
                                this._currentIndex++;
                            }

                            this._previousCommand = command;

                            switch (command) {
                                case SVGPathSeg.PATHSEG_MOVETO_REL:
                                    return new SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                                    return new SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_REL:
                                    return new SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_ABS:
                                    return new SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                                    return new SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                                    return new SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                                    return new SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                                    return new SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_CLOSEPATH:
                                    this._skipOptionalSpaces();
                                    return new SVGPathSegClosePath(owningPathSegList);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                                    var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                                    var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                                    return new SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                                    return new SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_ARC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                                case SVGPathSeg.PATHSEG_ARC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                                default:
                                    throw "Unknown path seg type.";
                            }
                        };

                        var builder = new Builder();
                        var source = new Source(string);

                        if (!source.initialCommandIsMoveTo()) return [];
                        while (source.hasMoreData()) {
                            var pathSeg = source.parseSegment();
                            if (!pathSeg) return [];
                            builder.appendSegment(pathSeg);
                        }

                        return builder.pathSegList;
                    };
                }
            })();

            /* jshint ignore:end */

            if (typeof define === 'function' && define.amd) {
                define("c3", ["d3"], function () {
                    return c3;
                });
            } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
                module.exports = c3;
            } else {
                window.c3 = c3;
            }
        })(window);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("6e", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6f", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("5b", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "ace", null);

    (function ($__global) {
        /* ***** BEGIN LICENSE BLOCK *****
         * Distributed under the BSD license:
         *
         * Copyright (c) 2010, Ajax.org B.V.
         * All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *     * Redistributions of source code must retain the above copyright
         *       notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above copyright
         *       notice, this list of conditions and the following disclaimer in the
         *       documentation and/or other materials provided with the distribution.
         *     * Neither the name of Ajax.org B.V. nor the
         *       names of its contributors may be used to endorse or promote products
         *       derived from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
         * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * ***** END LICENSE BLOCK ***** */

        /**
         * Define a module along with a payload
         * @param module a name for the payload
         * @param payload a function to call with (require, exports, module) params
         */

        (function () {

            var ACE_NAMESPACE = "ace";

            var global = function () {
                return this;
            }();
            if (!global && typeof window != "undefined") global = window; // strict mode


            if (!ACE_NAMESPACE && typeof requirejs !== "undefined") return;

            var define = function (module, deps, payload) {
                if (typeof module !== "string") {
                    if (define.original) define.original.apply(this, arguments);else {
                        console.error("dropping module because define wasn\'t a string.");
                        console.trace();
                    }
                    return;
                }
                if (arguments.length == 2) payload = deps;
                if (!define.modules[module]) {
                    define.payloads[module] = payload;
                    define.modules[module] = null;
                }
            };

            define.modules = {};
            define.payloads = {};

            /**
             * Get at functionality define()ed using the function above
             */
            var _require = function (parentId, module, callback) {
                if (typeof module === "string") {
                    var payload = lookup(parentId, module);
                    if (payload != undefined) {
                        callback && callback();
                        return payload;
                    }
                } else if (Object.prototype.toString.call(module) === "[object Array]") {
                    var params = [];
                    for (var i = 0, l = module.length; i < l; ++i) {
                        var dep = lookup(parentId, module[i]);
                        if (dep == undefined && require.original) return;
                        params.push(dep);
                    }
                    return callback && callback.apply(null, params) || true;
                }
            };

            var require = function (module, callback) {
                var packagedModule = _require("", module, callback);
                if (packagedModule == undefined && require.original) return require.original.apply(this, arguments);
                return packagedModule;
            };

            var normalizeModule = function (parentId, moduleName) {
                // normalize plugin requires
                if (moduleName.indexOf("!") !== -1) {
                    var chunks = moduleName.split("!");
                    return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
                }
                // normalize relative requires
                if (moduleName.charAt(0) == ".") {
                    var base = parentId.split("/").slice(0, -1).join("/");
                    moduleName = base + "/" + moduleName;

                    while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
                        var previous = moduleName;
                        moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
                    }
                }
                return moduleName;
            };

            /**
             * Internal function to lookup moduleNames and resolve them by calling the
             * definition function if needed.
             */
            var lookup = function (parentId, moduleName) {
                moduleName = normalizeModule(parentId, moduleName);

                var module = define.modules[moduleName];
                if (!module) {
                    module = define.payloads[moduleName];
                    if (typeof module === 'function') {
                        var exports = {};
                        var mod = {
                            id: moduleName,
                            uri: '',
                            exports: exports,
                            packaged: true
                        };

                        var req = function (module, callback) {
                            return _require(moduleName, module, callback);
                        };

                        var returnValue = module(req, exports, mod);
                        exports = returnValue || mod.exports;
                        define.modules[moduleName] = exports;
                        delete define.payloads[moduleName];
                    }
                    module = define.modules[moduleName] = exports || module;
                }
                return module;
            };

            function exportAce(ns) {
                var root = global;
                if (ns) {
                    if (!global[ns]) global[ns] = {};
                    root = global[ns];
                }

                if (!root.define || !root.define.packaged) {
                    define.original = root.define;
                    root.define = define;
                    root.define.packaged = true;
                }

                if (!root.require || !root.require.packaged) {
                    require.original = root.require;
                    root.require = require;
                    root.require.packaged = true;
                }
            }

            exportAce(ACE_NAMESPACE);
        })();

        ace.define("ace/lib/regexp", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var real = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            },
                compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
                // check `exec` handling of nonparticipating capturing groups
            compliantLastIndexIncrement = function () {
                var x = /^/g;
                real.test.call(x, "");
                return !x.lastIndex;
            }();

            if (compliantLastIndexIncrement && compliantExecNpcg) return;
            RegExp.prototype.exec = function (str) {
                var match = real.exec.apply(this, arguments),
                    name,
                    r2;
                if (typeof str == 'string' && match) {
                    if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                        real.replace.call(str.slice(match.index), r2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === undefined) match[i] = undefined;
                            }
                        });
                    }
                    if (this._xregexp && this._xregexp.captureNames) {
                        for (var i = 1; i < match.length; i++) {
                            name = this._xregexp.captureNames[i - 1];
                            if (name) match[name] = match[i];
                        }
                    }
                    if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                }
                return match;
            };
            if (!compliantLastIndexIncrement) {
                RegExp.prototype.test = function (str) {
                    var match = real.exec.call(this, str);
                    if (match && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                    return !!match;
                };
            }

            function getNativeFlags(regex) {
                return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + ( // Proposed for ES4; included in AS3
                regex.sticky ? "y" : "");
            }

            function indexOf(array, item, from) {
                if (Array.prototype.indexOf) // Use the native array method if available
                    return array.indexOf(item, from);
                for (var i = from || 0; i < array.length; i++) {
                    if (array[i] === item) return i;
                }
                return -1;
            }
        });

        ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (require, exports, module) {

            function Empty() {}

            if (!Function.prototype.bind) {
                Function.prototype.bind = function bind(that) {
                    // .length is 1
                    var target = this;
                    if (typeof target != "function") {
                        throw new TypeError("Function.prototype.bind called on incompatible " + target);
                    }
                    var args = slice.call(arguments, 1); // for normal call
                    var bound = function () {

                        if (this instanceof bound) {

                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    if (target.prototype) {
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            }
            var call = Function.prototype.call;
            var prototypeOfArray = Array.prototype;
            var prototypeOfObject = Object.prototype;
            var slice = prototypeOfArray.slice;
            var _toString = call.bind(prototypeOfObject.toString);
            var owns = call.bind(prototypeOfObject.hasOwnProperty);
            var defineGetter;
            var defineSetter;
            var lookupGetter;
            var lookupSetter;
            var supportsAccessors;
            if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
                defineGetter = call.bind(prototypeOfObject.__defineGetter__);
                defineSetter = call.bind(prototypeOfObject.__defineSetter__);
                lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
                lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
            }
            if ([1, 2].splice(0).length != 2) {
                if (function () {
                    // test IE < 9 to splice bug - see issue #138
                    function makeArray(l) {
                        var a = new Array(l + 2);
                        a[0] = a[1] = 0;
                        return a;
                    }
                    var array = [],
                        lengthBefore;

                    array.splice.apply(array, makeArray(20));
                    array.splice.apply(array, makeArray(26));

                    lengthBefore = array.length; //46
                    array.splice(5, 0, "XXX"); // add one element

                    lengthBefore + 1 == array.length;

                    if (lengthBefore + 1 == array.length) {
                        return true; // has right splice implementation without bugs
                    }
                }()) {
                    //IE 6/7
                    var array_splice = Array.prototype.splice;
                    Array.prototype.splice = function (start, deleteCount) {
                        if (!arguments.length) {
                            return [];
                        } else {
                            return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
                        }
                    };
                } else {
                    //IE8
                    Array.prototype.splice = function (pos, removeCount) {
                        var length = this.length;
                        if (pos > 0) {
                            if (pos > length) pos = length;
                        } else if (pos == void 0) {
                            pos = 0;
                        } else if (pos < 0) {
                            pos = Math.max(length + pos, 0);
                        }

                        if (!(pos + removeCount < length)) removeCount = length - pos;

                        var removed = this.slice(pos, pos + removeCount);
                        var insert = slice.call(arguments, 2);
                        var add = insert.length;
                        if (pos === length) {
                            if (add) {
                                this.push.apply(this, insert);
                            }
                        } else {
                            var remove = Math.min(removeCount, length - pos);
                            var tailOldPos = pos + remove;
                            var tailNewPos = tailOldPos + add - remove;
                            var tailCount = length - tailOldPos;
                            var lengthAfterRemove = length - remove;

                            if (tailNewPos < tailOldPos) {
                                // case A
                                for (var i = 0; i < tailCount; ++i) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } else if (tailNewPos > tailOldPos) {
                                // case B
                                for (i = tailCount; i--;) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } // else, add == remove (nothing to do)

                            if (add && pos === lengthAfterRemove) {
                                this.length = lengthAfterRemove; // truncate array
                                this.push.apply(this, insert);
                            } else {
                                this.length = lengthAfterRemove + add; // reserves space
                                for (i = 0; i < add; ++i) {
                                    this[pos + i] = insert[i];
                                }
                            }
                        }
                        return removed;
                    };
                }
            }
            if (!Array.isArray) {
                Array.isArray = function isArray(obj) {
                    return _toString(obj) == "[object Array]";
                };
            }
            var boxedString = Object("a"),
                splitString = boxedString[0] != "a" || !(0 in boxedString);

            if (!Array.prototype.forEach) {
                Array.prototype.forEach = function forEach(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        thisp = arguments[1],
                        i = -1,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(); // TODO message
                    }

                    while (++i < length) {
                        if (i in self) {
                            fun.call(thisp, self[i], i, object);
                        }
                    }
                };
            }
            if (!Array.prototype.map) {
                Array.prototype.map = function map(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = Array(length),
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) result[i] = fun.call(thisp, self[i], i, object);
                    }
                    return result;
                };
            }
            if (!Array.prototype.filter) {
                Array.prototype.filter = function filter(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = [],
                        value,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) {
                            value = self[i];
                            if (fun.call(thisp, value, i, object)) {
                                result.push(value);
                            }
                        }
                    }
                    return result;
                };
            }
            if (!Array.prototype.every) {
                Array.prototype.every = function every(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && !fun.call(thisp, self[i], i, object)) {
                            return false;
                        }
                    }
                    return true;
                };
            }
            if (!Array.prototype.some) {
                Array.prototype.some = function some(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && fun.call(thisp, self[i], i, object)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            if (!Array.prototype.reduce) {
                Array.prototype.reduce = function reduce(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduce of empty array with no initial value");
                    }

                    var i = 0;
                    var result;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i++];
                                break;
                            }
                            if (++i >= length) {
                                throw new TypeError("reduce of empty array with no initial value");
                            }
                        } while (true);
                    }

                    for (; i < length; i++) {
                        if (i in self) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    }

                    return result;
                };
            }
            if (!Array.prototype.reduceRight) {
                Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduceRight of empty array with no initial value");
                    }

                    var result,
                        i = length - 1;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i--];
                                break;
                            }
                            if (--i < 0) {
                                throw new TypeError("reduceRight of empty array with no initial value");
                            }
                        } while (true);
                    }

                    do {
                        if (i in this) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    } while (i--);

                    return result;
                };
            }
            if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
                Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }

                    var i = 0;
                    if (arguments.length > 1) {
                        i = toInteger(arguments[1]);
                    }
                    i = i >= 0 ? i : Math.max(0, length + i);
                    for (; i < length; i++) {
                        if (i in self && self[i] === sought) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
                Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }
                    var i = length - 1;
                    if (arguments.length > 1) {
                        i = Math.min(i, toInteger(arguments[1]));
                    }
                    i = i >= 0 ? i : length - Math.abs(i);
                    for (; i >= 0; i--) {
                        if (i in self && sought === self[i]) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Object.getPrototypeOf) {
                Object.getPrototypeOf = function getPrototypeOf(object) {
                    return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
                };
            }
            if (!Object.getOwnPropertyDescriptor) {
                var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
                Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
                    if (!owns(object, property)) return;

                    var descriptor, getter, setter;
                    descriptor = { enumerable: true, configurable: true };
                    if (supportsAccessors) {
                        var prototype = object.__proto__;
                        object.__proto__ = prototypeOfObject;

                        var getter = lookupGetter(object, property);
                        var setter = lookupSetter(object, property);
                        object.__proto__ = prototype;

                        if (getter || setter) {
                            if (getter) descriptor.get = getter;
                            if (setter) descriptor.set = setter;
                            return descriptor;
                        }
                    }
                    descriptor.value = object[property];
                    return descriptor;
                };
            }
            if (!Object.getOwnPropertyNames) {
                Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
                    return Object.keys(object);
                };
            }
            if (!Object.create) {
                var createEmpty;
                if (Object.prototype.__proto__ === null) {
                    createEmpty = function () {
                        return { "__proto__": null };
                    };
                } else {
                    createEmpty = function () {
                        var empty = {};
                        for (var i in empty) empty[i] = null;
                        empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
                        return empty;
                    };
                }

                Object.create = function create(prototype, properties) {
                    var object;
                    if (prototype === null) {
                        object = createEmpty();
                    } else {
                        if (typeof prototype != "object") throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
                        var Type = function () {};
                        Type.prototype = prototype;
                        object = new Type();
                        object.__proto__ = prototype;
                    }
                    if (properties !== void 0) Object.defineProperties(object, properties);
                    return object;
                };
            }

            function doesDefinePropertyWork(object) {
                try {
                    Object.defineProperty(object, "sentinel", {});
                    return "sentinel" in object;
                } catch (exception) {}
            }
            if (Object.defineProperty) {
                var definePropertyWorksOnObject = doesDefinePropertyWork({});
                var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
                if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
                    var definePropertyFallback = Object.defineProperty;
                }
            }

            if (!Object.defineProperty || definePropertyFallback) {
                var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
                var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
                var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";

                Object.defineProperty = function defineProperty(object, property, descriptor) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
                    if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
                    if (definePropertyFallback) {
                        try {
                            return definePropertyFallback.call(Object, object, property, descriptor);
                        } catch (exception) {}
                    }
                    if (owns(descriptor, "value")) {

                        if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                            var prototype = object.__proto__;
                            object.__proto__ = prototypeOfObject;
                            delete object[property];
                            object[property] = descriptor.value;
                            object.__proto__ = prototype;
                        } else {
                            object[property] = descriptor.value;
                        }
                    } else {
                        if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                        if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
                        if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
                    }

                    return object;
                };
            }
            if (!Object.defineProperties) {
                Object.defineProperties = function defineProperties(object, properties) {
                    for (var property in properties) {
                        if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
                    }
                    return object;
                };
            }
            if (!Object.seal) {
                Object.seal = function seal(object) {
                    return object;
                };
            }
            if (!Object.freeze) {
                Object.freeze = function freeze(object) {
                    return object;
                };
            }
            try {
                Object.freeze(function () {});
            } catch (exception) {
                Object.freeze = function freeze(freezeObject) {
                    return function freeze(object) {
                        if (typeof object == "function") {
                            return object;
                        } else {
                            return freezeObject(object);
                        }
                    };
                }(Object.freeze);
            }
            if (!Object.preventExtensions) {
                Object.preventExtensions = function preventExtensions(object) {
                    return object;
                };
            }
            if (!Object.isSealed) {
                Object.isSealed = function isSealed(object) {
                    return false;
                };
            }
            if (!Object.isFrozen) {
                Object.isFrozen = function isFrozen(object) {
                    return false;
                };
            }
            if (!Object.isExtensible) {
                Object.isExtensible = function isExtensible(object) {
                    if (Object(object) === object) {
                        throw new TypeError(); // TODO message
                    }
                    var name = '';
                    while (owns(object, name)) {
                        name += '?';
                    }
                    object[name] = true;
                    var returnValue = owns(object, name);
                    delete object[name];
                    return returnValue;
                };
            }
            if (!Object.keys) {
                var hasDontEnumBug = true,
                    dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                    dontEnumsLength = dontEnums.length;

                for (var key in { "toString": null }) {
                    hasDontEnumBug = false;
                }

                Object.keys = function keys(object) {

                    if (typeof object != "object" && typeof object != "function" || object === null) {
                        throw new TypeError("Object.keys called on a non-object");
                    }

                    var keys = [];
                    for (var name in object) {
                        if (owns(object, name)) {
                            keys.push(name);
                        }
                    }

                    if (hasDontEnumBug) {
                        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                            var dontEnum = dontEnums[i];
                            if (owns(object, dontEnum)) {
                                keys.push(dontEnum);
                            }
                        }
                    }
                    return keys;
                };
            }
            if (!Date.now) {
                Date.now = function now() {
                    return new Date().getTime();
                };
            }
            var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
            if (!String.prototype.trim || ws.trim()) {
                ws = "[" + ws + "]";
                var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
                    trimEndRegexp = new RegExp(ws + ws + "*$");
                String.prototype.trim = function trim() {
                    return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
                };
            }

            function toInteger(n) {
                n = +n;
                if (n !== n) {
                    // isNaN
                    n = 0;
                } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
                return n;
            }

            function isPrimitive(input) {
                var type = typeof input;
                return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
            }

            function toPrimitive(input) {
                var val, valueOf, toString;
                if (isPrimitive(input)) {
                    return input;
                }
                valueOf = input.valueOf;
                if (typeof valueOf === "function") {
                    val = valueOf.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                toString = input.toString;
                if (typeof toString === "function") {
                    val = toString.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                throw new TypeError();
            }
            var toObject = function (o) {
                if (o == null) {
                    // this matches both null and undefined
                    throw new TypeError("can't convert " + o + " to object");
                }
                return Object(o);
            };
        });

        ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function (require, exports, module) {
            "use strict";

            require("./regexp");
            require("./es5-shim");
        });

        ace.define("ace/lib/dom", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var XHTML_NS = "http://www.w3.org/1999/xhtml";

            exports.getDocumentHead = function (doc) {
                if (!doc) doc = document;
                return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
            };

            exports.createElement = function (tag, ns) {
                return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
            };

            exports.hasCssClass = function (el, name) {
                var classes = (el.className + "").split(/\s+/g);
                return classes.indexOf(name) !== -1;
            };
            exports.addCssClass = function (el, name) {
                if (!exports.hasCssClass(el, name)) {
                    el.className += " " + name;
                }
            };
            exports.removeCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g);
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    classes.splice(index, 1);
                }
                el.className = classes.join(" ");
            };

            exports.toggleCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g),
                    add = true;
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    add = false;
                    classes.splice(index, 1);
                }
                if (add) classes.push(name);

                el.className = classes.join(" ");
                return add;
            };
            exports.setCssClass = function (node, className, include) {
                if (include) {
                    exports.addCssClass(node, className);
                } else {
                    exports.removeCssClass(node, className);
                }
            };

            exports.hasCssString = function (id, doc) {
                var index = 0,
                    sheets;
                doc = doc || document;

                if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
                    while (index < sheets.length) if (sheets[index++].owningElement.id === id) return true;
                } else if (sheets = doc.getElementsByTagName("style")) {
                    while (index < sheets.length) if (sheets[index++].id === id) return true;
                }

                return false;
            };

            exports.importCssString = function importCssString(cssText, id, doc) {
                doc = doc || document;
                if (id && exports.hasCssString(id, doc)) return null;

                var style;

                if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";

                if (doc.createStyleSheet) {
                    style = doc.createStyleSheet();
                    style.cssText = cssText;
                    if (id) style.owningElement.id = id;
                } else {
                    style = exports.createElement("style");
                    style.appendChild(doc.createTextNode(cssText));
                    if (id) style.id = id;

                    exports.getDocumentHead(doc).appendChild(style);
                }
            };

            exports.importCssStylsheet = function (uri, doc) {
                if (doc.createStyleSheet) {
                    doc.createStyleSheet(uri);
                } else {
                    var link = exports.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = uri;

                    exports.getDocumentHead(doc).appendChild(link);
                }
            };

            exports.getInnerWidth = function (element) {
                return parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth;
            };

            exports.getInnerHeight = function (element) {
                return parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight;
            };

            exports.scrollbarWidth = function (document) {
                var inner = exports.createElement("ace_inner");
                inner.style.width = "100%";
                inner.style.minWidth = "0px";
                inner.style.height = "200px";
                inner.style.display = "block";

                var outer = exports.createElement("ace_outer");
                var style = outer.style;

                style.position = "absolute";
                style.left = "-10000px";
                style.overflow = "hidden";
                style.width = "200px";
                style.minWidth = "0px";
                style.height = "150px";
                style.display = "block";

                outer.appendChild(inner);

                var body = document.documentElement;
                body.appendChild(outer);

                var noScrollbar = inner.offsetWidth;

                style.overflow = "scroll";
                var withScrollbar = inner.offsetWidth;

                if (noScrollbar == withScrollbar) {
                    withScrollbar = outer.clientWidth;
                }

                body.removeChild(outer);

                return noScrollbar - withScrollbar;
            };

            if (typeof document == "undefined") {
                exports.importCssString = function () {};
                return;
            }

            if (window.pageYOffset !== undefined) {
                exports.getPageScrollTop = function () {
                    return window.pageYOffset;
                };

                exports.getPageScrollLeft = function () {
                    return window.pageXOffset;
                };
            } else {
                exports.getPageScrollTop = function () {
                    return document.body.scrollTop;
                };

                exports.getPageScrollLeft = function () {
                    return document.body.scrollLeft;
                };
            }

            if (window.getComputedStyle) exports.computedStyle = function (element, style) {
                if (style) return (window.getComputedStyle(element, "") || {})[style] || "";
                return window.getComputedStyle(element, "") || {};
            };else exports.computedStyle = function (element, style) {
                if (style) return element.currentStyle[style];
                return element.currentStyle;
            };
            exports.setInnerHtml = function (el, innerHtml) {
                var element = el.cloneNode(false); //document.createElement("div");
                element.innerHTML = innerHtml;
                el.parentNode.replaceChild(element, el);
                return element;
            };

            if ("textContent" in document.documentElement) {
                exports.setInnerText = function (el, innerText) {
                    el.textContent = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.textContent;
                };
            } else {
                exports.setInnerText = function (el, innerText) {
                    el.innerText = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.innerText;
                };
            }

            exports.getParentWindow = function (document) {
                return document.defaultView || document.parentWindow;
            };
        });

        ace.define("ace/lib/oop", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.inherits = function (ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };

            exports.mixin = function (obj, mixin) {
                for (var key in mixin) {
                    obj[key] = mixin[key];
                }
                return obj;
            };

            exports.implement = function (proto, mixin) {
                exports.mixin(proto, mixin);
            };
        });

        ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            require("./fixoldbrowsers");

            var oop = require("./oop");
            var Keys = function () {
                var ret = {
                    MODIFIER_KEYS: {
                        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
                    },

                    KEY_MODS: {
                        "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
                        "super": 8, "meta": 8, "command": 8, "cmd": 8
                    },

                    FUNCTION_KEYS: {
                        8: "Backspace",
                        9: "Tab",
                        13: "Return",
                        19: "Pause",
                        27: "Esc",
                        32: "Space",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "Left",
                        38: "Up",
                        39: "Right",
                        40: "Down",
                        44: "Print",
                        45: "Insert",
                        46: "Delete",
                        96: "Numpad0",
                        97: "Numpad1",
                        98: "Numpad2",
                        99: "Numpad3",
                        100: "Numpad4",
                        101: "Numpad5",
                        102: "Numpad6",
                        103: "Numpad7",
                        104: "Numpad8",
                        105: "Numpad9",
                        '-13': "NumpadEnter",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "Numlock",
                        145: "Scrolllock"
                    },

                    PRINTABLE_KEYS: {
                        32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
                        54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
                        66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
                        73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
                        80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
                        87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
                        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
                        219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
                    }
                };
                var name, i;
                for (i in ret.FUNCTION_KEYS) {
                    name = ret.FUNCTION_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                for (i in ret.PRINTABLE_KEYS) {
                    name = ret.PRINTABLE_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                oop.mixin(ret, ret.MODIFIER_KEYS);
                oop.mixin(ret, ret.PRINTABLE_KEYS);
                oop.mixin(ret, ret.FUNCTION_KEYS);
                ret.enter = ret["return"];
                ret.escape = ret.esc;
                ret.del = ret["delete"];
                ret[173] = '-';

                (function () {
                    var mods = ["cmd", "ctrl", "alt", "shift"];
                    for (var i = Math.pow(2, mods.length); i--;) {
                        ret.KEY_MODS[i] = mods.filter(function (x) {
                            return i & ret.KEY_MODS[x];
                        }).join("-") + "-";
                    }
                })();

                ret.KEY_MODS[0] = "";
                ret.KEY_MODS[-1] = "input-";

                return ret;
            }();
            oop.mixin(exports, Keys);

            exports.keyCodeToString = function (keyCode) {
                var keyString = Keys[keyCode];
                if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
                return keyString.toLowerCase();
            };
        });

        ace.define("ace/lib/useragent", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.OS = {
                LINUX: "LINUX",
                MAC: "MAC",
                WINDOWS: "WINDOWS"
            };
            exports.getOS = function () {
                if (exports.isMac) {
                    return exports.OS.MAC;
                } else if (exports.isLinux) {
                    return exports.OS.LINUX;
                } else {
                    return exports.OS.WINDOWS;
                }
            };
            if (typeof navigator != "object") return;

            var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
            var ua = navigator.userAgent;
            exports.isWin = os == "win";
            exports.isMac = os == "mac";
            exports.isLinux = os == "linux";
            exports.isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie

            exports.isOldIE = exports.isIE && exports.isIE < 9;
            exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
            exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
            exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
            exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

            exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

            exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

            exports.isIPad = ua.indexOf("iPad") >= 0;

            exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

            exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
        });

        ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keys = require("./keys");
            var useragent = require("./useragent");

            var pressedKeys = null;
            var ts = 0;

            exports.addListener = function (elem, type, callback) {
                if (elem.addEventListener) {
                    return elem.addEventListener(type, callback, false);
                }
                if (elem.attachEvent) {
                    var wrapper = function () {
                        callback.call(elem, window.event);
                    };
                    callback._wrapper = wrapper;
                    elem.attachEvent("on" + type, wrapper);
                }
            };

            exports.removeListener = function (elem, type, callback) {
                if (elem.removeEventListener) {
                    return elem.removeEventListener(type, callback, false);
                }
                if (elem.detachEvent) {
                    elem.detachEvent("on" + type, callback._wrapper || callback);
                }
            };
            exports.stopEvent = function (e) {
                exports.stopPropagation(e);
                exports.preventDefault(e);
                return false;
            };

            exports.stopPropagation = function (e) {
                if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
            };

            exports.preventDefault = function (e) {
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
            };
            exports.getButton = function (e) {
                if (e.type == "dblclick") return 0;
                if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
                if (e.preventDefault) {
                    return e.button;
                } else {
                    return { 1: 0, 2: 2, 4: 1 }[e.button];
                }
            };

            exports.capture = function (el, eventHandler, releaseCaptureHandler) {
                function onMouseUp(e) {
                    eventHandler && eventHandler(e);
                    releaseCaptureHandler && releaseCaptureHandler(e);

                    exports.removeListener(document, "mousemove", eventHandler, true);
                    exports.removeListener(document, "mouseup", onMouseUp, true);
                    exports.removeListener(document, "dragstart", onMouseUp, true);
                }

                exports.addListener(document, "mousemove", eventHandler, true);
                exports.addListener(document, "mouseup", onMouseUp, true);
                exports.addListener(document, "dragstart", onMouseUp, true);

                return onMouseUp;
            };

            exports.addTouchMoveListener = function (el, callback) {
                if ("ontouchmove" in el) {
                    var startx, starty;
                    exports.addListener(el, "touchstart", function (e) {
                        var touchObj = e.changedTouches[0];
                        startx = touchObj.clientX;
                        starty = touchObj.clientY;
                    });
                    exports.addListener(el, "touchmove", function (e) {
                        var factor = 1,
                            touchObj = e.changedTouches[0];

                        e.wheelX = -(touchObj.clientX - startx) / factor;
                        e.wheelY = -(touchObj.clientY - starty) / factor;

                        startx = touchObj.clientX;
                        starty = touchObj.clientY;

                        callback(e);
                    });
                }
            };

            exports.addMouseWheelListener = function (el, callback) {
                if ("onmousewheel" in el) {
                    exports.addListener(el, "mousewheel", function (e) {
                        var factor = 8;
                        if (e.wheelDeltaX !== undefined) {
                            e.wheelX = -e.wheelDeltaX / factor;
                            e.wheelY = -e.wheelDeltaY / factor;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = -e.wheelDelta / factor;
                        }
                        callback(e);
                    });
                } else if ("onwheel" in el) {
                    exports.addListener(el, "wheel", function (e) {
                        var factor = 0.35;
                        switch (e.deltaMode) {
                            case e.DOM_DELTA_PIXEL:
                                e.wheelX = e.deltaX * factor || 0;
                                e.wheelY = e.deltaY * factor || 0;
                                break;
                            case e.DOM_DELTA_LINE:
                            case e.DOM_DELTA_PAGE:
                                e.wheelX = (e.deltaX || 0) * 5;
                                e.wheelY = (e.deltaY || 0) * 5;
                                break;
                        }

                        callback(e);
                    });
                } else {
                    exports.addListener(el, "DOMMouseScroll", function (e) {
                        if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                            e.wheelX = (e.detail || 0) * 5;
                            e.wheelY = 0;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = (e.detail || 0) * 5;
                        }
                        callback(e);
                    });
                }
            };

            exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName) {
                var clicks = 0;
                var startX, startY, timer;
                var eventNames = {
                    2: "dblclick",
                    3: "tripleclick",
                    4: "quadclick"
                };

                function onMousedown(e) {
                    if (exports.getButton(e) !== 0) {
                        clicks = 0;
                    } else if (e.detail > 1) {
                        clicks++;
                        if (clicks > 4) clicks = 1;
                    } else {
                        clicks = 1;
                    }
                    if (useragent.isIE) {
                        var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                        if (!timer || isNewClick) clicks = 1;
                        if (timer) clearTimeout(timer);
                        timer = setTimeout(function () {
                            timer = null;
                        }, timeouts[clicks - 1] || 600);

                        if (clicks == 1) {
                            startX = e.clientX;
                            startY = e.clientY;
                        }
                    }

                    e._clicks = clicks;

                    eventHandler[callbackName]("mousedown", e);

                    if (clicks > 4) clicks = 0;else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
                }
                function onDblclick(e) {
                    clicks = 2;
                    if (timer) clearTimeout(timer);
                    timer = setTimeout(function () {
                        timer = null;
                    }, timeouts[clicks - 1] || 600);
                    eventHandler[callbackName]("mousedown", e);
                    eventHandler[callbackName](eventNames[clicks], e);
                }
                if (!Array.isArray(elements)) elements = [elements];
                elements.forEach(function (el) {
                    exports.addListener(el, "mousedown", onMousedown);
                    if (useragent.isOldIE) exports.addListener(el, "dblclick", onDblclick);
                });
            };

            var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function (e) {
                return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
            } : function (e) {
                return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
            };

            exports.getModifierString = function (e) {
                return keys.KEY_MODS[getModifierHash(e)];
            };

            function normalizeCommandKeys(callback, e, keyCode) {
                var hashId = getModifierHash(e);

                if (!useragent.isMac && pressedKeys) {
                    if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
                    if (pressedKeys.altGr) {
                        if ((3 & hashId) != 3) pressedKeys.altGr = 0;else return;
                    }
                    if (keyCode === 18 || keyCode === 17) {
                        var location = "location" in e ? e.location : e.keyLocation;
                        if (keyCode === 17 && location === 1) {
                            if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
                        } else if (keyCode === 18 && hashId === 3 && location === 2) {
                            var dt = e.timeStamp - ts;
                            if (dt < 50) pressedKeys.altGr = true;
                        }
                    }
                }

                if (keyCode in keys.MODIFIER_KEYS) {
                    keyCode = -1;
                }
                if (hashId & 8 && keyCode >= 91 && keyCode <= 93) {
                    keyCode = -1;
                }

                if (!hashId && keyCode === 13) {
                    var location = "location" in e ? e.location : e.keyLocation;
                    if (location === 3) {
                        callback(e, hashId, -keyCode);
                        if (e.defaultPrevented) return;
                    }
                }

                if (useragent.isChromeOS && hashId & 8) {
                    callback(e, hashId, keyCode);
                    if (e.defaultPrevented) return;else hashId &= ~8;
                }
                if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                    return false;
                }

                return callback(e, hashId, keyCode);
            }

            exports.addCommandKeyListener = function (el, callback) {
                var addListener = exports.addListener;
                if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                    var lastKeyDownKeyCode = null;
                    addListener(el, "keydown", function (e) {
                        lastKeyDownKeyCode = e.keyCode;
                    });
                    addListener(el, "keypress", function (e) {
                        return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                    });
                } else {
                    var lastDefaultPrevented = null;

                    addListener(el, "keydown", function (e) {
                        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                        var result = normalizeCommandKeys(callback, e, e.keyCode);
                        lastDefaultPrevented = e.defaultPrevented;
                        return result;
                    });

                    addListener(el, "keypress", function (e) {
                        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                            exports.stopEvent(e);
                            lastDefaultPrevented = null;
                        }
                    });

                    addListener(el, "keyup", function (e) {
                        pressedKeys[e.keyCode] = null;
                    });

                    if (!pressedKeys) {
                        resetPressedKeys();
                        addListener(window, "focus", resetPressedKeys);
                    }
                }
            };
            function resetPressedKeys() {
                pressedKeys = Object.create(null);
            }

            if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                var postMessageId = 1;
                exports.nextTick = function (callback, win) {
                    win = win || window;
                    var messageName = "zero-timeout-message-" + postMessageId;
                    exports.addListener(win, "message", function listener(e) {
                        if (e.data == messageName) {
                            exports.stopPropagation(e);
                            exports.removeListener(win, "message", listener);
                            callback();
                        }
                    });
                    win.postMessage(messageName, "*");
                };
            }

            exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);

            if (exports.nextFrame) exports.nextFrame = exports.nextFrame.bind(window);else exports.nextFrame = function (callback) {
                setTimeout(callback, 17);
            };
        });

        ace.define("ace/lib/lang", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.last = function (a) {
                return a[a.length - 1];
            };

            exports.stringReverse = function (string) {
                return string.split("").reverse().join("");
            };

            exports.stringRepeat = function (string, count) {
                var result = '';
                while (count > 0) {
                    if (count & 1) result += string;

                    if (count >>= 1) string += string;
                }
                return result;
            };

            var trimBeginRegexp = /^\s\s*/;
            var trimEndRegexp = /\s\s*$/;

            exports.stringTrimLeft = function (string) {
                return string.replace(trimBeginRegexp, '');
            };

            exports.stringTrimRight = function (string) {
                return string.replace(trimEndRegexp, '');
            };

            exports.copyObject = function (obj) {
                var copy = {};
                for (var key in obj) {
                    copy[key] = obj[key];
                }
                return copy;
            };

            exports.copyArray = function (array) {
                var copy = [];
                for (var i = 0, l = array.length; i < l; i++) {
                    if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
                }
                return copy;
            };

            exports.deepCopy = function deepCopy(obj) {
                if (typeof obj !== "object" || !obj) return obj;
                var copy;
                if (Array.isArray(obj)) {
                    copy = [];
                    for (var key = 0; key < obj.length; key++) {
                        copy[key] = deepCopy(obj[key]);
                    }
                    return copy;
                }
                if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;

                copy = {};
                for (var key in obj) copy[key] = deepCopy(obj[key]);
                return copy;
            };

            exports.arrayToMap = function (arr) {
                var map = {};
                for (var i = 0; i < arr.length; i++) {
                    map[arr[i]] = 1;
                }
                return map;
            };

            exports.createMap = function (props) {
                var map = Object.create(null);
                for (var i in props) {
                    map[i] = props[i];
                }
                return map;
            };
            exports.arrayRemove = function (array, value) {
                for (var i = 0; i <= array.length; i++) {
                    if (value === array[i]) {
                        array.splice(i, 1);
                    }
                }
            };

            exports.escapeRegExp = function (str) {
                return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
            };

            exports.escapeHTML = function (str) {
                return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
            };

            exports.getMatchOffsets = function (string, regExp) {
                var matches = [];

                string.replace(regExp, function (str) {
                    matches.push({
                        offset: arguments[arguments.length - 2],
                        length: str.length
                    });
                });

                return matches;
            };
            exports.deferredCall = function (fcn) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var deferred = function (timeout) {
                    deferred.cancel();
                    timer = setTimeout(callback, timeout || 0);
                    return deferred;
                };

                deferred.schedule = deferred;

                deferred.call = function () {
                    this.cancel();
                    fcn();
                    return deferred;
                };

                deferred.cancel = function () {
                    clearTimeout(timer);
                    timer = null;
                    return deferred;
                };

                deferred.isPending = function () {
                    return timer;
                };

                return deferred;
            };

            exports.delayedCall = function (fcn, defaultTimeout) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var _self = function (timeout) {
                    if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
                };

                _self.delay = function (timeout) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(callback, timeout || defaultTimeout);
                };
                _self.schedule = _self;

                _self.call = function () {
                    this.cancel();
                    fcn();
                };

                _self.cancel = function () {
                    timer && clearTimeout(timer);
                    timer = null;
                };

                _self.isPending = function () {
                    return timer;
                };

                return _self;
            };
        });

        ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var BROKEN_SETDATA = useragent.isChrome < 18;
            var USE_IE_MIME_TYPE = useragent.isIE;

            var TextInput = function (parentNode, host) {
                var text = dom.createElement("textarea");
                text.className = "ace_text-input";

                if (useragent.isTouchPad) text.setAttribute("x-palm-disable-auto-cap", true);

                text.setAttribute("wrap", "off");
                text.setAttribute("autocorrect", "off");
                text.setAttribute("autocapitalize", "off");
                text.setAttribute("spellcheck", false);

                text.style.opacity = "0";
                if (useragent.isOldIE) text.style.top = "-1000px";
                parentNode.insertBefore(text, parentNode.firstChild);

                var PLACEHOLDER = "\x01\x01";

                var copied = false;
                var pasted = false;
                var inComposition = false;
                var tempStyle = '';
                var isSelectionEmpty = true;
                try {
                    var isFocused = document.activeElement === text;
                } catch (e) {}

                event.addListener(text, "blur", function (e) {
                    host.onBlur(e);
                    isFocused = false;
                });
                event.addListener(text, "focus", function (e) {
                    isFocused = true;
                    host.onFocus(e);
                    resetSelection();
                });
                this.focus = function () {
                    if (tempStyle) return text.focus();
                    var top = text.style.top;
                    text.style.position = "fixed";
                    text.style.top = "0px";
                    text.focus();
                    setTimeout(function () {
                        text.style.position = "";
                        if (text.style.top == "0px") text.style.top = top;
                    }, 0);
                };
                this.blur = function () {
                    text.blur();
                };
                this.isFocused = function () {
                    return isFocused;
                };
                var syncSelection = lang.delayedCall(function () {
                    isFocused && resetSelection(isSelectionEmpty);
                });
                var syncValue = lang.delayedCall(function () {
                    if (!inComposition) {
                        text.value = PLACEHOLDER;
                        isFocused && resetSelection();
                    }
                });

                function resetSelection(isEmpty) {
                    if (inComposition) return;
                    inComposition = true;

                    if (inputHandler) {
                        selectionStart = 0;
                        selectionEnd = isEmpty ? 0 : text.value.length - 1;
                    } else {
                        var selectionStart = isEmpty ? 2 : 1;
                        var selectionEnd = 2;
                    }
                    try {
                        text.setSelectionRange(selectionStart, selectionEnd);
                    } catch (e) {}

                    inComposition = false;
                }

                function resetValue() {
                    if (inComposition) return;
                    text.value = PLACEHOLDER;
                    if (useragent.isWebKit) syncValue.schedule();
                }

                useragent.isWebKit || host.addEventListener('changeSelection', function () {
                    if (host.selection.isEmpty() != isSelectionEmpty) {
                        isSelectionEmpty = !isSelectionEmpty;
                        syncSelection.schedule();
                    }
                });

                resetValue();
                if (isFocused) host.onFocus();

                var isAllSelected = function (text) {
                    return text.selectionStart === 0 && text.selectionEnd === text.value.length;
                };
                if (!text.setSelectionRange && text.createTextRange) {
                    text.setSelectionRange = function (selectionStart, selectionEnd) {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveStart('character', selectionStart);
                        range.moveEnd('character', selectionEnd);
                        range.select();
                    };
                    isAllSelected = function (text) {
                        try {
                            var range = text.ownerDocument.selection.createRange();
                        } catch (e) {}
                        if (!range || range.parentElement() != text) return false;
                        return range.text == text.value;
                    };
                }
                if (useragent.isOldIE) {
                    var inPropertyChange = false;
                    var onPropertyChange = function (e) {
                        if (inPropertyChange) return;
                        var data = text.value;
                        if (inComposition || !data || data == PLACEHOLDER) return;
                        if (e && data == PLACEHOLDER[0]) return syncProperty.schedule();

                        sendText(data);
                        inPropertyChange = true;
                        resetValue();
                        inPropertyChange = false;
                    };
                    var syncProperty = lang.delayedCall(onPropertyChange);
                    event.addListener(text, "propertychange", onPropertyChange);

                    var keytable = { 13: 1, 27: 1 };
                    event.addListener(text, "keyup", function (e) {
                        if (inComposition && (!text.value || keytable[e.keyCode])) setTimeout(onCompositionEnd, 0);
                        if ((text.value.charCodeAt(0) || 0) < 129) {
                            return syncProperty.call();
                        }
                        inComposition ? onCompositionUpdate() : onCompositionStart();
                    });
                    event.addListener(text, "keydown", function (e) {
                        syncProperty.schedule(50);
                    });
                }

                var onSelect = function (e) {
                    if (copied) {
                        copied = false;
                    } else if (isAllSelected(text)) {
                        host.selectAll();
                        resetSelection();
                    } else if (inputHandler) {
                        resetSelection(host.selection.isEmpty());
                    }
                };

                var inputHandler = null;
                this.setInputHandler = function (cb) {
                    inputHandler = cb;
                };
                this.getInputHandler = function () {
                    return inputHandler;
                };
                var afterContextMenu = false;

                var sendText = function (data) {
                    if (inputHandler) {
                        data = inputHandler(data);
                        inputHandler = null;
                    }
                    if (pasted) {
                        resetSelection();
                        if (data) host.onPaste(data);
                        pasted = false;
                    } else if (data == PLACEHOLDER.charAt(0)) {
                        if (afterContextMenu) host.execCommand("del", { source: "ace" });else // some versions of android do not fire keydown when pressing backspace
                            host.execCommand("backspace", { source: "ace" });
                    } else {
                        if (data.substring(0, 2) == PLACEHOLDER) data = data.substr(2);else if (data.charAt(0) == PLACEHOLDER.charAt(0)) data = data.substr(1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
                        if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);

                        if (data) host.onTextInput(data);
                    }
                    if (afterContextMenu) afterContextMenu = false;
                };
                var onInput = function (e) {
                    if (inComposition) return;
                    var data = text.value;
                    sendText(data);
                    resetValue();
                };

                var handleClipboardData = function (e, data, forceIEMime) {
                    var clipboardData = e.clipboardData || window.clipboardData;
                    if (!clipboardData || BROKEN_SETDATA) return;
                    var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                    try {
                        if (data) {
                            return clipboardData.setData(mime, data) !== false;
                        } else {
                            return clipboardData.getData(mime);
                        }
                    } catch (e) {
                        if (!forceIEMime) return handleClipboardData(e, data, true);
                    }
                };

                var doCopy = function (e, isCut) {
                    var data = host.getCopyText();
                    if (!data) return event.preventDefault(e);

                    if (handleClipboardData(e, data)) {
                        isCut ? host.onCut() : host.onCopy();
                        event.preventDefault(e);
                    } else {
                        copied = true;
                        text.value = data;
                        text.select();
                        setTimeout(function () {
                            copied = false;
                            resetValue();
                            resetSelection();
                            isCut ? host.onCut() : host.onCopy();
                        });
                    }
                };

                var onCut = function (e) {
                    doCopy(e, true);
                };

                var onCopy = function (e) {
                    doCopy(e, false);
                };

                var onPaste = function (e) {
                    var data = handleClipboardData(e);
                    if (typeof data == "string") {
                        if (data) host.onPaste(data, e);
                        if (useragent.isIE) setTimeout(resetSelection);
                        event.preventDefault(e);
                    } else {
                        text.value = "";
                        pasted = true;
                    }
                };

                event.addCommandKeyListener(text, host.onCommandKey.bind(host));

                event.addListener(text, "select", onSelect);

                event.addListener(text, "input", onInput);

                event.addListener(text, "cut", onCut);
                event.addListener(text, "copy", onCopy);
                event.addListener(text, "paste", onPaste);
                if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
                    event.addListener(parentNode, "keydown", function (e) {
                        if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;

                        switch (e.keyCode) {
                            case 67:
                                onCopy(e);
                                break;
                            case 86:
                                onPaste(e);
                                break;
                            case 88:
                                onCut(e);
                                break;
                        }
                    });
                }
                var onCompositionStart = function (e) {
                    if (inComposition || !host.onCompositionStart || host.$readOnly) return;
                    inComposition = {};
                    inComposition.canUndo = host.session.$undoManager;
                    host.onCompositionStart();
                    setTimeout(onCompositionUpdate, 0);
                    host.on("mousedown", onCompositionEnd);
                    if (inComposition.canUndo && !host.selection.isEmpty()) {
                        host.insert("");
                        host.session.markUndoGroup();
                        host.selection.clearSelection();
                    }
                    host.session.markUndoGroup();
                };

                var onCompositionUpdate = function () {
                    if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
                    var val = text.value.replace(/\x01/g, "");
                    if (inComposition.lastValue === val) return;

                    host.onCompositionUpdate(val);
                    if (inComposition.lastValue) host.undo();
                    if (inComposition.canUndo) inComposition.lastValue = val;
                    if (inComposition.lastValue) {
                        var r = host.selection.getRange();
                        host.insert(inComposition.lastValue);
                        host.session.markUndoGroup();
                        inComposition.range = host.selection.getRange();
                        host.selection.setRange(r);
                        host.selection.clearSelection();
                    }
                };

                var onCompositionEnd = function (e) {
                    if (!host.onCompositionEnd || host.$readOnly) return;
                    var c = inComposition;
                    inComposition = false;
                    var timer = setTimeout(function () {
                        timer = null;
                        var str = text.value.replace(/\x01/g, "");
                        if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
                            resetValue();
                            sendText(str);
                        }
                    });
                    inputHandler = function compositionInputHandler(str) {
                        if (timer) clearTimeout(timer);
                        str = str.replace(/\x01/g, "");
                        if (str == c.lastValue) return "";
                        if (c.lastValue && timer) host.undo();
                        return str;
                    };
                    host.onCompositionEnd();
                    host.removeListener("mousedown", onCompositionEnd);
                    if (e.type == "compositionend" && c.range) {
                        host.selection.setRange(c.range);
                    }
                };

                var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

                event.addListener(text, "compositionstart", onCompositionStart);
                if (useragent.isGecko) {
                    event.addListener(text, "text", function () {
                        syncComposition.schedule();
                    });
                } else {
                    event.addListener(text, "keyup", function () {
                        syncComposition.schedule();
                    });
                    event.addListener(text, "keydown", function () {
                        syncComposition.schedule();
                    });
                }
                event.addListener(text, "compositionend", onCompositionEnd);

                this.getElement = function () {
                    return text;
                };

                this.setReadOnly = function (readOnly) {
                    text.readOnly = readOnly;
                };

                this.onContextMenu = function (e) {
                    afterContextMenu = true;
                    resetSelection(host.selection.isEmpty());
                    host._emit("nativecontextmenu", { target: host, domEvent: e });
                    this.moveToMouse(e, true);
                };

                this.moveToMouse = function (e, bringToFront) {
                    if (!bringToFront && useragent.isOldIE) return;
                    if (!tempStyle) tempStyle = text.style.cssText;
                    text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");

                    var rect = host.container.getBoundingClientRect();
                    var style = dom.computedStyle(host.container);
                    var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                    var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                    var maxTop = rect.bottom - top - text.clientHeight - 2;
                    var move = function (e) {
                        text.style.left = e.clientX - left - 2 + "px";
                        text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
                    };
                    move(e);

                    if (e.type != "mousedown") return;

                    if (host.renderer.$keepTextAreaAtCursor) host.renderer.$keepTextAreaAtCursor = null;

                    clearTimeout(closeTimeout);
                    if (useragent.isWin && !useragent.isOldIE) event.capture(host.container, move, onContextMenuClose);
                };

                this.onContextMenuClose = onContextMenuClose;
                var closeTimeout;
                function onContextMenuClose() {
                    clearTimeout(closeTimeout);
                    closeTimeout = setTimeout(function () {
                        if (tempStyle) {
                            text.style.cssText = tempStyle;
                            tempStyle = '';
                        }
                        if (host.renderer.$keepTextAreaAtCursor == null) {
                            host.renderer.$keepTextAreaAtCursor = true;
                            host.renderer.$moveTextAreaToCursor();
                        }
                    }, useragent.isOldIE ? 200 : 0);
                }

                var onContextMenu = function (e) {
                    host.textInput.onContextMenu(e);
                    onContextMenuClose();
                };
                event.addListener(text, "mouseup", onContextMenu);
                event.addListener(text, "mousedown", function (e) {
                    e.preventDefault();
                    onContextMenuClose();
                });
                event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
                event.addListener(text, "contextmenu", onContextMenu);
            };

            exports.TextInput = TextInput;
        });

        ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var DRAG_OFFSET = 0; // pixels

            function DefaultHandlers(mouseHandler) {
                mouseHandler.$clickSelection = null;

                var editor = mouseHandler.editor;
                editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
                editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
                editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

                var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);

                mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
                mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
            }

            (function () {

                this.onMouseDown = function (ev) {
                    var inSelection = ev.inSelection();
                    var pos = ev.getDocumentPosition();
                    this.mousedownEvent = ev;
                    var editor = this.editor;

                    var button = ev.getButton();
                    if (button !== 0) {
                        var selectionRange = editor.getSelectionRange();
                        var selectionEmpty = selectionRange.isEmpty();
                        editor.$blockScrolling++;
                        if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
                        editor.$blockScrolling--;
                        if (button == 2) editor.textInput.onContextMenu(ev.domEvent);
                        return; // stopping event here breaks contextmenu on ff mac
                    }

                    this.mousedownEvent.time = Date.now();
                    if (inSelection && !editor.isFocused()) {
                        editor.focus();
                        if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                            this.setState("focusWait");
                            this.captureMouse(ev);
                            return;
                        }
                    }

                    this.captureMouse(ev);
                    this.startSelect(pos, ev.domEvent._clicks > 1);
                    return ev.preventDefault();
                };

                this.startSelect = function (pos, waitForClickSelection) {
                    pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var editor = this.editor;
                    editor.$blockScrolling++;
                    if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
                    if (!waitForClickSelection) this.select();
                    if (editor.renderer.scroller.setCapture) {
                        editor.renderer.scroller.setCapture();
                    }
                    editor.setStyle("ace_selecting");
                    this.setState("select");
                    editor.$blockScrolling--;
                };

                this.select = function () {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmp = this.$clickSelection.comparePoint(cursor);

                        if (cmp == -1) {
                            anchor = this.$clickSelection.end;
                        } else if (cmp == 1) {
                            anchor = this.$clickSelection.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.extendSelectionBy = function (unitName) {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var range = editor.selection[unitName](cursor.row, cursor.column);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmpStart = this.$clickSelection.comparePoint(range.start);
                        var cmpEnd = this.$clickSelection.comparePoint(range.end);

                        if (cmpStart == -1 && cmpEnd <= 0) {
                            anchor = this.$clickSelection.end;
                            if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                        } else if (cmpEnd == 1 && cmpStart >= 0) {
                            anchor = this.$clickSelection.start;
                            if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                        } else if (cmpStart == -1 && cmpEnd == 1) {
                            cursor = range.end;
                            anchor = range.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function () {
                    this.$clickSelection = null;
                    this.editor.unsetStyle("ace_selecting");
                    if (this.editor.renderer.scroller.releaseCapture) {
                        this.editor.renderer.scroller.releaseCapture();
                    }
                };

                this.focusWait = function () {
                    var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                    var time = Date.now();

                    if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) this.startSelect(this.mousedownEvent.getDocumentPosition());
                };

                this.onDoubleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;
                    var session = editor.session;

                    var range = session.getBracketRange(pos);
                    if (range) {
                        if (range.isEmpty()) {
                            range.start.column--;
                            range.end.column++;
                        }
                        this.setState("select");
                    } else {
                        range = editor.selection.getWordRange(pos.row, pos.column);
                        this.setState("selectByWords");
                    }
                    this.$clickSelection = range;
                    this.select();
                };

                this.onTripleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;

                    this.setState("selectByLines");
                    var range = editor.getSelectionRange();
                    if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                        this.$clickSelection = editor.selection.getLineRange(range.start.row);
                        this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
                    } else {
                        this.$clickSelection = editor.selection.getLineRange(pos.row);
                    }
                    this.select();
                };

                this.onQuadClick = function (ev) {
                    var editor = this.editor;

                    editor.selectAll();
                    this.$clickSelection = editor.getSelectionRange();
                    this.setState("selectAll");
                };

                this.onMouseWheel = function (ev) {
                    if (ev.getAccelKey()) return;
                    if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                        ev.wheelX = ev.wheelY;
                        ev.wheelY = 0;
                    }

                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };

                this.onTouchMove = function (ev) {
                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };
            }).call(DefaultHandlers.prototype);

            exports.DefaultHandlers = DefaultHandlers;

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            function calcRangeOrientation(range, cursor) {
                if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;else var cmp = 2 * cursor.row - range.start.row - range.end.row;

                if (cmp < 0) return { cursor: range.start, anchor: range.end };else return { cursor: range.end, anchor: range.start };
            }
        });

        ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            function Tooltip(parentNode) {
                this.isOpen = false;
                this.$element = null;
                this.$parentNode = parentNode;
            }

            (function () {
                this.$init = function () {
                    this.$element = dom.createElement("div");
                    this.$element.className = "ace_tooltip";
                    this.$element.style.display = "none";
                    this.$parentNode.appendChild(this.$element);
                    return this.$element;
                };
                this.getElement = function () {
                    return this.$element || this.$init();
                };
                this.setText = function (text) {
                    dom.setInnerText(this.getElement(), text);
                };
                this.setHtml = function (html) {
                    this.getElement().innerHTML = html;
                };
                this.setPosition = function (x, y) {
                    this.getElement().style.left = x + "px";
                    this.getElement().style.top = y + "px";
                };
                this.setClassName = function (className) {
                    dom.addCssClass(this.getElement(), className);
                };
                this.show = function (text, x, y) {
                    if (text != null) this.setText(text);
                    if (x != null && y != null) this.setPosition(x, y);
                    if (!this.isOpen) {
                        this.getElement().style.display = "block";
                        this.isOpen = true;
                    }
                };

                this.hide = function () {
                    if (this.isOpen) {
                        this.getElement().style.display = "none";
                        this.isOpen = false;
                    }
                };
                this.getHeight = function () {
                    return this.getElement().offsetHeight;
                };
                this.getWidth = function () {
                    return this.getElement().offsetWidth;
                };
            }).call(Tooltip.prototype);

            exports.Tooltip = Tooltip;
        });

        ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var event = require("../lib/event");
            var Tooltip = require("../tooltip").Tooltip;

            function GutterHandler(mouseHandler) {
                var editor = mouseHandler.editor;
                var gutter = editor.renderer.$gutterLayer;
                var tooltip = new GutterTooltip(editor.container);

                mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
                    if (!editor.isFocused() || e.getButton() != 0) return;
                    var gutterRegion = gutter.getRegion(e);

                    if (gutterRegion == "foldWidgets") return;

                    var row = e.getDocumentPosition().row;
                    var selection = editor.session.selection;

                    if (e.getShiftKey()) selection.selectTo(row, 0);else {
                        if (e.domEvent.detail == 2) {
                            editor.selectAll();
                            return e.preventDefault();
                        }
                        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                    }
                    mouseHandler.setState("selectByLines");
                    mouseHandler.captureMouse(e);
                    return e.preventDefault();
                });

                var tooltipTimeout, mouseEvent, tooltipAnnotation;

                function showTooltip() {
                    var row = mouseEvent.getDocumentPosition().row;
                    var annotation = gutter.$annotations[row];
                    if (!annotation) return hideTooltip();

                    var maxRow = editor.session.getLength();
                    if (row == maxRow) {
                        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                        var pos = mouseEvent.$pos;
                        if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
                    }

                    if (tooltipAnnotation == annotation) return;
                    tooltipAnnotation = annotation.text.join("<br/>");

                    tooltip.setHtml(tooltipAnnotation);
                    tooltip.show();
                    editor._signal("showGutterTooltip", tooltip);
                    editor.on("mousewheel", hideTooltip);

                    if (mouseHandler.$tooltipFollowsMouse) {
                        moveTooltip(mouseEvent);
                    } else {
                        var gutterElement = mouseEvent.domEvent.target;
                        var rect = gutterElement.getBoundingClientRect();
                        var style = tooltip.getElement().style;
                        style.left = rect.right + "px";
                        style.top = rect.bottom + "px";
                    }
                }

                function hideTooltip() {
                    if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
                    if (tooltipAnnotation) {
                        tooltip.hide();
                        tooltipAnnotation = null;
                        editor._signal("hideGutterTooltip", tooltip);
                        editor.removeEventListener("mousewheel", hideTooltip);
                    }
                }

                function moveTooltip(e) {
                    tooltip.setPosition(e.x, e.y);
                }

                mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
                    var target = e.domEvent.target || e.domEvent.srcElement;
                    if (dom.hasCssClass(target, "ace_fold-widget")) return hideTooltip();

                    if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);

                    mouseEvent = e;
                    if (tooltipTimeout) return;
                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();else hideTooltip();
                    }, 50);
                });

                event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
                    mouseEvent = null;
                    if (!tooltipAnnotation || tooltipTimeout) return;

                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        hideTooltip();
                    }, 50);
                });

                editor.on("changeSession", hideTooltip);
            }

            function GutterTooltip(parentNode) {
                Tooltip.call(this, parentNode);
            }

            oop.inherits(GutterTooltip, Tooltip);

            (function () {
                this.setPosition = function (x, y) {
                    var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                    var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                    var width = this.getWidth();
                    var height = this.getHeight();
                    x += 15;
                    y += 15;
                    if (x + width > windowWidth) {
                        x -= x + width - windowWidth;
                    }
                    if (y + height > windowHeight) {
                        y -= 20 + height;
                    }
                    Tooltip.prototype.setPosition.call(this, x, y);
                };
            }).call(GutterTooltip.prototype);

            exports.GutterHandler = GutterHandler;
        });

        ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
                this.domEvent = domEvent;
                this.editor = editor;

                this.x = this.clientX = domEvent.clientX;
                this.y = this.clientY = domEvent.clientY;

                this.$pos = null;
                this.$inSelection = null;

                this.propagationStopped = false;
                this.defaultPrevented = false;
            };

            (function () {

                this.stopPropagation = function () {
                    event.stopPropagation(this.domEvent);
                    this.propagationStopped = true;
                };

                this.preventDefault = function () {
                    event.preventDefault(this.domEvent);
                    this.defaultPrevented = true;
                };

                this.stop = function () {
                    this.stopPropagation();
                    this.preventDefault();
                };
                this.getDocumentPosition = function () {
                    if (this.$pos) return this.$pos;

                    this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                    return this.$pos;
                };
                this.inSelection = function () {
                    if (this.$inSelection !== null) return this.$inSelection;

                    var editor = this.editor;

                    var selectionRange = editor.getSelectionRange();
                    if (selectionRange.isEmpty()) this.$inSelection = false;else {
                        var pos = this.getDocumentPosition();
                        this.$inSelection = selectionRange.contains(pos.row, pos.column);
                    }

                    return this.$inSelection;
                };
                this.getButton = function () {
                    return event.getButton(this.domEvent);
                };
                this.getShiftKey = function () {
                    return this.domEvent.shiftKey;
                };

                this.getAccelKey = useragent.isMac ? function () {
                    return this.domEvent.metaKey;
                } : function () {
                    return this.domEvent.ctrlKey;
                };
            }).call(MouseEvent.prototype);
        });

        ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var AUTOSCROLL_DELAY = 200;
            var SCROLL_CURSOR_DELAY = 200;
            var SCROLL_CURSOR_HYSTERESIS = 5;

            function DragdropHandler(mouseHandler) {

                var editor = mouseHandler.editor;

                var blankImage = dom.createElement("img");
                blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                if (useragent.isOpera) blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

                var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);
                editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));

                var mouseTarget = editor.container;
                var dragSelectionMarker, x, y;
                var timerId, range;
                var dragCursor,
                    counter = 0;
                var dragOperation;
                var isInternal;
                var autoScrollStartTime;
                var cursorMovedTime;
                var cursorPointOnCaretMoved;

                this.onDragStart = function (e) {
                    if (this.cancelDrag || !mouseTarget.draggable) {
                        var self = this;
                        setTimeout(function () {
                            self.startSelect();
                            self.captureMouse(e);
                        }, 0);
                        return e.preventDefault();
                    }
                    range = editor.getSelectionRange();

                    var dataTransfer = e.dataTransfer;
                    dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
                    if (useragent.isOpera) {
                        editor.container.appendChild(blankImage);
                        blankImage.scrollTop = 0;
                    }
                    dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
                    if (useragent.isOpera) {
                        editor.container.removeChild(blankImage);
                    }
                    dataTransfer.clearData();
                    dataTransfer.setData("Text", editor.session.getTextRange());

                    isInternal = true;
                    this.setState("drag");
                };

                this.onDragEnd = function (e) {
                    mouseTarget.draggable = false;
                    isInternal = false;
                    this.setState(null);
                    if (!editor.getReadOnly()) {
                        var dropEffect = e.dataTransfer.dropEffect;
                        if (!dragOperation && dropEffect == "move") editor.session.remove(editor.getSelectionRange());
                        editor.renderer.$cursorLayer.setBlinking(true);
                    }
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                };

                this.onDragEnter = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) addDragMarker();
                    counter++;
                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragOver = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) {
                        addDragMarker();
                        counter++;
                    }
                    if (onMouseMoveTimer !== null) onMouseMoveTimer = null;

                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragLeave = function (e) {
                    counter--;
                    if (counter <= 0 && dragSelectionMarker) {
                        clearDragMarker();
                        dragOperation = null;
                        return event.preventDefault(e);
                    }
                };

                this.onDrop = function (e) {
                    if (!dragCursor) return;
                    var dataTransfer = e.dataTransfer;
                    if (isInternal) {
                        switch (dragOperation) {
                            case "move":
                                if (range.contains(dragCursor.row, dragCursor.column)) {
                                    range = {
                                        start: dragCursor,
                                        end: dragCursor
                                    };
                                } else {
                                    range = editor.moveText(range, dragCursor);
                                }
                                break;
                            case "copy":
                                range = editor.moveText(range, dragCursor, true);
                                break;
                        }
                    } else {
                        var dropData = dataTransfer.getData('Text');
                        range = {
                            start: dragCursor,
                            end: editor.session.insert(dragCursor, dropData)
                        };
                        editor.focus();
                        dragOperation = null;
                    }
                    clearDragMarker();
                    return event.preventDefault(e);
                };

                event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
                event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
                event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
                event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
                event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
                event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

                function scrollCursorIntoView(cursor, prevCursor) {
                    var now = Date.now();
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    var hMovement = !prevCursor || cursor.column != prevCursor.column;
                    if (!cursorMovedTime || vMovement || hMovement) {
                        editor.$blockScrolling += 1;
                        editor.moveCursorToPosition(cursor);
                        editor.$blockScrolling -= 1;
                        cursorMovedTime = now;
                        cursorPointOnCaretMoved = { x: x, y: y };
                    } else {
                        var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                        if (distance > SCROLL_CURSOR_HYSTERESIS) {
                            cursorMovedTime = null;
                        } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                            editor.renderer.scrollCursorIntoView();
                            cursorMovedTime = null;
                        }
                    }
                }

                function autoScroll(cursor, prevCursor) {
                    var now = Date.now();
                    var lineHeight = editor.renderer.layerConfig.lineHeight;
                    var characterWidth = editor.renderer.layerConfig.characterWidth;
                    var editorRect = editor.renderer.scroller.getBoundingClientRect();
                    var offsets = {
                        x: {
                            left: x - editorRect.left,
                            right: editorRect.right - x
                        },
                        y: {
                            top: y - editorRect.top,
                            bottom: editorRect.bottom - y
                        }
                    };
                    var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
                    var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
                    var scrollCursor = { row: cursor.row, column: cursor.column };
                    if (nearestXOffset / characterWidth <= 2) {
                        scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
                    }
                    if (nearestYOffset / lineHeight <= 1) {
                        scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
                    }
                    var vScroll = cursor.row != scrollCursor.row;
                    var hScroll = cursor.column != scrollCursor.column;
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    if (vScroll || hScroll && !vMovement) {
                        if (!autoScrollStartTime) autoScrollStartTime = now;else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
                    } else {
                        autoScrollStartTime = null;
                    }
                }

                function onDragInterval() {
                    var prevCursor = dragCursor;
                    dragCursor = editor.renderer.screenToTextCoordinates(x, y);
                    scrollCursorIntoView(dragCursor, prevCursor);
                    autoScroll(dragCursor, prevCursor);
                }

                function addDragMarker() {
                    range = editor.selection.toOrientedRange();
                    dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
                    editor.clearSelection();
                    if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
                    clearInterval(timerId);
                    onDragInterval();
                    timerId = setInterval(onDragInterval, 20);
                    counter = 0;
                    event.addListener(document, "mousemove", onMouseMove);
                }

                function clearDragMarker() {
                    clearInterval(timerId);
                    editor.session.removeMarker(dragSelectionMarker);
                    dragSelectionMarker = null;
                    editor.$blockScrolling += 1;
                    editor.selection.fromOrientedRange(range);
                    editor.$blockScrolling -= 1;
                    if (editor.isFocused() && !isInternal) editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
                    range = null;
                    dragCursor = null;
                    counter = 0;
                    autoScrollStartTime = null;
                    cursorMovedTime = null;
                    event.removeListener(document, "mousemove", onMouseMove);
                }
                var onMouseMoveTimer = null;
                function onMouseMove() {
                    if (onMouseMoveTimer == null) {
                        onMouseMoveTimer = setTimeout(function () {
                            if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
                        }, 20);
                    }
                }

                function canAccept(dataTransfer) {
                    var types = dataTransfer.types;
                    return !types || Array.prototype.some.call(types, function (type) {
                        return type == 'text/plain' || type == 'Text';
                    });
                }

                function getDropEffect(e) {
                    var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
                    var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

                    var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
                    var effectAllowed = "uninitialized";
                    try {
                        effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
                    } catch (e) {}
                    var dropEffect = "none";

                    if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";

                    return dropEffect;
                }
            }

            (function () {

                this.dragWait = function () {
                    var interval = Date.now() - this.mousedownEvent.time;
                    if (interval > this.editor.getDragDelay()) this.startDrag();
                };

                this.dragWaitEnd = function () {
                    var target = this.editor.container;
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                    this.selectEnd();
                };

                this.dragReadyEnd = function (e) {
                    this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                    this.dragWaitEnd();
                };

                this.startDrag = function () {
                    this.cancelDrag = false;
                    var editor = this.editor;
                    var target = editor.container;
                    target.draggable = true;
                    editor.renderer.$cursorLayer.setBlinking(false);
                    editor.setStyle("ace_dragging");
                    var cursorStyle = useragent.isWin ? "default" : "move";
                    editor.renderer.setCursorStyle(cursorStyle);
                    this.setState("dragReady");
                };

                this.onMouseDrag = function (e) {
                    var target = this.editor.container;
                    if (useragent.isIE && this.state == "dragReady") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 3) target.dragDrop();
                    }
                    if (this.state === "dragWait") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 0) {
                            target.draggable = false;
                            this.startSelect(this.mousedownEvent.getDocumentPosition());
                        }
                    }
                };

                this.onMouseDown = function (e) {
                    if (!this.$dragEnabled) return;
                    this.mousedownEvent = e;
                    var editor = this.editor;

                    var inSelection = e.inSelection();
                    var button = e.getButton();
                    var clickCount = e.domEvent.detail || 1;
                    if (clickCount === 1 && button === 0 && inSelection) {
                        if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                        this.mousedownEvent.time = Date.now();
                        var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                        if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
                        if (editor.getDragDelay()) {
                            if (useragent.isWebKit) {
                                this.cancelDrag = true;
                                var mouseTarget = editor.container;
                                mouseTarget.draggable = true;
                            }
                            this.setState("dragWait");
                        } else {
                            this.startDrag();
                        }
                        this.captureMouse(e, this.onMouseDrag.bind(this));
                        e.defaultPrevented = true;
                    }
                };
            }).call(DragdropHandler.prototype);

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            exports.DragdropHandler = DragdropHandler;
        });

        ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("./dom");

            exports.get = function (url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        callback(xhr.responseText);
                    }
                };
                xhr.send(null);
            };

            exports.loadScript = function (path, callback) {
                var head = dom.getDocumentHead();
                var s = document.createElement('script');

                s.src = path;
                head.appendChild(s);

                s.onload = s.onreadystatechange = function (_, isAbort) {
                    if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                        s = s.onload = s.onreadystatechange = null;
                        if (!isAbort) callback();
                    }
                };
            };
            exports.qualifyURL = function (url) {
                var a = document.createElement('a');
                a.href = url;
                return a.href;
            };
        });

        ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var EventEmitter = {};
            var stopPropagation = function () {
                this.propagationStopped = true;
            };
            var preventDefault = function () {
                this.defaultPrevented = true;
            };

            EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
                this._eventRegistry || (this._eventRegistry = {});
                this._defaultHandlers || (this._defaultHandlers = {});

                var listeners = this._eventRegistry[eventName] || [];
                var defaultHandler = this._defaultHandlers[eventName];
                if (!listeners.length && !defaultHandler) return;

                if (typeof e != "object" || !e) e = {};

                if (!e.type) e.type = eventName;
                if (!e.stopPropagation) e.stopPropagation = stopPropagation;
                if (!e.preventDefault) e.preventDefault = preventDefault;

                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i](e, this);
                    if (e.propagationStopped) break;
                }

                if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
            };

            EventEmitter._signal = function (eventName, e) {
                var listeners = (this._eventRegistry || {})[eventName];
                if (!listeners) return;
                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) listeners[i](e, this);
            };

            EventEmitter.once = function (eventName, callback) {
                var _self = this;
                callback && this.addEventListener(eventName, function newCallback() {
                    _self.removeEventListener(eventName, newCallback);
                    callback.apply(null, arguments);
                });
            };

            EventEmitter.setDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) handlers = this._defaultHandlers = { _disabled_: {} };

                if (handlers[eventName]) {
                    var old = handlers[eventName];
                    var disabled = handlers._disabled_[eventName];
                    if (!disabled) handlers._disabled_[eventName] = disabled = [];
                    disabled.push(old);
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
                handlers[eventName] = callback;
            };
            EventEmitter.removeDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) return;
                var disabled = handlers._disabled_[eventName];

                if (handlers[eventName] == callback) {
                    var old = handlers[eventName];
                    if (disabled) this.setDefaultHandler(eventName, disabled.pop());
                } else if (disabled) {
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
            };

            EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) listeners = this._eventRegistry[eventName] = [];

                if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
                return callback;
            };

            EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) return;

                var index = listeners.indexOf(callback);
                if (index !== -1) listeners.splice(index, 1);
            };

            EventEmitter.removeAllListeners = function (eventName) {
                if (this._eventRegistry) this._eventRegistry[eventName] = [];
            };

            exports.EventEmitter = EventEmitter;
        });

        ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "no use strict";

            var oop = require("./oop");
            var EventEmitter = require("./event_emitter").EventEmitter;

            var optionsProvider = {
                setOptions: function (optList) {
                    Object.keys(optList).forEach(function (key) {
                        this.setOption(key, optList[key]);
                    }, this);
                },
                getOptions: function (optionNames) {
                    var result = {};
                    if (!optionNames) {
                        optionNames = Object.keys(this.$options);
                    } else if (!Array.isArray(optionNames)) {
                        result = optionNames;
                        optionNames = Object.keys(result);
                    }
                    optionNames.forEach(function (key) {
                        result[key] = this.getOption(key);
                    }, this);
                    return result;
                },
                setOption: function (name, value) {
                    if (this["$" + name] === value) return;
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

                    if (!opt.handlesSet) this["$" + name] = value;
                    if (opt && opt.set) opt.set.call(this, value);
                },
                getOption: function (name) {
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                    return opt && opt.get ? opt.get.call(this) : this["$" + name];
                }
            };

            function warn(message) {
                if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
            }

            function reportError(msg, data) {
                var e = new Error(msg);
                e.data = data;
                if (typeof console == "object" && console.error) console.error(e);
                setTimeout(function () {
                    throw e;
                });
            }

            var AppConfig = function () {
                this.$defaultOptions = {};
            };

            (function () {
                oop.implement(this, EventEmitter);
                this.defineOptions = function (obj, path, options) {
                    if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};

                    Object.keys(options).forEach(function (key) {
                        var opt = options[key];
                        if (typeof opt == "string") opt = { forwardTo: opt };

                        opt.name || (opt.name = key);
                        obj.$options[opt.name] = opt;
                        if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
                    });
                    oop.implement(obj, optionsProvider);

                    return this;
                };

                this.resetOptions = function (obj) {
                    Object.keys(obj.$options).forEach(function (key) {
                        var opt = obj.$options[key];
                        if ("value" in opt) obj.setOption(key, opt.value);
                    });
                };

                this.setDefaultValue = function (path, name, value) {
                    var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                    if (opts[name]) {
                        if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);else opts[name].value = value;
                    }
                };

                this.setDefaultValues = function (path, optionHash) {
                    Object.keys(optionHash).forEach(function (key) {
                        this.setDefaultValue(path, key, optionHash[key]);
                    }, this);
                };

                this.warn = warn;
                this.reportError = reportError;
            }).call(AppConfig.prototype);

            exports.AppConfig = AppConfig;
        });

        ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function (require, exports, module) {
            "no use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var net = require("./lib/net");
            var AppConfig = require("./lib/app_config").AppConfig;

            module.exports = exports = new AppConfig();

            var global = function () {
                return this || typeof window != "undefined" && window;
            }();

            var options = {
                packaged: false,
                workerPath: null,
                modePath: null,
                themePath: null,
                basePath: "",
                suffix: ".js",
                $moduleUrls: {}
            };

            exports.get = function (key) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                return options[key];
            };

            exports.set = function (key, value) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                options[key] = value;
            };

            exports.all = function () {
                return lang.copyObject(options);
            };
            exports.moduleUrl = function (name, component) {
                if (options.$moduleUrls[name]) return options.$moduleUrls[name];

                var parts = name.split("/");
                component = component || parts[parts.length - 2] || "";
                var sep = component == "snippets" ? "/" : "-";
                var base = parts[parts.length - 1];
                if (component == "worker" && sep == "-") {
                    var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
                    base = base.replace(re, "");
                }

                if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
                var path = options[component + "Path"];
                if (path == null) {
                    path = options.basePath;
                } else if (sep == "/") {
                    component = sep = "";
                }
                if (path && path.slice(-1) != "/") path += "/";
                return path + component + sep + base + this.get("suffix");
            };

            exports.setModuleUrl = function (name, subst) {
                return options.$moduleUrls[name] = subst;
            };

            exports.$loading = {};
            exports.loadModule = function (moduleName, onLoad) {
                var module, moduleType;
                if (Array.isArray(moduleName)) {
                    moduleType = moduleName[0];
                    moduleName = moduleName[1];
                }

                try {
                    module = require(moduleName);
                } catch (e) {}
                if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);

                if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];

                exports.$loading[moduleName].push(onLoad);

                if (exports.$loading[moduleName].length > 1) return;

                var afterLoad = function () {
                    require([moduleName], function (module) {
                        exports._emit("load.module", { name: moduleName, module: module });
                        var listeners = exports.$loading[moduleName];
                        exports.$loading[moduleName] = null;
                        listeners.forEach(function (onLoad) {
                            onLoad && onLoad(module);
                        });
                    });
                };

                if (!exports.get("packaged")) return afterLoad();
                net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
            };
            init(true);function init(packaged) {

                if (!global || !global.document) return;

                options.packaged = packaged || require.packaged || module.packaged || global.define && define.packaged;

                var scriptOptions = {};
                var scriptUrl = "";
                var currentScript = document.currentScript || document._currentScript; // native or polyfill
                var currentDocument = currentScript && currentScript.ownerDocument || document;

                var scripts = currentDocument.getElementsByTagName("script");
                for (var i = 0; i < scripts.length; i++) {
                    var script = scripts[i];

                    var src = script.src || script.getAttribute("src");
                    if (!src) continue;

                    var attributes = script.attributes;
                    for (var j = 0, l = attributes.length; j < l; j++) {
                        var attr = attributes[j];
                        if (attr.name.indexOf("data-ace-") === 0) {
                            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                        }
                    }

                    var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
                    if (m) scriptUrl = m[1];
                }

                if (scriptUrl) {
                    scriptOptions.base = scriptOptions.base || scriptUrl;
                    scriptOptions.packaged = true;
                }

                scriptOptions.basePath = scriptOptions.base;
                scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
                scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
                scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
                delete scriptOptions.base;

                for (var key in scriptOptions) if (typeof scriptOptions[key] !== "undefined") exports.set(key, scriptOptions[key]);
            }

            exports.init = init;

            function deHyphenate(str) {
                return str.replace(/-(.)/g, function (m, m1) {
                    return m1.toUpperCase();
                });
            }
        });

        ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var DefaultHandlers = require("./default_handlers").DefaultHandlers;
            var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
            var MouseEvent = require("./mouse_event").MouseEvent;
            var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
            var config = require("../config");

            var MouseHandler = function (editor) {
                var _self = this;
                this.editor = editor;

                new DefaultHandlers(this);
                new DefaultGutterHandler(this);
                new DragdropHandler(this);

                var focusEditor = function (e) {
                    var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
                    if (windowBlurred) window.focus();
                    editor.focus();
                };

                var mouseTarget = editor.renderer.getMouseEventTarget();
                event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
                event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
                event.addMultiMouseDownListener([mouseTarget, editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner, editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner, editor.textInput && editor.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
                event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

                var gutterEl = editor.renderer.$gutter;
                event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
                event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
                event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
                event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

                event.addListener(mouseTarget, "mousedown", focusEditor);
                event.addListener(gutterEl, "mousedown", focusEditor);
                if (useragent.isIE && editor.renderer.scrollBarV) {
                    event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
                    event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
                }

                editor.on("mousemove", function (e) {
                    if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;

                    var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                    var range = editor.session.selection.getRange();
                    var renderer = editor.renderer;

                    if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                        renderer.setCursorStyle("default");
                    } else {
                        renderer.setCursorStyle("");
                    }
                });
            };

            (function () {
                this.onMouseEvent = function (name, e) {
                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseMove = function (name, e) {
                    var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
                    if (!listeners || !listeners.length) return;

                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseWheel = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;

                    this.editor._emit(name, mouseEvent);
                };

                this.onTouchMove = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = 1; //this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;
                    this.editor._emit(name, mouseEvent);
                };

                this.setState = function (state) {
                    this.state = state;
                };

                this.captureMouse = function (ev, mouseMoveHandler) {
                    this.x = ev.x;
                    this.y = ev.y;

                    this.isMousePressed = true;
                    var renderer = this.editor.renderer;
                    if (renderer.$keepTextAreaAtCursor) renderer.$keepTextAreaAtCursor = null;

                    var self = this;
                    var onMouseMove = function (e) {
                        if (!e) return;
                        if (useragent.isWebKit && !e.which && self.releaseMouse) return self.releaseMouse();

                        self.x = e.clientX;
                        self.y = e.clientY;
                        mouseMoveHandler && mouseMoveHandler(e);
                        self.mouseEvent = new MouseEvent(e, self.editor);
                        self.$mouseMoved = true;
                    };

                    var onCaptureEnd = function (e) {
                        clearInterval(timerId);
                        onCaptureInterval();
                        self[self.state + "End"] && self[self.state + "End"](e);
                        self.state = "";
                        if (renderer.$keepTextAreaAtCursor == null) {
                            renderer.$keepTextAreaAtCursor = true;
                            renderer.$moveTextAreaToCursor();
                        }
                        self.isMousePressed = false;
                        self.$onCaptureMouseMove = self.releaseMouse = null;
                        e && self.onMouseEvent("mouseup", e);
                    };

                    var onCaptureInterval = function () {
                        self[self.state] && self[self.state]();
                        self.$mouseMoved = false;
                    };

                    if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                        return setTimeout(function () {
                            onCaptureEnd(ev);
                        });
                    }

                    self.$onCaptureMouseMove = onMouseMove;
                    self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                    var timerId = setInterval(onCaptureInterval, 20);
                };
                this.releaseMouse = null;
                this.cancelContextMenu = function () {
                    var stop = function (e) {
                        if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
                        this.editor.off("nativecontextmenu", stop);
                        if (e && e.domEvent) event.stopEvent(e.domEvent);
                    }.bind(this);
                    setTimeout(stop, 10);
                    this.editor.on("nativecontextmenu", stop);
                };
            }).call(MouseHandler.prototype);

            config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                scrollSpeed: { initialValue: 2 },
                dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
                dragEnabled: { initialValue: true },
                focusTimout: { initialValue: 0 },
                tooltipFollowsMouse: { initialValue: true }
            });

            exports.MouseHandler = MouseHandler;
        });

        ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function FoldHandler(editor) {

                editor.on("click", function (e) {
                    var position = e.getDocumentPosition();
                    var session = editor.session;
                    var fold = session.getFoldAt(position.row, position.column, 1);
                    if (fold) {
                        if (e.getAccelKey()) session.removeFold(fold);else session.expandFold(fold);

                        e.stop();
                    }
                });

                editor.on("gutterclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
                        if (!editor.isFocused()) editor.focus();
                        e.stop();
                    }
                });

                editor.on("gutterdblclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        var data = session.getParentFoldRangeData(row, true);
                        var range = data.range || data.firstRange;

                        if (range) {
                            row = range.start.row;
                            var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                            if (fold) {
                                session.removeFold(fold);
                            } else {
                                session.addFold("...", range);
                                editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                            }
                        }
                        e.stop();
                    }
                });
            }

            exports.FoldHandler = FoldHandler;
        });

        ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var event = require("../lib/event");

            var KeyBinding = function (editor) {
                this.$editor = editor;
                this.$data = { editor: editor };
                this.$handlers = [];
                this.setDefaultHandler(editor.commands);
            };

            (function () {
                this.setDefaultHandler = function (kb) {
                    this.removeKeyboardHandler(this.$defaultHandler);
                    this.$defaultHandler = kb;
                    this.addKeyboardHandler(kb, 0);
                };

                this.setKeyboardHandler = function (kb) {
                    var h = this.$handlers;
                    if (h[h.length - 1] == kb) return;

                    while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler) this.removeKeyboardHandler(h[h.length - 1]);

                    this.addKeyboardHandler(kb, 1);
                };

                this.addKeyboardHandler = function (kb, pos) {
                    if (!kb) return;
                    if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
                    var i = this.$handlers.indexOf(kb);
                    if (i != -1) this.$handlers.splice(i, 1);

                    if (pos == undefined) this.$handlers.push(kb);else this.$handlers.splice(pos, 0, kb);

                    if (i == -1 && kb.attach) kb.attach(this.$editor);
                };

                this.removeKeyboardHandler = function (kb) {
                    var i = this.$handlers.indexOf(kb);
                    if (i == -1) return false;
                    this.$handlers.splice(i, 1);
                    kb.detach && kb.detach(this.$editor);
                    return true;
                };

                this.getKeyboardHandler = function () {
                    return this.$handlers[this.$handlers.length - 1];
                };

                this.getStatusText = function () {
                    var data = this.$data;
                    var editor = data.editor;
                    return this.$handlers.map(function (h) {
                        return h.getStatusText && h.getStatusText(editor, data) || "";
                    }).filter(Boolean).join(" ");
                };

                this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
                    var toExecute;
                    var success = false;
                    var commands = this.$editor.commands;

                    for (var i = this.$handlers.length; i--;) {
                        toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                        if (!toExecute || !toExecute.command) continue;
                        if (toExecute.command == "null") {
                            success = true;
                        } else {
                            success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                        }
                        if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                            event.stopEvent(e);
                        }
                        if (success) break;
                    }

                    if (!success && hashId == -1) {
                        toExecute = { command: "insertstring" };
                        success = commands.exec("insertstring", this.$editor, keyString);
                    }

                    if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);

                    return success;
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    var keyString = keyUtil.keyCodeToString(keyCode);
                    this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                };

                this.onTextInput = function (text) {
                    this.$callKeyboardHandlers(-1, text);
                };
            }).call(KeyBinding.prototype);

            exports.KeyBinding = KeyBinding;
        });

        ace.define("ace/range", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };
            var Range = function (startRow, startColumn, endRow, endColumn) {
                this.start = {
                    row: startRow,
                    column: startColumn
                };

                this.end = {
                    row: endRow,
                    column: endColumn
                };
            };

            (function () {
                this.isEqual = function (range) {
                    return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
                };
                this.toString = function () {
                    return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
                };

                this.contains = function (row, column) {
                    return this.compare(row, column) == 0;
                };
                this.compareRange = function (range) {
                    var cmp,
                        end = range.end,
                        start = range.start;

                    cmp = this.compare(end.row, end.column);
                    if (cmp == 1) {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == 1) {
                            return 2;
                        } else if (cmp == 0) {
                            return 1;
                        } else {
                            return 0;
                        }
                    } else if (cmp == -1) {
                        return -2;
                    } else {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == -1) {
                            return -1;
                        } else if (cmp == 1) {
                            return 42;
                        } else {
                            return 0;
                        }
                    }
                };
                this.comparePoint = function (p) {
                    return this.compare(p.row, p.column);
                };
                this.containsRange = function (range) {
                    return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
                };
                this.intersects = function (range) {
                    var cmp = this.compareRange(range);
                    return cmp == -1 || cmp == 0 || cmp == 1;
                };
                this.isEnd = function (row, column) {
                    return this.end.row == row && this.end.column == column;
                };
                this.isStart = function (row, column) {
                    return this.start.row == row && this.start.column == column;
                };
                this.setStart = function (row, column) {
                    if (typeof row == "object") {
                        this.start.column = row.column;
                        this.start.row = row.row;
                    } else {
                        this.start.row = row;
                        this.start.column = column;
                    }
                };
                this.setEnd = function (row, column) {
                    if (typeof row == "object") {
                        this.end.column = row.column;
                        this.end.row = row.row;
                    } else {
                        this.end.row = row;
                        this.end.column = column;
                    }
                };
                this.inside = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column) || this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideStart = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideEnd = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.compare = function (row, column) {
                    if (!this.isMultiLine()) {
                        if (row === this.start.row) {
                            return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
                        }
                    }

                    if (row < this.start.row) return -1;

                    if (row > this.end.row) return 1;

                    if (this.start.row === row) return column >= this.start.column ? 0 : -1;

                    if (this.end.row === row) return column <= this.end.column ? 0 : 1;

                    return 0;
                };
                this.compareStart = function (row, column) {
                    if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareEnd = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareInside = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.clipRows = function (firstRow, lastRow) {
                    if (this.end.row > lastRow) var end = { row: lastRow + 1, column: 0 };else if (this.end.row < firstRow) var end = { row: firstRow, column: 0 };

                    if (this.start.row > lastRow) var start = { row: lastRow + 1, column: 0 };else if (this.start.row < firstRow) var start = { row: firstRow, column: 0 };

                    return Range.fromPoints(start || this.start, end || this.end);
                };
                this.extend = function (row, column) {
                    var cmp = this.compare(row, column);

                    if (cmp == 0) return this;else if (cmp == -1) var start = { row: row, column: column };else var end = { row: row, column: column };

                    return Range.fromPoints(start || this.start, end || this.end);
                };

                this.isEmpty = function () {
                    return this.start.row === this.end.row && this.start.column === this.end.column;
                };
                this.isMultiLine = function () {
                    return this.start.row !== this.end.row;
                };
                this.clone = function () {
                    return Range.fromPoints(this.start, this.end);
                };
                this.collapseRows = function () {
                    if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
                };
                this.toScreenRange = function (session) {
                    var screenPosStart = session.documentToScreenPosition(this.start);
                    var screenPosEnd = session.documentToScreenPosition(this.end);

                    return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
                };
                this.moveBy = function (row, column) {
                    this.start.row += row;
                    this.start.column += column;
                    this.end.row += row;
                    this.end.column += column;
                };
            }).call(Range.prototype);
            Range.fromPoints = function (start, end) {
                return new Range(start.row, start.column, end.row, end.column);
            };
            Range.comparePoints = comparePoints;

            Range.comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };

            exports.Range = Range;
        });

        ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Selection = function (session) {
                this.session = session;
                this.doc = session.getDocument();

                this.clearSelection();
                this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
                this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

                var self = this;
                this.lead.on("change", function (e) {
                    self._emit("changeCursor");
                    if (!self.$isEmpty) self._emit("changeSelection");
                    if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column) self.$desiredColumn = null;
                });

                this.selectionAnchor.on("change", function () {
                    if (!self.$isEmpty) self._emit("changeSelection");
                });
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.isEmpty = function () {
                    return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
                };
                this.isMultiLine = function () {
                    if (this.isEmpty()) {
                        return false;
                    }

                    return this.getRange().isMultiLine();
                };
                this.getCursor = function () {
                    return this.lead.getPosition();
                };
                this.setSelectionAnchor = function (row, column) {
                    this.anchor.setPosition(row, column);

                    if (this.$isEmpty) {
                        this.$isEmpty = false;
                        this._emit("changeSelection");
                    }
                };
                this.getSelectionAnchor = function () {
                    if (this.$isEmpty) return this.getSelectionLead();else return this.anchor.getPosition();
                };
                this.getSelectionLead = function () {
                    return this.lead.getPosition();
                };
                this.shiftSelection = function (columns) {
                    if (this.$isEmpty) {
                        this.moveCursorTo(this.lead.row, this.lead.column + columns);
                        return;
                    }

                    var anchor = this.getSelectionAnchor();
                    var lead = this.getSelectionLead();

                    var isBackwards = this.isBackwards();

                    if (!isBackwards || anchor.column !== 0) this.setSelectionAnchor(anchor.row, anchor.column + columns);

                    if (isBackwards || lead.column !== 0) {
                        this.$moveSelection(function () {
                            this.moveCursorTo(lead.row, lead.column + columns);
                        });
                    }
                };
                this.isBackwards = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;
                    return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
                };
                this.getRange = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;

                    if (this.isEmpty()) return Range.fromPoints(lead, lead);

                    if (this.isBackwards()) {
                        return Range.fromPoints(lead, anchor);
                    } else {
                        return Range.fromPoints(anchor, lead);
                    }
                };
                this.clearSelection = function () {
                    if (!this.$isEmpty) {
                        this.$isEmpty = true;
                        this._emit("changeSelection");
                    }
                };
                this.selectAll = function () {
                    var lastRow = this.doc.getLength() - 1;
                    this.setSelectionAnchor(0, 0);
                    this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
                };
                this.setRange = this.setSelectionRange = function (range, reverse) {
                    if (reverse) {
                        this.setSelectionAnchor(range.end.row, range.end.column);
                        this.selectTo(range.start.row, range.start.column);
                    } else {
                        this.setSelectionAnchor(range.start.row, range.start.column);
                        this.selectTo(range.end.row, range.end.column);
                    }
                    if (this.getRange().isEmpty()) this.$isEmpty = true;
                    this.$desiredColumn = null;
                };

                this.$moveSelection = function (mover) {
                    var lead = this.lead;
                    if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);

                    mover.call(this);
                };
                this.selectTo = function (row, column) {
                    this.$moveSelection(function () {
                        this.moveCursorTo(row, column);
                    });
                };
                this.selectToPosition = function (pos) {
                    this.$moveSelection(function () {
                        this.moveCursorToPosition(pos);
                    });
                };
                this.moveTo = function (row, column) {
                    this.clearSelection();
                    this.moveCursorTo(row, column);
                };
                this.moveToPosition = function (pos) {
                    this.clearSelection();
                    this.moveCursorToPosition(pos);
                };
                this.selectUp = function () {
                    this.$moveSelection(this.moveCursorUp);
                };
                this.selectDown = function () {
                    this.$moveSelection(this.moveCursorDown);
                };
                this.selectRight = function () {
                    this.$moveSelection(this.moveCursorRight);
                };
                this.selectLeft = function () {
                    this.$moveSelection(this.moveCursorLeft);
                };
                this.selectLineStart = function () {
                    this.$moveSelection(this.moveCursorLineStart);
                };
                this.selectLineEnd = function () {
                    this.$moveSelection(this.moveCursorLineEnd);
                };
                this.selectFileEnd = function () {
                    this.$moveSelection(this.moveCursorFileEnd);
                };
                this.selectFileStart = function () {
                    this.$moveSelection(this.moveCursorFileStart);
                };
                this.selectWordRight = function () {
                    this.$moveSelection(this.moveCursorWordRight);
                };
                this.selectWordLeft = function () {
                    this.$moveSelection(this.moveCursorWordLeft);
                };
                this.getWordRange = function (row, column) {
                    if (typeof column == "undefined") {
                        var cursor = row || this.lead;
                        row = cursor.row;
                        column = cursor.column;
                    }
                    return this.session.getWordRange(row, column);
                };
                this.selectWord = function () {
                    this.setSelectionRange(this.getWordRange());
                };
                this.selectAWord = function () {
                    var cursor = this.getCursor();
                    var range = this.session.getAWordRange(cursor.row, cursor.column);
                    this.setSelectionRange(range);
                };

                this.getLineRange = function (row, excludeLastChar) {
                    var rowStart = typeof row == "number" ? row : this.lead.row;
                    var rowEnd;

                    var foldLine = this.session.getFoldLine(rowStart);
                    if (foldLine) {
                        rowStart = foldLine.start.row;
                        rowEnd = foldLine.end.row;
                    } else {
                        rowEnd = rowStart;
                    }
                    if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);else return new Range(rowStart, 0, rowEnd + 1, 0);
                };
                this.selectLine = function () {
                    this.setSelectionRange(this.getLineRange());
                };
                this.moveCursorUp = function () {
                    this.moveCursorBy(-1, 0);
                };
                this.moveCursorDown = function () {
                    this.moveCursorBy(1, 0);
                };
                this.moveCursorLeft = function () {
                    var cursor = this.lead.getPosition(),
                        fold;

                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                    } else if (cursor.column === 0) {
                        if (cursor.row > 0) {
                            this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize) this.moveCursorBy(0, -tabSize);else this.moveCursorBy(0, -1);
                    }
                };
                this.moveCursorRight = function () {
                    var cursor = this.lead.getPosition(),
                        fold;
                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                    } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                        if (this.lead.row < this.doc.getLength() - 1) {
                            this.moveCursorTo(this.lead.row + 1, 0);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        var cursor = this.lead;
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize) this.moveCursorBy(0, tabSize);else this.moveCursorBy(0, 1);
                    }
                };
                this.moveCursorLineStart = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var screenRow = this.session.documentToScreenRow(row, column);
                    var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                    var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);

                    var leadingSpace = beforeCursor.match(/^\s*/);
                    if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
                    this.moveCursorToPosition(firstColumnPosition);
                };
                this.moveCursorLineEnd = function () {
                    var lead = this.lead;
                    var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                    if (this.lead.column == lineEnd.column) {
                        var line = this.session.getLine(lineEnd.row);
                        if (lineEnd.column == line.length) {
                            var textEnd = line.search(/\s+$/);
                            if (textEnd > 0) lineEnd.column = textEnd;
                        }
                    }

                    this.moveCursorTo(lineEnd.row, lineEnd.column);
                };
                this.moveCursorFileEnd = function () {
                    var row = this.doc.getLength() - 1;
                    var column = this.doc.getLine(row).length;
                    this.moveCursorTo(row, column);
                };
                this.moveCursorFileStart = function () {
                    this.moveCursorTo(0, 0);
                };
                this.moveCursorLongWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                        return;
                    }
                    if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                        column += this.session.nonTokenRe.lastIndex;
                        this.session.nonTokenRe.lastIndex = 0;
                        rightOfCursor = line.substring(column);
                    }
                    if (column >= line.length) {
                        this.moveCursorTo(row, line.length);
                        this.moveCursorRight();
                        if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        column += this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };
                this.moveCursorLongWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                        return;
                    }

                    var str = this.session.getFoldStringAt(row, column, -1);
                    if (str == null) {
                        str = this.doc.getLine(row).substring(0, column);
                    }

                    var leftOfCursor = lang.stringReverse(str);
                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                        column -= this.session.nonTokenRe.lastIndex;
                        leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                        this.session.nonTokenRe.lastIndex = 0;
                    }
                    if (column <= 0) {
                        this.moveCursorTo(row, 0);
                        this.moveCursorLeft();
                        if (row > 0) this.moveCursorWordLeft();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(leftOfCursor)) {
                        column -= this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };

                this.$shortWordEndIndex = function (rightOfCursor) {
                    var match,
                        index = 0,
                        ch;
                    var whitespaceRe = /\s/;
                    var tokenRe = this.session.tokenRe;

                    tokenRe.lastIndex = 0;
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        index = this.session.tokenRe.lastIndex;
                    } else {
                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;

                        if (index < 1) {
                            tokenRe.lastIndex = 0;
                            while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                                tokenRe.lastIndex = 0;
                                index++;
                                if (whitespaceRe.test(ch)) {
                                    if (index > 2) {
                                        index--;
                                        break;
                                    } else {
                                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                                        if (index > 2) break;
                                    }
                                }
                            }
                        }
                    }
                    tokenRe.lastIndex = 0;

                    return index;
                };

                this.moveCursorShortWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);

                    if (column == line.length) {
                        var l = this.doc.getLength();
                        do {
                            row++;
                            rightOfCursor = this.doc.getLine(row);
                        } while (row < l && /^\s*$/.test(rightOfCursor));

                        if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                        column = 0;
                    }

                    var index = this.$shortWordEndIndex(rightOfCursor);

                    this.moveCursorTo(row, column + index);
                };

                this.moveCursorShortWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;

                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);

                    var line = this.session.getLine(row).substring(0, column);
                    if (column === 0) {
                        do {
                            row--;
                            line = this.doc.getLine(row);
                        } while (row > 0 && /^\s*$/.test(line));

                        column = line.length;
                        if (!/\s+$/.test(line)) line = "";
                    }

                    var leftOfCursor = lang.stringReverse(line);
                    var index = this.$shortWordEndIndex(leftOfCursor);

                    return this.moveCursorTo(row, column - index);
                };

                this.moveCursorWordRight = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordRight();else this.moveCursorShortWordRight();
                };

                this.moveCursorWordLeft = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordLeft();else this.moveCursorShortWordLeft();
                };
                this.moveCursorBy = function (rows, chars) {
                    var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);

                    if (chars === 0) {
                        if (this.$desiredColumn) screenPos.column = this.$desiredColumn;else this.$desiredColumn = screenPos.column;
                    }

                    var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);

                    if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
                        if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                            if (docPos.row > 0 || rows > 0) docPos.row++;
                        }
                    }
                    this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                };
                this.moveCursorToPosition = function (position) {
                    this.moveCursorTo(position.row, position.column);
                };
                this.moveCursorTo = function (row, column, keepDesiredColumn) {
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        row = fold.start.row;
                        column = fold.start.column;
                    }

                    this.$keepDesiredColumnOnChange = true;
                    this.lead.setPosition(row, column);
                    this.$keepDesiredColumnOnChange = false;

                    if (!keepDesiredColumn) this.$desiredColumn = null;
                };
                this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
                    var pos = this.session.screenToDocumentPosition(row, column);
                    this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                };
                this.detach = function () {
                    this.lead.detach();
                    this.anchor.detach();
                    this.session = this.doc = null;
                };

                this.fromOrientedRange = function (range) {
                    this.setSelectionRange(range, range.cursor == range.start);
                    this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                };

                this.toOrientedRange = function (range) {
                    var r = this.getRange();
                    if (range) {
                        range.start.column = r.start.column;
                        range.start.row = r.start.row;
                        range.end.column = r.end.column;
                        range.end.row = r.end.row;
                    } else {
                        range = r;
                    }

                    range.cursor = this.isBackwards() ? range.start : range.end;
                    range.desiredColumn = this.$desiredColumn;
                    return range;
                };
                this.getRangeOfMovements = function (func) {
                    var start = this.getCursor();
                    try {
                        func(this);
                        var end = this.getCursor();
                        return Range.fromPoints(start, end);
                    } catch (e) {
                        return Range.fromPoints(start, start);
                    } finally {
                        this.moveCursorToPosition(start);
                    }
                };

                this.toJSON = function () {
                    if (this.rangeCount) {
                        var data = this.ranges.map(function (r) {
                            var r1 = r.clone();
                            r1.isBackwards = r.cursor == r.start;
                            return r1;
                        });
                    } else {
                        var data = this.getRange();
                        data.isBackwards = this.isBackwards();
                    }
                    return data;
                };

                this.fromJSON = function (data) {
                    if (data.start == undefined) {
                        if (this.rangeList) {
                            this.toSingleRange(data[0]);
                            for (var i = data.length; i--;) {
                                var r = Range.fromPoints(data[i].start, data[i].end);
                                if (data[i].isBackwards) r.cursor = r.start;
                                this.addRange(r, true);
                            }
                            return;
                        } else data = data[0];
                    }
                    if (this.rangeList) this.toSingleRange(data);
                    this.setSelectionRange(data, data.isBackwards);
                };

                this.isEqual = function (data) {
                    if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
                    if (!data.length || !this.ranges) return this.getRange().isEqual(data);

                    for (var i = this.ranges.length; i--;) {
                        if (!this.ranges[i].isEqual(data[i])) return false;
                    }
                    return true;
                };
            }).call(Selection.prototype);

            exports.Selection = Selection;
        });

        ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function (require, exports, module) {
            "use strict";

            var config = require("./config");
            var MAX_TOKEN_COUNT = 2000;
            var Tokenizer = function (rules) {
                this.states = rules;

                this.regExps = {};
                this.matchMappings = {};
                for (var key in this.states) {
                    var state = this.states[key];
                    var ruleRegExps = [];
                    var matchTotal = 0;
                    var mapping = this.matchMappings[key] = { defaultToken: "text" };
                    var flag = "g";

                    var splitterRurles = [];
                    for (var i = 0; i < state.length; i++) {
                        var rule = state[i];
                        if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                        if (rule.caseInsensitive) flag = "gi";
                        if (rule.regex == null) continue;

                        if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
                        var adjustedregex = rule.regex;
                        var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                        if (Array.isArray(rule.token)) {
                            if (rule.token.length == 1 || matchcount == 1) {
                                rule.token = rule.token[0];
                            } else if (matchcount - 1 != rule.token.length) {
                                this.reportError("number of classes and regexp groups doesn't match", {
                                    rule: rule,
                                    groupCount: matchcount - 1
                                });
                                rule.token = rule.token[0];
                            } else {
                                rule.tokenArray = rule.token;
                                rule.token = null;
                                rule.onMatch = this.$arrayTokens;
                            }
                        } else if (typeof rule.token == "function" && !rule.onMatch) {
                            if (matchcount > 1) rule.onMatch = this.$applyToken;else rule.onMatch = rule.token;
                        }

                        if (matchcount > 1) {
                            if (/\\\d/.test(rule.regex)) {
                                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                                    return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                                });
                            } else {
                                matchcount = 1;
                                adjustedregex = this.removeCapturingGroups(rule.regex);
                            }
                            if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
                        }

                        mapping[matchTotal] = i;
                        matchTotal += matchcount;

                        ruleRegExps.push(adjustedregex);
                        if (!rule.onMatch) rule.onMatch = null;
                    }

                    if (!ruleRegExps.length) {
                        mapping[0] = 0;
                        ruleRegExps.push("$");
                    }

                    splitterRurles.forEach(function (rule) {
                        rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                    }, this);

                    this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
                }
            };

            (function () {
                this.$setMaxTokenCount = function (m) {
                    MAX_TOKEN_COUNT = m | 0;
                };

                this.$applyToken = function (str) {
                    var values = this.splitRegex.exec(str).slice(1);
                    var types = this.token.apply(this, values);
                    if (typeof types === "string") return [{ type: types, value: str }];

                    var tokens = [];
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i]
                        };
                    }
                    return tokens;
                };

                this.$arrayTokens = function (str) {
                    if (!str) return [];
                    var values = this.splitRegex.exec(str);
                    if (!values) return "text";
                    var tokens = [];
                    var types = this.tokenArray;
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i + 1]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i + 1]
                        };
                    }
                    return tokens;
                };

                this.removeCapturingGroups = function (src) {
                    var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
                        return y ? "(?:" : x;
                    });
                    return r;
                };

                this.createSplitterRegexp = function (src, flag) {
                    if (src.indexOf("(?=") != -1) {
                        var stack = 0;
                        var inChClass = false;
                        var lastCapture = {};
                        src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                            if (inChClass) {
                                inChClass = square != "]";
                            } else if (square) {
                                inChClass = true;
                            } else if (parenClose) {
                                if (stack == lastCapture.stack) {
                                    lastCapture.end = index + 1;
                                    lastCapture.stack = -1;
                                }
                                stack--;
                            } else if (parenOpen) {
                                stack++;
                                if (parenOpen.length != 1) {
                                    lastCapture.stack = stack;
                                    lastCapture.start = index;
                                }
                            }
                            return m;
                        });

                        if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                    }
                    if (src.charAt(0) != "^") src = "^" + src;
                    if (src.charAt(src.length - 1) != "$") src += "$";

                    return new RegExp(src, (flag || "").replace("g", ""));
                };
                this.getLineTokens = function (line, startState) {
                    if (startState && typeof startState != "string") {
                        var stack = startState.slice(0);
                        startState = stack[0];
                        if (startState === "#tmp") {
                            stack.shift();
                            startState = stack.shift();
                        }
                    } else var stack = [];

                    var currentState = startState || "start";
                    var state = this.states[currentState];
                    if (!state) {
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    var mapping = this.matchMappings[currentState];
                    var re = this.regExps[currentState];
                    re.lastIndex = 0;

                    var match,
                        tokens = [];
                    var lastIndex = 0;
                    var matchAttempts = 0;

                    var token = { type: null, value: "" };

                    while (match = re.exec(line)) {
                        var type = mapping.defaultToken;
                        var rule = null;
                        var value = match[0];
                        var index = re.lastIndex;

                        if (index - value.length > lastIndex) {
                            var skipped = line.substring(lastIndex, index - value.length);
                            if (token.type == type) {
                                token.value += skipped;
                            } else {
                                if (token.type) tokens.push(token);
                                token = { type: type, value: skipped };
                            }
                        }

                        for (var i = 0; i < match.length - 2; i++) {
                            if (match[i + 1] === undefined) continue;

                            rule = state[mapping[i]];

                            if (rule.onMatch) type = rule.onMatch(value, currentState, stack);else type = rule.token;

                            if (rule.next) {
                                if (typeof rule.next == "string") {
                                    currentState = rule.next;
                                } else {
                                    currentState = rule.next(currentState, stack);
                                }

                                state = this.states[currentState];
                                if (!state) {
                                    this.reportError("state doesn't exist", currentState);
                                    currentState = "start";
                                    state = this.states[currentState];
                                }
                                mapping = this.matchMappings[currentState];
                                lastIndex = index;
                                re = this.regExps[currentState];
                                re.lastIndex = index;
                            }
                            break;
                        }

                        if (value) {
                            if (typeof type === "string") {
                                if ((!rule || rule.merge !== false) && token.type === type) {
                                    token.value += value;
                                } else {
                                    if (token.type) tokens.push(token);
                                    token = { type: type, value: value };
                                }
                            } else if (type) {
                                if (token.type) tokens.push(token);
                                token = { type: null, value: "" };
                                for (var i = 0; i < type.length; i++) tokens.push(type[i]);
                            }
                        }

                        if (lastIndex == line.length) break;

                        lastIndex = index;

                        if (matchAttempts++ > MAX_TOKEN_COUNT) {
                            if (matchAttempts > 2 * line.length) {
                                this.reportError("infinite loop with in ace tokenizer", {
                                    startState: startState,
                                    line: line
                                });
                            }
                            while (lastIndex < line.length) {
                                if (token.type) tokens.push(token);
                                token = {
                                    value: line.substring(lastIndex, lastIndex += 2000),
                                    type: "overflow"
                                };
                            }
                            currentState = "start";
                            stack = [];
                            break;
                        }
                    }

                    if (token.type) tokens.push(token);

                    if (stack.length > 1) {
                        if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
                    }
                    return {
                        tokens: tokens,
                        state: stack.length ? stack : currentState
                    };
                };

                this.reportError = config.reportError;
            }).call(Tokenizer.prototype);

            exports.Tokenizer = Tokenizer;
        });

        ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");

            var TextHighlightRules = function () {

                this.$rules = {
                    "start": [{
                        token: "empty_line",
                        regex: '^$'
                    }, {
                        defaultToken: "text"
                    }]
                };
            };

            (function () {

                this.addRules = function (rules, prefix) {
                    if (!prefix) {
                        for (var key in rules) this.$rules[key] = rules[key];
                        return;
                    }
                    for (var key in rules) {
                        var state = rules[key];
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            if (rule.next || rule.onMatch) {
                                if (typeof rule.next == "string") {
                                    if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                                }
                                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                            }
                        }
                        this.$rules[prefix + key] = state;
                    }
                };

                this.getRules = function () {
                    return this.$rules;
                };

                this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
                    var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
                    if (states) {
                        for (var i = 0; i < states.length; i++) states[i] = prefix + states[i];
                    } else {
                        states = [];
                        for (var key in embedRules) states.push(prefix + key);
                    }

                    this.addRules(embedRules, prefix);

                    if (escapeRules) {
                        var addRules = Array.prototype[append ? "push" : "unshift"];
                        for (var i = 0; i < states.length; i++) addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
                    }

                    if (!this.$embeds) this.$embeds = [];
                    this.$embeds.push(prefix);
                };

                this.getEmbeds = function () {
                    return this.$embeds;
                };

                var pushState = function (currentState, stack) {
                    if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
                    return this.nextState;
                };
                var popState = function (currentState, stack) {
                    stack.shift();
                    return stack.shift() || "start";
                };

                this.normalizeRules = function () {
                    var id = 0;
                    var rules = this.$rules;
                    function processState(key) {
                        var state = rules[key];
                        state.processed = true;
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            var toInsert = null;
                            if (Array.isArray(rule)) {
                                toInsert = rule;
                                rule = {};
                            }
                            if (!rule.regex && rule.start) {
                                rule.regex = rule.start;
                                if (!rule.next) rule.next = [];
                                rule.next.push({
                                    defaultToken: rule.token
                                }, {
                                    token: rule.token + ".end",
                                    regex: rule.end || rule.start,
                                    next: "pop"
                                });
                                rule.token = rule.token + ".start";
                                rule.push = true;
                            }
                            var next = rule.next || rule.push;
                            if (next && Array.isArray(next)) {
                                var stateName = rule.stateName;
                                if (!stateName) {
                                    stateName = rule.token;
                                    if (typeof stateName != "string") stateName = stateName[0] || "";
                                    if (rules[stateName]) stateName += id++;
                                }
                                rules[stateName] = next;
                                rule.next = stateName;
                                processState(stateName);
                            } else if (next == "pop") {
                                rule.next = popState;
                            }

                            if (rule.push) {
                                rule.nextState = rule.next || rule.push;
                                rule.next = pushState;
                                delete rule.push;
                            }

                            if (rule.rules) {
                                for (var r in rule.rules) {
                                    if (rules[r]) {
                                        if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                                    } else {
                                        rules[r] = rule.rules[r];
                                    }
                                }
                            }
                            var includeName = typeof rule == "string" ? rule : typeof rule.include == "string" ? rule.include : "";
                            if (includeName) {
                                toInsert = rules[includeName];
                            }

                            if (toInsert) {
                                var args = [i, 1].concat(toInsert);
                                if (rule.noEscape) args = args.filter(function (x) {
                                    return !x.next;
                                });
                                state.splice.apply(state, args);
                                i--;
                            }

                            if (rule.keywordMap) {
                                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                                delete rule.defaultToken;
                            }
                        }
                    }
                    Object.keys(rules).forEach(processState, this);
                };

                this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
                    var keywords = Object.create(null);
                    Object.keys(map).forEach(function (className) {
                        var a = map[className];
                        if (ignoreCase) a = a.toLowerCase();
                        var list = a.split(splitChar || "|");
                        for (var i = list.length; i--;) keywords[list[i]] = className;
                    });
                    if (Object.getPrototypeOf(keywords)) {
                        keywords.__proto__ = null;
                    }
                    this.$keywordList = Object.keys(keywords);
                    map = null;
                    return ignoreCase ? function (value) {
                        return keywords[value.toLowerCase()] || defaultToken;
                    } : function (value) {
                        return keywords[value] || defaultToken;
                    };
                };

                this.getKeywords = function () {
                    return this.$keywords;
                };
            }).call(TextHighlightRules.prototype);

            exports.TextHighlightRules = TextHighlightRules;
        });

        ace.define("ace/mode/behaviour", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var Behaviour = function () {
                this.$behaviours = {};
            };

            (function () {

                this.add = function (name, action, callback) {
                    switch (undefined) {
                        case this.$behaviours:
                            this.$behaviours = {};
                        case this.$behaviours[name]:
                            this.$behaviours[name] = {};
                    }
                    this.$behaviours[name][action] = callback;
                };

                this.addBehaviours = function (behaviours) {
                    for (var key in behaviours) {
                        for (var action in behaviours[key]) {
                            this.add(key, action, behaviours[key][action]);
                        }
                    }
                };

                this.remove = function (name) {
                    if (this.$behaviours && this.$behaviours[name]) {
                        delete this.$behaviours[name];
                    }
                };

                this.inherit = function (mode, filter) {
                    if (typeof mode === "function") {
                        var behaviours = new mode().getBehaviours(filter);
                    } else {
                        var behaviours = mode.getBehaviours(filter);
                    }
                    this.addBehaviours(behaviours);
                };

                this.getBehaviours = function (filter) {
                    if (!filter) {
                        return this.$behaviours;
                    } else {
                        var ret = {};
                        for (var i = 0; i < filter.length; i++) {
                            if (this.$behaviours[filter[i]]) {
                                ret[filter[i]] = this.$behaviours[filter[i]];
                            }
                        }
                        return ret;
                    }
                };
            }).call(Behaviour.prototype);

            exports.Behaviour = Behaviour;
        });

        ace.define("ace/token_iterator", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var TokenIterator = function (session, initialRow, initialColumn) {
                this.$session = session;
                this.$row = initialRow;
                this.$rowTokens = session.getTokens(initialRow);

                var token = session.getTokenAt(initialRow, initialColumn);
                this.$tokenIndex = token ? token.index : -1;
            };

            (function () {
                this.stepBackward = function () {
                    this.$tokenIndex -= 1;

                    while (this.$tokenIndex < 0) {
                        this.$row -= 1;
                        if (this.$row < 0) {
                            this.$row = 0;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = this.$rowTokens.length - 1;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.stepForward = function () {
                    this.$tokenIndex += 1;
                    var rowCount;
                    while (this.$tokenIndex >= this.$rowTokens.length) {
                        this.$row += 1;
                        if (!rowCount) rowCount = this.$session.getLength();
                        if (this.$row >= rowCount) {
                            this.$row = rowCount - 1;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = 0;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentToken = function () {
                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentTokenRow = function () {
                    return this.$row;
                };
                this.getCurrentTokenColumn = function () {
                    var rowTokens = this.$rowTokens;
                    var tokenIndex = this.$tokenIndex;
                    var column = rowTokens[tokenIndex].start;
                    if (column !== undefined) return column;

                    column = 0;
                    while (tokenIndex > 0) {
                        tokenIndex -= 1;
                        column += rowTokens[tokenIndex].value.length;
                    }

                    return column;
                };
                this.getCurrentTokenPosition = function () {
                    return { row: this.$row, column: this.getCurrentTokenColumn() };
                };
            }).call(TokenIterator.prototype);

            exports.TokenIterator = TokenIterator;
        });

        ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;
            var lang = require("../../lib/lang");

            var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
            var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];

            var context;
            var contextCache = {};
            var initContext = function (editor) {
                var id = -1;
                if (editor.multiSelect) {
                    id = editor.selection.index;
                    if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = { rangeCount: editor.multiSelect.rangeCount };
                }
                if (contextCache[id]) return context = contextCache[id];
                context = contextCache[id] = {
                    autoInsertedBrackets: 0,
                    autoInsertedRow: -1,
                    autoInsertedLineEnd: "",
                    maybeInsertedBrackets: 0,
                    maybeInsertedRow: -1,
                    maybeInsertedLineStart: "",
                    maybeInsertedLineEnd: ""
                };
            };

            var getWrapped = function (selection, selected, opening, closing) {
                var rowDiff = selection.end.row - selection.start.row;
                return {
                    text: opening + selected + closing,
                    selection: [0, selection.start.column + 1, rowDiff, selection.end.column + (rowDiff ? 0 : 1)]
                };
            };

            var CstyleBehaviour = function () {
                this.add("braces", "insertion", function (state, action, editor, session, text) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    if (text == '{') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '{', '}');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                                return {
                                    text: '{}',
                                    selection: [1, 1]
                                };
                            } else {
                                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                                return {
                                    text: '{',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == '}') {
                        initContext(editor);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == '}') {
                            var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == "\n" || text == "\r\n") {
                        initContext(editor);
                        var closing = "";
                        if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                            closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                            CstyleBehaviour.clearMaybeInsertedClosing();
                        }
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === '}') {
                            var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                            if (!openBracePos) return null;
                            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                        } else if (closing) {
                            var next_indent = this.$getIndent(line);
                        } else {
                            CstyleBehaviour.clearMaybeInsertedClosing();
                            return;
                        }
                        var indent = next_indent + session.getTabString();

                        return {
                            text: '\n' + indent + '\n' + next_indent + closing,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        CstyleBehaviour.clearMaybeInsertedClosing();
                    }
                });

                this.add("braces", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '{') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.end.column, range.end.column + 1);
                        if (rightChar == '}') {
                            range.end.column++;
                            return range;
                        } else {
                            context.maybeInsertedBrackets--;
                        }
                    }
                });

                this.add("parens", "insertion", function (state, action, editor, session, text) {
                    if (text == '(') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '(', ')');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, ")");
                            return {
                                text: '()',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ')') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ')') {
                            var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("parens", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '(') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ')') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("brackets", "insertion", function (state, action, editor, session, text) {
                    if (text == '[') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '[', ']');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, "]");
                            return {
                                text: '[]',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ']') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ']') {
                            var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("brackets", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '[') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ']') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                    if (text == '"' || text == "'") {
                        if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
                        initContext(editor);
                        var quote = text;
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, quote, quote);
                        } else if (!selected) {
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var leftChar = line.substring(cursor.column - 1, cursor.column);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);

                            var token = session.getTokenAt(cursor.row, cursor.column);
                            var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                            if (leftChar == "\\" && token && /escape/.test(token.type)) return null;

                            var stringBefore = token && /string|escape/.test(token.type);
                            var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                            var pair;
                            if (rightChar == quote) {
                                pair = stringBefore !== stringAfter;
                                if (pair && /string\.end/.test(rightToken.type)) pair = false;
                            } else {
                                if (stringBefore && !stringAfter) return null; // wrap string with different quote
                                if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                                var wordRe = session.$mode.tokenRe;
                                wordRe.lastIndex = 0;
                                var isWordBefore = wordRe.test(leftChar);
                                wordRe.lastIndex = 0;
                                var isWordAfter = wordRe.test(leftChar);
                                if (isWordBefore || isWordAfter) return null; // before or after alphanumeric
                                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                                pair = true;
                            }
                            return {
                                text: pair ? quote + quote : "",
                                selection: [1, 1]
                            };
                        }
                    }
                });

                this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == selected) {
                            range.end.column++;
                            return range;
                        }
                    }
                });
            };

            CstyleBehaviour.isSaneInsertion = function (editor, session) {
                var cursor = editor.getCursorPosition();
                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                    var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
                    if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
                }
                iterator.stepForward();
                return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
            };

            CstyleBehaviour.$matchTokenType = function (token, types) {
                return types.indexOf(token.type || token) > -1;
            };

            CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
                context.autoInsertedRow = cursor.row;
                context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
                context.autoInsertedBrackets++;
            };

            CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isMaybeInsertedClosing(cursor, line)) context.maybeInsertedBrackets = 0;
                context.maybeInsertedRow = cursor.row;
                context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
                context.maybeInsertedLineEnd = line.substr(cursor.column);
                context.maybeInsertedBrackets++;
            };

            CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
                return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
            };

            CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
                return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
            };

            CstyleBehaviour.popAutoInsertedClosing = function () {
                context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
                context.autoInsertedBrackets--;
            };

            CstyleBehaviour.clearMaybeInsertedClosing = function () {
                if (context) {
                    context.maybeInsertedBrackets = 0;
                    context.maybeInsertedRow = -1;
                }
            };

            oop.inherits(CstyleBehaviour, Behaviour);

            exports.CstyleBehaviour = CstyleBehaviour;
        });

        ace.define("ace/unicode", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.packages = {};

            addUnicodePackage({
                L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
                Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
                Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
                Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
                Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
                Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
                Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
                Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
                N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
                No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
                P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
                Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
                Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
                Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
                Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
                Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
                Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
                Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
                S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
                Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
                Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
                Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
                So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
                Z: "002000A01680180E2000-200A20282029202F205F3000",
                Zs: "002000A01680180E2000-200A202F205F3000",
                Zl: "2028",
                Zp: "2029",
                C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
                Cc: "0000-001F007F-009F",
                Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
                Co: "E000-F8FF",
                Cs: "D800-DFFF",
                Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
            });

            function addUnicodePackage(pack) {
                var codePoint = /\w{4}/g;
                for (var name in pack) exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
            }
        });

        ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var Tokenizer = require("../tokenizer").Tokenizer;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var unicode = require("../unicode");
            var lang = require("../lib/lang");
            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            var Mode = function () {
                this.HighlightRules = TextHighlightRules;
            };

            (function () {
                this.$behaviour = new CstyleBehaviour();

                this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");

                this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");

                this.getTokenizer = function () {
                    if (!this.$tokenizer) {
                        this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                        this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                    }
                    return this.$tokenizer;
                };

                this.lineCommentStart = "";
                this.blockComment = "";

                this.toggleCommentLines = function (state, session, startRow, endRow) {
                    var doc = session.doc;

                    var ignoreBlankLines = true;
                    var shouldRemove = true;
                    var minIndent = Infinity;
                    var tabSize = session.getTabSize();
                    var insertAtTabStop = false;

                    if (!this.lineCommentStart) {
                        if (!this.blockComment) return false;
                        var lineCommentStart = this.blockComment.start;
                        var lineCommentEnd = this.blockComment.end;
                        var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                        var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

                        var comment = function (line, i) {
                            if (testRemove(line, i)) return;
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };

                        var uncomment = function (line, i) {
                            var m;
                            if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                            if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                        };

                        var testRemove = function (line, row) {
                            if (regexpStart.test(line)) return true;
                            var tokens = session.getTokens(row);
                            for (var i = 0; i < tokens.length; i++) {
                                if (tokens[i].type === "comment") return true;
                            }
                        };
                    } else {
                        if (Array.isArray(this.lineCommentStart)) {
                            var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                            var lineCommentStart = this.lineCommentStart[0];
                        } else {
                            var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                            var lineCommentStart = this.lineCommentStart;
                        }
                        regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

                        insertAtTabStop = session.getUseSoftTabs();

                        var uncomment = function (line, i) {
                            var m = line.match(regexpStart);
                            if (!m) return;
                            var start = m[1].length,
                                end = m[0].length;
                            if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                            doc.removeInLine(i, start, end);
                        };
                        var commentWithSpace = lineCommentStart + " ";
                        var comment = function (line, i) {
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);else doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };
                        var testRemove = function (line, i) {
                            return regexpStart.test(line);
                        };

                        var shouldInsertSpace = function (line, before, after) {
                            var spaces = 0;
                            while (before-- && line.charAt(before) == " ") spaces++;
                            if (spaces % tabSize != 0) return false;
                            var spaces = 0;
                            while (line.charAt(after++) == " ") spaces++;
                            if (tabSize > 2) return spaces % tabSize != tabSize - 1;else return spaces % tabSize == 0;
                            return true;
                        };
                    }

                    function iter(fun) {
                        for (var i = startRow; i <= endRow; i++) fun(doc.getLine(i), i);
                    }

                    var minEmptyLength = Infinity;
                    iter(function (line, i) {
                        var indent = line.search(/\S/);
                        if (indent !== -1) {
                            if (indent < minIndent) minIndent = indent;
                            if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
                        } else if (minEmptyLength > line.length) {
                            minEmptyLength = line.length;
                        }
                    });

                    if (minIndent == Infinity) {
                        minIndent = minEmptyLength;
                        ignoreBlankLines = false;
                        shouldRemove = false;
                    }

                    if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;

                    iter(shouldRemove ? uncomment : comment);
                };

                this.toggleBlockComment = function (state, session, range, cursor) {
                    var comment = this.blockComment;
                    if (!comment) return;
                    if (!comment.start && comment[0]) comment = comment[0];

                    var iterator = new TokenIterator(session, cursor.row, cursor.column);
                    var token = iterator.getCurrentToken();

                    var sel = session.selection;
                    var initialRange = session.selection.toOrientedRange();
                    var startRow, colDiff;

                    if (token && /comment/.test(token.type)) {
                        var startRange, endRange;
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.start);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                startRange = new Range(row, column, row, column + comment.start.length);
                                break;
                            }
                            token = iterator.stepBackward();
                        }

                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.end);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                endRange = new Range(row, column, row, column + comment.end.length);
                                break;
                            }
                            token = iterator.stepForward();
                        }
                        if (endRange) session.remove(endRange);
                        if (startRange) {
                            session.remove(startRange);
                            startRow = startRange.start.row;
                            colDiff = -comment.start.length;
                        }
                    } else {
                        colDiff = comment.start.length;
                        startRow = range.start.row;
                        session.insert(range.end, comment.end);
                        session.insert(range.start, comment.start);
                    }
                    if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
                    if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
                    session.selection.fromOrientedRange(initialRange);
                };

                this.getNextLineIndent = function (state, line, tab) {
                    return this.$getIndent(line);
                };

                this.checkOutdent = function (state, line, input) {
                    return false;
                };

                this.autoOutdent = function (state, doc, row) {};

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };

                this.createWorker = function (session) {
                    return null;
                };

                this.createModeDelegates = function (mapping) {
                    this.$embeds = [];
                    this.$modes = {};
                    for (var i in mapping) {
                        if (mapping[i]) {
                            this.$embeds.push(i);
                            this.$modes[i] = new mapping[i]();
                        }
                    }

                    var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

                    for (var i = 0; i < delegations.length; i++) {
                        (function (scope) {
                            var functionName = delegations[i];
                            var defaultHandler = scope[functionName];
                            scope[delegations[i]] = function () {
                                return this.$delegator(functionName, arguments, defaultHandler);
                            };
                        })(this);
                    }
                };

                this.$delegator = function (method, args, defaultHandler) {
                    var state = args[0];
                    if (typeof state != "string") state = state[0];
                    for (var i = 0; i < this.$embeds.length; i++) {
                        if (!this.$modes[this.$embeds[i]]) continue;

                        var split = state.split(this.$embeds[i]);
                        if (!split[0] && split[1]) {
                            args[0] = split[1];
                            var mode = this.$modes[this.$embeds[i]];
                            return mode[method].apply(mode, args);
                        }
                    }
                    var ret = defaultHandler.apply(this, args);
                    return defaultHandler ? ret : undefined;
                };

                this.transformAction = function (state, action, editor, session, param) {
                    if (this.$behaviour) {
                        var behaviours = this.$behaviour.getBehaviours();
                        for (var key in behaviours) {
                            if (behaviours[key][action]) {
                                var ret = behaviours[key][action].apply(this, arguments);
                                if (ret) {
                                    return ret;
                                }
                            }
                        }
                    }
                };

                this.getKeywords = function (append) {
                    if (!this.completionKeywords) {
                        var rules = this.$tokenizer.rules;
                        var completionKeywords = [];
                        for (var rule in rules) {
                            var ruleItr = rules[rule];
                            for (var r = 0, l = ruleItr.length; r < l; r++) {
                                if (typeof ruleItr[r].token === "string") {
                                    if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                                } else if (typeof ruleItr[r].token === "object") {
                                    for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                                        if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                            var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                            completionKeywords.push(rule.substr(1, rule.length - 2));
                                        }
                                    }
                                }
                            }
                        }
                        this.completionKeywords = completionKeywords;
                    }
                    if (!append) return this.$keywordList;
                    return completionKeywords.concat(this.$keywordList || []);
                };

                this.$createKeywordList = function () {
                    if (!this.$highlightRules) this.getTokenizer();
                    return this.$keywordList = this.$highlightRules.$keywordList || [];
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    var keywords = this.$keywordList || this.$createKeywordList();
                    return keywords.map(function (word) {
                        return {
                            name: word,
                            value: word,
                            score: 0,
                            meta: "keyword"
                        };
                    });
                };

                this.$id = "ace/mode/text";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/apply_delta", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function throwDeltaError(delta, errorText) {
                console.log("Invalid Delta:", delta);
                throw "Invalid Delta: " + errorText;
            }

            function positionInDocument(docLines, position) {
                return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
            }

            function validateDelta(docLines, delta) {
                if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
                if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
                if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
                var start = delta.start;
                if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
                var end = delta.end;
                if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
                var numRangeRows = end.row - start.row;
                var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
                if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
            }

            exports.applyDelta = function (docLines, delta, doNotValidate) {

                var row = delta.start.row;
                var startColumn = delta.start.column;
                var line = docLines[row] || "";
                switch (delta.action) {
                    case "insert":
                        var lines = delta.lines;
                        if (lines.length === 1) {
                            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                        } else {
                            var args = [row, 1].concat(delta.lines);
                            docLines.splice.apply(docLines, args);
                            docLines[row] = line.substring(0, startColumn) + docLines[row];
                            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                        }
                        break;
                    case "remove":
                        var endColumn = delta.end.column;
                        var endRow = delta.end.row;
                        if (row === endRow) {
                            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                        } else {
                            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                        }
                        break;
                }
            };
        });

        ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var Anchor = exports.Anchor = function (doc, row, column) {
                this.$onChange = this.onChange.bind(this);
                this.attach(doc);

                if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.getPosition = function () {
                    return this.$clipPositionToDocument(this.row, this.column);
                };
                this.getDocument = function () {
                    return this.document;
                };
                this.$insertRight = false;
                this.onChange = function (delta) {
                    if (delta.start.row == delta.end.row && delta.start.row != this.row) return;

                    if (delta.start.row > this.row) return;

                    var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
                    this.setPosition(point.row, point.column, true);
                };

                function $pointsInOrder(point1, point2, equalPointsInOrder) {
                    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
                    return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
                }

                function $getTransformedPoint(delta, point, moveIfEqual) {
                    var deltaIsInsert = delta.action == "insert";
                    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
                    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
                    var deltaStart = delta.start;
                    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
                    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                        return {
                            row: point.row,
                            column: point.column
                        };
                    }
                    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                        return {
                            row: point.row + deltaRowShift,
                            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                        };
                    }

                    return {
                        row: deltaStart.row,
                        column: deltaStart.column
                    };
                }
                this.setPosition = function (row, column, noClip) {
                    var pos;
                    if (noClip) {
                        pos = {
                            row: row,
                            column: column
                        };
                    } else {
                        pos = this.$clipPositionToDocument(row, column);
                    }

                    if (this.row == pos.row && this.column == pos.column) return;

                    var old = {
                        row: this.row,
                        column: this.column
                    };

                    this.row = pos.row;
                    this.column = pos.column;
                    this._signal("change", {
                        old: old,
                        value: pos
                    });
                };
                this.detach = function () {
                    this.document.removeEventListener("change", this.$onChange);
                };
                this.attach = function (doc) {
                    this.document = doc || this.document;
                    this.document.on("change", this.$onChange);
                };
                this.$clipPositionToDocument = function (row, column) {
                    var pos = {};

                    if (row >= this.document.getLength()) {
                        pos.row = Math.max(0, this.document.getLength() - 1);
                        pos.column = this.document.getLine(pos.row).length;
                    } else if (row < 0) {
                        pos.row = 0;
                        pos.column = 0;
                    } else {
                        pos.row = row;
                        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                    }

                    if (column < 0) pos.column = 0;

                    return pos;
                };
            }).call(Anchor.prototype);
        });

        ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var applyDelta = require("./apply_delta").applyDelta;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Anchor = require("./anchor").Anchor;

            var Document = function (textOrLines) {
                this.$lines = [""];
                if (textOrLines.length === 0) {
                    this.$lines = [""];
                } else if (Array.isArray(textOrLines)) {
                    this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
                } else {
                    this.insert({ row: 0, column: 0 }, textOrLines);
                }
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setValue = function (text) {
                    var len = this.getLength() - 1;
                    this.remove(new Range(0, 0, len, this.getLine(len).length));
                    this.insert({ row: 0, column: 0 }, text);
                };
                this.getValue = function () {
                    return this.getAllLines().join(this.getNewLineCharacter());
                };
                this.createAnchor = function (row, column) {
                    return new Anchor(this, row, column);
                };
                if ("aaa".split(/a/).length === 0) {
                    this.$split = function (text) {
                        return text.replace(/\r\n|\r/g, "\n").split("\n");
                    };
                } else {
                    this.$split = function (text) {
                        return text.split(/\r\n|\r|\n/);
                    };
                }

                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r\n|\r|\n)/m);
                    this.$autoNewLine = match ? match[1] : "\n";
                    this._signal("changeNewLineMode");
                };
                this.getNewLineCharacter = function () {
                    switch (this.$newLineMode) {
                        case "windows":
                            return "\r\n";
                        case "unix":
                            return "\n";
                        default:
                            return this.$autoNewLine || "\n";
                    }
                };

                this.$autoNewLine = "";
                this.$newLineMode = "auto";
                this.setNewLineMode = function (newLineMode) {
                    if (this.$newLineMode === newLineMode) return;

                    this.$newLineMode = newLineMode;
                    this._signal("changeNewLineMode");
                };
                this.getNewLineMode = function () {
                    return this.$newLineMode;
                };
                this.isNewLine = function (text) {
                    return text == "\r\n" || text == "\r" || text == "\n";
                };
                this.getLine = function (row) {
                    return this.$lines[row] || "";
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.$lines.slice(firstRow, lastRow + 1);
                };
                this.getAllLines = function () {
                    return this.getLines(0, this.getLength());
                };
                this.getLength = function () {
                    return this.$lines.length;
                };
                this.getTextRange = function (range) {
                    return this.getLinesForRange(range).join(this.getNewLineCharacter());
                };
                this.getLinesForRange = function (range) {
                    var lines;
                    if (range.start.row === range.end.row) {
                        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
                    } else {
                        lines = this.getLines(range.start.row, range.end.row);
                        lines[0] = (lines[0] || "").substring(range.start.column);
                        var l = lines.length - 1;
                        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
                    }
                    return lines;
                };
                this.insertLines = function (row, lines) {
                    console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
                    return this.insertFullLines(row, lines);
                };
                this.removeLines = function (firstRow, lastRow) {
                    console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
                    return this.removeFullLines(firstRow, lastRow);
                };
                this.insertNewLine = function (position) {
                    console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
                    return this.insertMergedLines(position, ["", ""]);
                };
                this.insert = function (position, text) {
                    if (this.getLength() <= 1) this.$detectNewLine(text);

                    return this.insertMergedLines(position, this.$split(text));
                };
                this.insertInLine = function (position, text) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = this.pos(position.row, position.column + text.length);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: [text]
                    }, true);

                    return this.clonePos(end);
                };

                this.clippedPos = function (row, column) {
                    var length = this.getLength();
                    if (row === undefined) {
                        row = length;
                    } else if (row < 0) {
                        row = 0;
                    } else if (row >= length) {
                        row = length - 1;
                        column = undefined;
                    }
                    var line = this.getLine(row);
                    if (column == undefined) column = line.length;
                    column = Math.min(Math.max(column, 0), line.length);
                    return { row: row, column: column };
                };

                this.clonePos = function (pos) {
                    return { row: pos.row, column: pos.column };
                };

                this.pos = function (row, column) {
                    return { row: row, column: column };
                };

                this.$clipPosition = function (position) {
                    var length = this.getLength();
                    if (position.row >= length) {
                        position.row = Math.max(0, length - 1);
                        position.column = this.getLine(length - 1).length;
                    } else {
                        position.row = Math.max(0, position.row);
                        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
                    }
                    return position;
                };
                this.insertFullLines = function (row, lines) {
                    row = Math.min(Math.max(row, 0), this.getLength());
                    var column = 0;
                    if (row < this.getLength()) {
                        lines = lines.concat([""]);
                        column = 0;
                    } else {
                        lines = [""].concat(lines);
                        row--;
                        column = this.$lines[row].length;
                    }
                    this.insertMergedLines({ row: row, column: column }, lines);
                };
                this.insertMergedLines = function (position, lines) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = {
                        row: start.row + lines.length - 1,
                        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
                    };

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: lines
                    });

                    return this.clonePos(end);
                };
                this.remove = function (range) {
                    var start = this.clippedPos(range.start.row, range.start.column);
                    var end = this.clippedPos(range.end.row, range.end.column);
                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    });
                    return this.clonePos(start);
                };
                this.removeInLine = function (row, startColumn, endColumn) {
                    var start = this.clippedPos(row, startColumn);
                    var end = this.clippedPos(row, endColumn);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    }, true);

                    return this.clonePos(start);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
                    lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
                    var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
                    var deleteLastNewLine = lastRow < this.getLength() - 1;
                    var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
                    var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
                    var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
                    var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
                    var range = new Range(startRow, startCol, endRow, endCol);
                    var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

                    this.applyDelta({
                        start: range.start,
                        end: range.end,
                        action: "remove",
                        lines: this.getLinesForRange(range)
                    });
                    return deletedLines;
                };
                this.removeNewLine = function (row) {
                    if (row < this.getLength() - 1 && row >= 0) {
                        this.applyDelta({
                            start: this.pos(row, this.getLine(row).length),
                            end: this.pos(row + 1, 0),
                            action: "remove",
                            lines: ["", ""]
                        });
                    }
                };
                this.replace = function (range, text) {
                    if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
                    if (text.length === 0 && range.isEmpty()) return range.start;
                    if (text == this.getTextRange(range)) return range.end;

                    this.remove(range);
                    var end;
                    if (text) {
                        end = this.insert(range.start, text);
                    } else {
                        end = range.start;
                    }

                    return end;
                };
                this.applyDeltas = function (deltas) {
                    for (var i = 0; i < deltas.length; i++) {
                        this.applyDelta(deltas[i]);
                    }
                };
                this.revertDeltas = function (deltas) {
                    for (var i = deltas.length - 1; i >= 0; i--) {
                        this.revertDelta(deltas[i]);
                    }
                };
                this.applyDelta = function (delta, doNotValidate) {
                    var isInsert = delta.action == "insert";
                    if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
                        return;
                    }

                    if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
                    applyDelta(this.$lines, delta, doNotValidate);
                    this._signal("change", delta);
                };

                this.$splitAndapplyLargeDelta = function (delta, MAX) {
                    var lines = delta.lines;
                    var l = lines.length;
                    var row = delta.start.row;
                    var column = delta.start.column;
                    var from = 0,
                        to = 0;
                    do {
                        from = to;
                        to += MAX - 1;
                        var chunk = lines.slice(from, to);
                        if (to > l) {
                            delta.lines = chunk;
                            delta.start.row = row + from;
                            delta.start.column = column;
                            break;
                        }
                        chunk.push("");
                        this.applyDelta({
                            start: this.pos(row + from, column),
                            end: this.pos(row + to, column = 0),
                            action: delta.action,
                            lines: chunk
                        }, true);
                    } while (true);
                };
                this.revertDelta = function (delta) {
                    this.applyDelta({
                        start: this.clonePos(delta.start),
                        end: this.clonePos(delta.end),
                        action: delta.action == "insert" ? "remove" : "insert",
                        lines: delta.lines.slice()
                    });
                };
                this.indexToPosition = function (index, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    for (var i = startRow || 0, l = lines.length; i < l; i++) {
                        index -= lines[i].length + newlineLength;
                        if (index < 0) return { row: i, column: index + lines[i].length + newlineLength };
                    }
                    return { row: l - 1, column: lines[l - 1].length };
                };
                this.positionToIndex = function (pos, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    var index = 0;
                    var row = Math.min(pos.row, lines.length);
                    for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;

                    return index + pos.column;
                };
            }).call(Document.prototype);

            exports.Document = Document;
        });

        ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var BackgroundTokenizer = function (tokenizer, editor) {
                this.running = false;
                this.lines = [];
                this.states = [];
                this.currentLine = 0;
                this.tokenizer = tokenizer;

                var self = this;

                this.$worker = function () {
                    if (!self.running) {
                        return;
                    }

                    var workerStart = new Date();
                    var currentLine = self.currentLine;
                    var endLine = -1;
                    var doc = self.doc;

                    var startLine = currentLine;
                    while (self.lines[currentLine]) currentLine++;

                    var len = doc.getLength();
                    var processedLines = 0;
                    self.running = false;
                    while (currentLine < len) {
                        self.$tokenizeRow(currentLine);
                        endLine = currentLine;
                        do {
                            currentLine++;
                        } while (self.lines[currentLine]);
                        processedLines++;
                        if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
                            self.running = setTimeout(self.$worker, 20);
                            break;
                        }
                    }
                    self.currentLine = currentLine;

                    if (startLine <= endLine) self.fireUpdateEvent(startLine, endLine);
                };
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setTokenizer = function (tokenizer) {
                    this.tokenizer = tokenizer;
                    this.lines = [];
                    this.states = [];

                    this.start(0);
                };
                this.setDocument = function (doc) {
                    this.doc = doc;
                    this.lines = [];
                    this.states = [];

                    this.stop();
                };
                this.fireUpdateEvent = function (firstRow, lastRow) {
                    var data = {
                        first: firstRow,
                        last: lastRow
                    };
                    this._signal("update", { data: data });
                };
                this.start = function (startRow) {
                    this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                    this.lines.splice(this.currentLine, this.lines.length);
                    this.states.splice(this.currentLine, this.states.length);

                    this.stop();
                    this.running = setTimeout(this.$worker, 700);
                };

                this.scheduleStart = function () {
                    if (!this.running) this.running = setTimeout(this.$worker, 700);
                };

                this.$updateOnChange = function (delta) {
                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {
                        this.lines[startRow] = null;
                    } else if (delta.action == "remove") {
                        this.lines.splice(startRow, len + 1, null);
                        this.states.splice(startRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(startRow, 1);
                        this.lines.splice.apply(this.lines, args);
                        this.states.splice.apply(this.states, args);
                    }

                    this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

                    this.stop();
                };
                this.stop = function () {
                    if (this.running) clearTimeout(this.running);
                    this.running = false;
                };
                this.getTokens = function (row) {
                    return this.lines[row] || this.$tokenizeRow(row);
                };
                this.getState = function (row) {
                    if (this.currentLine == row) this.$tokenizeRow(row);
                    return this.states[row] || "start";
                };

                this.$tokenizeRow = function (row) {
                    var line = this.doc.getLine(row);
                    var state = this.states[row - 1];

                    var data = this.tokenizer.getLineTokens(line, state, row);

                    if (this.states[row] + "" !== data.state + "") {
                        this.states[row] = data.state;
                        this.lines[row + 1] = null;
                        if (this.currentLine > row + 1) this.currentLine = row + 1;
                    } else if (this.currentLine == row) {
                        this.currentLine = row + 1;
                    }

                    return this.lines[row] = data.tokens;
                };
            }).call(BackgroundTokenizer.prototype);

            exports.BackgroundTokenizer = BackgroundTokenizer;
        });

        ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var SearchHighlight = function (regExp, clazz, type) {
                this.setRegexp(regExp);
                this.clazz = clazz;
                this.type = type || "text";
            };

            (function () {
                this.MAX_RANGES = 500;

                this.setRegexp = function (regExp) {
                    if (this.regExp + "" == regExp + "") return;
                    this.regExp = regExp;
                    this.cache = [];
                };

                this.update = function (html, markerLayer, session, config) {
                    if (!this.regExp) return;
                    var start = config.firstRow,
                        end = config.lastRow;

                    for (var i = start; i <= end; i++) {
                        var ranges = this.cache[i];
                        if (ranges == null) {
                            ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                            if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                            ranges = ranges.map(function (match) {
                                return new Range(i, match.offset, i, match.offset + match.length);
                            });
                            this.cache[i] = ranges.length ? ranges : "";
                        }

                        for (var j = ranges.length; j--;) {
                            markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
                        }
                    }
                };
            }).call(SearchHighlight.prototype);

            exports.SearchHighlight = SearchHighlight;
        });

        ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            function FoldLine(foldData, folds) {
                this.foldData = foldData;
                if (Array.isArray(folds)) {
                    this.folds = folds;
                } else {
                    folds = this.folds = [folds];
                }

                var last = folds[folds.length - 1];
                this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
                this.start = this.range.start;
                this.end = this.range.end;

                this.folds.forEach(function (fold) {
                    fold.setFoldLine(this);
                }, this);
            }

            (function () {
                this.shiftRow = function (shift) {
                    this.start.row += shift;
                    this.end.row += shift;
                    this.folds.forEach(function (fold) {
                        fold.start.row += shift;
                        fold.end.row += shift;
                    });
                };

                this.addFold = function (fold) {
                    if (fold.sameRow) {
                        if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                            throw new Error("Can't add a fold to this FoldLine as it has no connection");
                        }
                        this.folds.push(fold);
                        this.folds.sort(function (a, b) {
                            return -a.range.compareEnd(b.start.row, b.start.column);
                        });
                        if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                            this.end.row = fold.end.row;
                            this.end.column = fold.end.column;
                        } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                            this.start.row = fold.start.row;
                            this.start.column = fold.start.column;
                        }
                    } else if (fold.start.row == this.end.row) {
                        this.folds.push(fold);
                        this.end.row = fold.end.row;
                        this.end.column = fold.end.column;
                    } else if (fold.end.row == this.start.row) {
                        this.folds.unshift(fold);
                        this.start.row = fold.start.row;
                        this.start.column = fold.start.column;
                    } else {
                        throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                    }
                    fold.foldLine = this;
                };

                this.containsRow = function (row) {
                    return row >= this.start.row && row <= this.end.row;
                };

                this.walk = function (callback, endRow, endColumn) {
                    var lastEnd = 0,
                        folds = this.folds,
                        fold,
                        cmp,
                        stop,
                        isNewRow = true;

                    if (endRow == null) {
                        endRow = this.end.row;
                        endColumn = this.end.column;
                    }

                    for (var i = 0; i < folds.length; i++) {
                        fold = folds[i];

                        cmp = fold.range.compareStart(endRow, endColumn);
                        if (cmp == -1) {
                            callback(null, endRow, endColumn, lastEnd, isNewRow);
                            return;
                        }

                        stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                        stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                        if (stop || cmp === 0) {
                            return;
                        }
                        isNewRow = !fold.sameRow;
                        lastEnd = fold.end.column;
                    }
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                };

                this.getNextFoldTo = function (row, column) {
                    var fold, cmp;
                    for (var i = 0; i < this.folds.length; i++) {
                        fold = this.folds[i];
                        cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            return {
                                fold: fold,
                                kind: "after"
                            };
                        } else if (cmp === 0) {
                            return {
                                fold: fold,
                                kind: "inside"
                            };
                        }
                    }
                    return null;
                };

                this.addRemoveChars = function (row, column, len) {
                    var ret = this.getNextFoldTo(row, column),
                        fold,
                        folds;
                    if (ret) {
                        fold = ret.fold;
                        if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                            window.console && window.console.log(row, column, fold);
                        } else if (fold.start.row == row) {
                            folds = this.folds;
                            var i = folds.indexOf(fold);
                            if (i === 0) {
                                this.start.column += len;
                            }
                            for (i; i < folds.length; i++) {
                                fold = folds[i];
                                fold.start.column += len;
                                if (!fold.sameRow) {
                                    return;
                                }
                                fold.end.column += len;
                            }
                            this.end.column += len;
                        }
                    }
                };

                this.split = function (row, column) {
                    var pos = this.getNextFoldTo(row, column);

                    if (!pos || pos.kind == "inside") return null;

                    var fold = pos.fold;
                    var folds = this.folds;
                    var foldData = this.foldData;

                    var i = folds.indexOf(fold);
                    var foldBefore = folds[i - 1];
                    this.end.row = foldBefore.end.row;
                    this.end.column = foldBefore.end.column;
                    folds = folds.splice(i, folds.length - i);

                    var newFoldLine = new FoldLine(foldData, folds);
                    foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                    return newFoldLine;
                };

                this.merge = function (foldLineNext) {
                    var folds = foldLineNext.folds;
                    for (var i = 0; i < folds.length; i++) {
                        this.addFold(folds[i]);
                    }
                    var foldData = this.foldData;
                    foldData.splice(foldData.indexOf(foldLineNext), 1);
                };

                this.toString = function () {
                    var ret = [this.range.toString() + ": ["];

                    this.folds.forEach(function (fold) {
                        ret.push("  " + fold.toString());
                    });
                    ret.push("]");
                    return ret.join("\n");
                };

                this.idxToPosition = function (idx) {
                    var lastFoldEndColumn = 0;

                    for (var i = 0; i < this.folds.length; i++) {
                        var fold = this.folds[i];

                        idx -= fold.start.column - lastFoldEndColumn;
                        if (idx < 0) {
                            return {
                                row: fold.start.row,
                                column: fold.start.column + idx
                            };
                        }

                        idx -= fold.placeholder.length;
                        if (idx < 0) {
                            return fold.start;
                        }

                        lastFoldEndColumn = fold.end.column;
                    }

                    return {
                        row: this.end.row,
                        column: this.end.column + idx
                    };
                };
            }).call(FoldLine.prototype);

            exports.FoldLine = FoldLine;
        });

        ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var comparePoints = Range.comparePoints;

            var RangeList = function () {
                this.ranges = [];
            };

            (function () {
                this.comparePoints = comparePoints;

                this.pointIndex = function (pos, excludeEdges, startIndex) {
                    var list = this.ranges;

                    for (var i = startIndex || 0; i < list.length; i++) {
                        var range = list[i];
                        var cmpEnd = comparePoints(pos, range.end);
                        if (cmpEnd > 0) continue;
                        var cmpStart = comparePoints(pos, range.start);
                        if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                        if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;

                        return -i - 1;
                    }
                    return -i - 1;
                };

                this.add = function (range) {
                    var excludeEdges = !range.isEmpty();
                    var startIndex = this.pointIndex(range.start, excludeEdges);
                    if (startIndex < 0) startIndex = -startIndex - 1;

                    var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

                    if (endIndex < 0) endIndex = -endIndex - 1;else endIndex++;
                    return this.ranges.splice(startIndex, endIndex - startIndex, range);
                };

                this.addList = function (list) {
                    var removed = [];
                    for (var i = list.length; i--;) {
                        removed.push.apply(removed, this.add(list[i]));
                    }
                    return removed;
                };

                this.substractPoint = function (pos) {
                    var i = this.pointIndex(pos);

                    if (i >= 0) return this.ranges.splice(i, 1);
                };
                this.merge = function () {
                    var removed = [];
                    var list = this.ranges;

                    list = list.sort(function (a, b) {
                        return comparePoints(a.start, b.start);
                    });

                    var next = list[0],
                        range;
                    for (var i = 1; i < list.length; i++) {
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;

                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;

                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }

                        list.splice(i, 1);
                        removed.push(next);
                        next = range;
                        i--;
                    }

                    this.ranges = list;

                    return removed;
                };

                this.contains = function (row, column) {
                    return this.pointIndex({ row: row, column: column }) >= 0;
                };

                this.containsPoint = function (pos) {
                    return this.pointIndex(pos) >= 0;
                };

                this.rangeAtPoint = function (pos) {
                    var i = this.pointIndex(pos);
                    if (i >= 0) return this.ranges[i];
                };

                this.clipRows = function (startRow, endRow) {
                    var list = this.ranges;
                    if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];

                    var startIndex = this.pointIndex({ row: startRow, column: 0 });
                    if (startIndex < 0) startIndex = -startIndex - 1;
                    var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
                    if (endIndex < 0) endIndex = -endIndex - 1;

                    var clipped = [];
                    for (var i = startIndex; i < endIndex; i++) {
                        clipped.push(list[i]);
                    }
                    return clipped;
                };

                this.removeAll = function () {
                    return this.ranges.splice(0, this.ranges.length);
                };

                this.attach = function (session) {
                    if (this.session) this.detach();

                    this.session = session;
                    this.onChange = this.$onChange.bind(this);

                    this.session.on('change', this.onChange);
                };

                this.detach = function () {
                    if (!this.session) return;
                    this.session.removeListener('change', this.onChange);
                    this.session = null;
                };

                this.$onChange = function (delta) {
                    if (delta.action == "insert") {
                        var start = delta.start;
                        var end = delta.end;
                    } else {
                        var end = delta.start;
                        var start = delta.end;
                    }
                    var startRow = start.row;
                    var endRow = end.row;
                    var lineDif = endRow - startRow;

                    var colDiff = -start.column + end.column;
                    var ranges = this.ranges;

                    for (var i = 0, n = ranges.length; i < n; i++) {
                        var r = ranges[i];
                        if (r.end.row < startRow) continue;
                        if (r.start.row > startRow) break;

                        if (r.start.row == startRow && r.start.column >= start.column) {
                            if (r.start.column == start.column && this.$insertRight) {} else {
                                r.start.column += colDiff;
                                r.start.row += lineDif;
                            }
                        }
                        if (r.end.row == startRow && r.end.column >= start.column) {
                            if (r.end.column == start.column && this.$insertRight) {
                                continue;
                            }
                            if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
                            }
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    }

                    if (lineDif != 0 && i < n) {
                        for (; i < n; i++) {
                            var r = ranges[i];
                            r.start.row += lineDif;
                            r.end.row += lineDif;
                        }
                    }
                };
            }).call(RangeList.prototype);

            exports.RangeList = RangeList;
        });

        ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var RangeList = require("../range_list").RangeList;
            var oop = require("../lib/oop");
            var Fold = exports.Fold = function (range, placeholder) {
                this.foldLine = null;
                this.placeholder = placeholder;
                this.range = range;
                this.start = range.start;
                this.end = range.end;

                this.sameRow = range.start.row == range.end.row;
                this.subFolds = this.ranges = [];
            };

            oop.inherits(Fold, RangeList);

            (function () {

                this.toString = function () {
                    return '"' + this.placeholder + '" ' + this.range.toString();
                };

                this.setFoldLine = function (foldLine) {
                    this.foldLine = foldLine;
                    this.subFolds.forEach(function (fold) {
                        fold.setFoldLine(foldLine);
                    });
                };

                this.clone = function () {
                    var range = this.range.clone();
                    var fold = new Fold(range, this.placeholder);
                    this.subFolds.forEach(function (subFold) {
                        fold.subFolds.push(subFold.clone());
                    });
                    fold.collapseChildren = this.collapseChildren;
                    return fold;
                };

                this.addSubFold = function (fold) {
                    if (this.range.isEqual(fold)) return;

                    if (!this.range.containsRange(fold)) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
                    consumeRange(fold, this.start);

                    var row = fold.start.row,
                        column = fold.start.column;
                    for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                        cmp = this.subFolds[i].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterStart = this.subFolds[i];

                    if (cmp == 0) return afterStart.addSubFold(fold);
                    var row = fold.range.end.row,
                        column = fold.range.end.column;
                    for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                        cmp = this.subFolds[j].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterEnd = this.subFolds[j];

                    if (cmp == 0) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

                    var consumedFolds = this.subFolds.splice(i, j - i, fold);
                    fold.setFoldLine(this.foldLine);

                    return fold;
                };

                this.restoreRange = function (range) {
                    return restoreRange(range, this.start);
                };
            }).call(Fold.prototype);

            function consumePoint(point, anchor) {
                point.row -= anchor.row;
                if (point.row == 0) point.column -= anchor.column;
            }
            function consumeRange(range, anchor) {
                consumePoint(range.start, anchor);
                consumePoint(range.end, anchor);
            }
            function restorePoint(point, anchor) {
                if (point.row == 0) point.column += anchor.column;
                point.row += anchor.row;
            }
            function restoreRange(range, anchor) {
                restorePoint(range.start, anchor);
                restorePoint(range.end, anchor);
            }
        });

        ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var FoldLine = require("./fold_line").FoldLine;
            var Fold = require("./fold").Fold;
            var TokenIterator = require("../token_iterator").TokenIterator;

            function Folding() {
                this.getFoldAt = function (row, column, side) {
                    var foldLine = this.getFoldLine(row);
                    if (!foldLine) return null;

                    var folds = foldLine.folds;
                    for (var i = 0; i < folds.length; i++) {
                        var fold = folds[i];
                        if (fold.range.contains(row, column)) {
                            if (side == 1 && fold.range.isEnd(row, column)) {
                                continue;
                            } else if (side == -1 && fold.range.isStart(row, column)) {
                                continue;
                            }
                            return fold;
                        }
                    }
                };
                this.getFoldsInRange = function (range) {
                    var start = range.start;
                    var end = range.end;
                    var foldLines = this.$foldData;
                    var foundFolds = [];

                    start.column += 1;
                    end.column -= 1;

                    for (var i = 0; i < foldLines.length; i++) {
                        var cmp = foldLines[i].range.compareRange(range);
                        if (cmp == 2) {
                            continue;
                        } else if (cmp == -2) {
                            break;
                        }

                        var folds = foldLines[i].folds;
                        for (var j = 0; j < folds.length; j++) {
                            var fold = folds[j];
                            cmp = fold.range.compareRange(range);
                            if (cmp == -2) {
                                break;
                            } else if (cmp == 2) {
                                continue;
                            } else if (cmp == 42) {
                                break;
                            }
                            foundFolds.push(fold);
                        }
                    }
                    start.column -= 1;
                    end.column += 1;

                    return foundFolds;
                };

                this.getFoldsInRangeList = function (ranges) {
                    if (Array.isArray(ranges)) {
                        var folds = [];
                        ranges.forEach(function (range) {
                            folds = folds.concat(this.getFoldsInRange(range));
                        }, this);
                    } else {
                        var folds = this.getFoldsInRange(ranges);
                    }
                    return folds;
                };
                this.getAllFolds = function () {
                    var folds = [];
                    var foldLines = this.$foldData;

                    for (var i = 0; i < foldLines.length; i++) for (var j = 0; j < foldLines[i].folds.length; j++) folds.push(foldLines[i].folds[j]);

                    return folds;
                };
                this.getFoldStringAt = function (row, column, trim, foldLine) {
                    foldLine = foldLine || this.getFoldLine(row);
                    if (!foldLine) return null;

                    var lastFold = {
                        end: { column: 0 }
                    };
                    var str, fold;
                    for (var i = 0; i < foldLine.folds.length; i++) {
                        fold = foldLine.folds[i];
                        var cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                            break;
                        } else if (cmp === 0) {
                            return null;
                        }
                        lastFold = fold;
                    }
                    if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);

                    if (trim == -1) return str.substring(0, column - lastFold.end.column);else if (trim == 1) return str.substring(column - lastFold.end.column);else return str;
                };

                this.getFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                            return foldLine;
                        } else if (foldLine.end.row > docRow) {
                            return null;
                        }
                    }
                    return null;
                };
                this.getNextFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.end.row >= docRow) {
                            return foldLine;
                        }
                    }
                    return null;
                };

                this.getFoldedRowCount = function (first, last) {
                    var foldData = this.$foldData,
                        rowCount = last - first + 1;
                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i],
                            end = foldLine.end.row,
                            start = foldLine.start.row;
                        if (end >= last) {
                            if (start < last) {
                                if (start >= first) rowCount -= last - start;else rowCount = 0; // in one fold
                            }
                            break;
                        } else if (end >= first) {
                            if (start >= first) // fold inside range
                                rowCount -= end - start;else rowCount -= end - first + 1;
                        }
                    }
                    return rowCount;
                };

                this.$addFoldLine = function (foldLine) {
                    this.$foldData.push(foldLine);
                    this.$foldData.sort(function (a, b) {
                        return a.start.row - b.start.row;
                    });
                    return foldLine;
                };
                this.addFold = function (placeholder, range) {
                    var foldData = this.$foldData;
                    var added = false;
                    var fold;

                    if (placeholder instanceof Fold) fold = placeholder;else {
                        fold = new Fold(range, placeholder);
                        fold.collapseChildren = range.collapseChildren;
                    }
                    this.$clipRangeToDocument(fold.range);

                    var startRow = fold.start.row;
                    var startColumn = fold.start.column;
                    var endRow = fold.end.row;
                    var endColumn = fold.end.column;
                    if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2)) throw new Error("The range has to be at least 2 characters width");

                    var startFold = this.getFoldAt(startRow, startColumn, 1);
                    var endFold = this.getFoldAt(endRow, endColumn, -1);
                    if (startFold && endFold == startFold) return startFold.addSubFold(fold);

                    if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);

                    if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
                    var folds = this.getFoldsInRange(fold.range);
                    if (folds.length > 0) {
                        this.removeFolds(folds);
                        folds.forEach(function (subFold) {
                            fold.addSubFold(subFold);
                        });
                    }

                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (endRow == foldLine.start.row) {
                            foldLine.addFold(fold);
                            added = true;
                            break;
                        } else if (startRow == foldLine.end.row) {
                            foldLine.addFold(fold);
                            added = true;
                            if (!fold.sameRow) {
                                var foldLineNext = foldData[i + 1];
                                if (foldLineNext && foldLineNext.start.row == endRow) {
                                    foldLine.merge(foldLineNext);
                                    break;
                                }
                            }
                            break;
                        } else if (endRow <= foldLine.start.row) {
                            break;
                        }
                    }

                    if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

                    if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "add" });

                    return fold;
                };

                this.addFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.addFold(fold);
                    }, this);
                };

                this.removeFold = function (fold) {
                    var foldLine = fold.foldLine;
                    var startRow = foldLine.start.row;
                    var endRow = foldLine.end.row;

                    var foldLines = this.$foldData;
                    var folds = foldLine.folds;
                    if (folds.length == 1) {
                        foldLines.splice(foldLines.indexOf(foldLine), 1);
                    } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                        folds.pop();
                        foldLine.end.row = folds[folds.length - 1].end.row;
                        foldLine.end.column = folds[folds.length - 1].end.column;
                    } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                        folds.shift();
                        foldLine.start.row = folds[0].start.row;
                        foldLine.start.column = folds[0].start.column;
                    } else if (fold.sameRow) {
                        folds.splice(folds.indexOf(fold), 1);
                    } else {
                        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                        folds = newFoldLine.folds;
                        folds.shift();
                        newFoldLine.start.row = folds[0].start.row;
                        newFoldLine.start.column = folds[0].start.column;
                    }

                    if (!this.$updating) {
                        if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);else this.$updateRowLengthCache(startRow, endRow);
                    }
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "remove" });
                };

                this.removeFolds = function (folds) {
                    var cloneFolds = [];
                    for (var i = 0; i < folds.length; i++) {
                        cloneFolds.push(folds[i]);
                    }

                    cloneFolds.forEach(function (fold) {
                        this.removeFold(fold);
                    }, this);
                    this.$modified = true;
                };

                this.expandFold = function (fold) {
                    this.removeFold(fold);
                    fold.subFolds.forEach(function (subFold) {
                        fold.restoreRange(subFold);
                        this.addFold(subFold);
                    }, this);
                    if (fold.collapseChildren > 0) {
                        this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
                    }
                    fold.subFolds = [];
                };

                this.expandFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.expandFold(fold);
                    }, this);
                };

                this.unfold = function (location, expandInner) {
                    var range, folds;
                    if (location == null) {
                        range = new Range(0, 0, this.getLength(), 0);
                        expandInner = true;
                    } else if (typeof location == "number") range = new Range(location, 0, location, this.getLine(location).length);else if ("row" in location) range = Range.fromPoints(location, location);else range = location;

                    folds = this.getFoldsInRangeList(range);
                    if (expandInner) {
                        this.removeFolds(folds);
                    } else {
                        var subFolds = folds;
                        while (subFolds.length) {
                            this.expandFolds(subFolds);
                            subFolds = this.getFoldsInRangeList(range);
                        }
                    }
                    if (folds.length) return folds;
                };
                this.isRowFolded = function (docRow, startFoldRow) {
                    return !!this.getFoldLine(docRow, startFoldRow);
                };

                this.getRowFoldEnd = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.end.row : docRow;
                };

                this.getRowFoldStart = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.start.row : docRow;
                };

                this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
                    if (startRow == null) startRow = foldLine.start.row;
                    if (startColumn == null) startColumn = 0;
                    if (endRow == null) endRow = foldLine.end.row;
                    if (endColumn == null) endColumn = this.getLine(endRow).length;
                    var doc = this.doc;
                    var textLine = "";

                    foldLine.walk(function (placeholder, row, column, lastColumn) {
                        if (row < startRow) return;
                        if (row == startRow) {
                            if (column < startColumn) return;
                            lastColumn = Math.max(startColumn, lastColumn);
                        }

                        if (placeholder != null) {
                            textLine += placeholder;
                        } else {
                            textLine += doc.getLine(row).substring(lastColumn, column);
                        }
                    }, endRow, endColumn);
                    return textLine;
                };

                this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
                    var foldLine = this.getFoldLine(row);

                    if (!foldLine) {
                        var line;
                        line = this.doc.getLine(row);
                        return line.substring(startColumn || 0, endColumn || line.length);
                    } else {
                        return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
                    }
                };

                this.$cloneFoldData = function () {
                    var fd = [];
                    fd = this.$foldData.map(function (foldLine) {
                        var folds = foldLine.folds.map(function (fold) {
                            return fold.clone();
                        });
                        return new FoldLine(fd, folds);
                    });

                    return fd;
                };

                this.toggleFold = function (tryToUnfold) {
                    var selection = this.selection;
                    var range = selection.getRange();
                    var fold;
                    var bracketPos;

                    if (range.isEmpty()) {
                        var cursor = range.start;
                        fold = this.getFoldAt(cursor.row, cursor.column);

                        if (fold) {
                            this.expandFold(fold);
                            return;
                        } else if (bracketPos = this.findMatchingBracket(cursor)) {
                            if (range.comparePoint(bracketPos) == 1) {
                                range.end = bracketPos;
                            } else {
                                range.start = bracketPos;
                                range.start.column++;
                                range.end.column--;
                            }
                        } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                            if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;else range.start = bracketPos;

                            range.start.column++;
                        } else {
                            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                        }
                    } else {
                        var folds = this.getFoldsInRange(range);
                        if (tryToUnfold && folds.length) {
                            this.expandFolds(folds);
                            return;
                        } else if (folds.length == 1) {
                            fold = folds[0];
                        }
                    }

                    if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);

                    if (fold && fold.range.toString() == range.toString()) {
                        this.expandFold(fold);
                        return;
                    }

                    var placeholder = "...";
                    if (!range.isMultiLine()) {
                        placeholder = this.getTextRange(range);
                        if (placeholder.length < 4) return;
                        placeholder = placeholder.trim().substring(0, 2) + "..";
                    }

                    this.addFold(placeholder, range);
                };

                this.getCommentFoldRange = function (row, column, dir) {
                    var iterator = new TokenIterator(this, row, column);
                    var token = iterator.getCurrentToken();
                    if (token && /^comment|string/.test(token.type)) {
                        var range = new Range();
                        var re = new RegExp(token.type.replace(/\..*/, "\\."));
                        if (dir != 1) {
                            do {
                                token = iterator.stepBackward();
                            } while (token && re.test(token.type));
                            iterator.stepForward();
                        }

                        range.start.row = iterator.getCurrentTokenRow();
                        range.start.column = iterator.getCurrentTokenColumn() + 2;

                        iterator = new TokenIterator(this, row, column);

                        if (dir != -1) {
                            do {
                                token = iterator.stepForward();
                            } while (token && re.test(token.type));
                            token = iterator.stepBackward();
                        } else token = iterator.getCurrentToken();

                        range.end.row = iterator.getCurrentTokenRow();
                        range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                        return range;
                    }
                };

                this.foldAll = function (startRow, endRow, depth) {
                    if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
                    var foldWidgets = this.foldWidgets;
                    if (!foldWidgets) return; // mode doesn't support folding
                    endRow = endRow || this.getLength();
                    startRow = startRow || 0;
                    for (var row = startRow; row < endRow; row++) {
                        if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                        if (foldWidgets[row] != "start") continue;

                        var range = this.getFoldWidgetRange(row);
                        if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                            row = range.end.row;
                            try {
                                var fold = this.addFold("...", range);
                                if (fold) fold.collapseChildren = depth;
                            } catch (e) {}
                        }
                    }
                };
                this.$foldStyles = {
                    "manual": 1,
                    "markbegin": 1,
                    "markbeginend": 1
                };
                this.$foldStyle = "markbegin";
                this.setFoldStyle = function (style) {
                    if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");

                    if (this.$foldStyle == style) return;

                    this.$foldStyle = style;

                    if (style == "manual") this.unfold();
                    var mode = this.$foldMode;
                    this.$setFolding(null);
                    this.$setFolding(mode);
                };

                this.$setFolding = function (foldMode) {
                    if (this.$foldMode == foldMode) return;

                    this.$foldMode = foldMode;

                    this.off('change', this.$updateFoldWidgets);
                    this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                    this._signal("changeAnnotation");

                    if (!foldMode || this.$foldStyle == "manual") {
                        this.foldWidgets = null;
                        return;
                    }

                    this.foldWidgets = [];
                    this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                    this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

                    this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                    this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
                    this.on('change', this.$updateFoldWidgets);
                    this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                };

                this.getParentFoldRangeData = function (row, ignoreCurrent) {
                    var fw = this.foldWidgets;
                    if (!fw || ignoreCurrent && fw[row]) return {};

                    var i = row - 1,
                        firstRange;
                    while (i >= 0) {
                        var c = fw[i];
                        if (c == null) c = fw[i] = this.getFoldWidget(i);

                        if (c == "start") {
                            var range = this.getFoldWidgetRange(i);
                            if (!firstRange) firstRange = range;
                            if (range && range.end.row >= row) break;
                        }
                        i--;
                    }

                    return {
                        range: i !== -1 && range,
                        firstRange: firstRange
                    };
                };

                this.onFoldWidgetClick = function (row, e) {
                    e = e.domEvent;
                    var options = {
                        children: e.shiftKey,
                        all: e.ctrlKey || e.metaKey,
                        siblings: e.altKey
                    };

                    var range = this.$toggleFoldWidget(row, options);
                    if (!range) {
                        var el = e.target || e.srcElement;
                        if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
                    }
                };

                this.$toggleFoldWidget = function (row, options) {
                    if (!this.getFoldWidget) return;
                    var type = this.getFoldWidget(row);
                    var line = this.getLine(row);

                    var dir = type === "end" ? -1 : 1;
                    var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

                    if (fold) {
                        if (options.children || options.all) this.removeFold(fold);else this.expandFold(fold);
                        return fold;
                    }

                    var range = this.getFoldWidgetRange(row, true);
                    if (range && !range.isMultiLine()) {
                        fold = this.getFoldAt(range.start.row, range.start.column, 1);
                        if (fold && range.isEqual(fold.range)) {
                            this.removeFold(fold);
                            return fold;
                        }
                    }

                    if (options.siblings) {
                        var data = this.getParentFoldRangeData(row);
                        if (data.range) {
                            var startRow = data.range.start.row + 1;
                            var endRow = data.range.end.row;
                        }
                        this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                    } else if (options.children) {
                        endRow = range ? range.end.row : this.getLength();
                        this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
                    } else if (range) {
                        if (options.all) range.collapseChildren = 10000;
                        this.addFold("...", range);
                    }

                    return range;
                };

                this.toggleFoldWidget = function (toggleParent) {
                    var row = this.selection.getCursor().row;
                    row = this.getRowFoldStart(row);
                    var range = this.$toggleFoldWidget(row, {});

                    if (range) return;
                    var data = this.getParentFoldRangeData(row, true);
                    range = data.range || data.firstRange;

                    if (range) {
                        row = range.start.row;
                        var fold = this.getFoldAt(row, this.getLine(row).length, 1);

                        if (fold) {
                            this.removeFold(fold);
                        } else {
                            this.addFold("...", range);
                        }
                    }
                };

                this.updateFoldWidgets = function (delta) {
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;

                    if (len === 0) {
                        this.foldWidgets[firstRow] = null;
                    } else if (delta.action == 'remove') {
                        this.foldWidgets.splice(firstRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.foldWidgets.splice.apply(this.foldWidgets, args);
                    }
                };
                this.tokenizerUpdateFoldWidgets = function (e) {
                    var rows = e.data;
                    if (rows.first != rows.last) {
                        if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
                    }
                };
            }

            exports.Folding = Folding;
        });

        ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            function BracketMatch() {

                this.findMatchingBracket = function (position, chr) {
                    if (position.column == 0) return null;

                    var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
                    if (charBeforeCursor == "") return null;

                    var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) return null;

                    if (match[1]) return this.$findClosingBracket(match[1], position);else return this.$findOpeningBracket(match[2], position);
                };

                this.getBracketRange = function (pos) {
                    var line = this.getLine(pos.row);
                    var before = true,
                        range;

                    var chr = line.charAt(pos.column - 1);
                    var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) {
                        chr = line.charAt(pos.column);
                        pos = { row: pos.row, column: pos.column + 1 };
                        match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                        before = false;
                    }
                    if (!match) return null;

                    if (match[1]) {
                        var bracketPos = this.$findClosingBracket(match[1], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(pos, bracketPos);
                        if (!before) {
                            range.end.column++;
                            range.start.column--;
                        }
                        range.cursor = range.end;
                    } else {
                        var bracketPos = this.$findOpeningBracket(match[2], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(bracketPos, pos);
                        if (!before) {
                            range.start.column++;
                            range.end.column--;
                        }
                        range.cursor = range.start;
                    }

                    return range;
                };

                this.$brackets = {
                    ")": "(",
                    "(": ")",
                    "]": "[",
                    "[": "]",
                    "{": "}",
                    "}": "{"
                };

                this.$findOpeningBracket = function (bracket, position, typeRe) {
                    var openBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                    var value = token.value;

                    while (true) {

                        while (valueIndex >= 0) {
                            var chr = value.charAt(valueIndex);
                            if (chr == openBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex -= 1;
                        }
                        do {
                            token = iterator.stepBackward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        value = token.value;
                        valueIndex = value.length - 1;
                    }

                    return null;
                };

                this.$findClosingBracket = function (bracket, position, typeRe) {
                    var closingBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn();

                    while (true) {

                        var value = token.value;
                        var valueLength = value.length;
                        while (valueIndex < valueLength) {
                            var chr = value.charAt(valueIndex);
                            if (chr == closingBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex += 1;
                        }
                        do {
                            token = iterator.stepForward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        valueIndex = 0;
                    }

                    return null;
                };
            }
            exports.BracketMatch = BracketMatch;
        });

        ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var config = require("./config");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Selection = require("./selection").Selection;
            var TextMode = require("./mode/text").Mode;
            var Range = require("./range").Range;
            var Document = require("./document").Document;
            var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
            var SearchHighlight = require("./search_highlight").SearchHighlight;

            var EditSession = function (text, mode) {
                this.$breakpoints = [];
                this.$decorations = [];
                this.$frontMarkers = {};
                this.$backMarkers = {};
                this.$markerId = 1;
                this.$undoSelect = true;

                this.$foldData = [];
                this.id = "session" + ++EditSession.$uid;
                this.$foldData.toString = function () {
                    return this.join("\n");
                };
                this.on("changeFold", this.onChangeFold.bind(this));
                this.$onChange = this.onChange.bind(this);

                if (typeof text != "object" || !text.getLine) text = new Document(text);

                this.setDocument(text);
                this.selection = new Selection(this);

                config.resetOptions(this);
                this.setMode(mode);
                config._signal("session", this);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setDocument = function (doc) {
                    if (this.doc) this.doc.removeListener("change", this.$onChange);

                    this.doc = doc;
                    doc.on("change", this.$onChange);

                    if (this.bgTokenizer) this.bgTokenizer.setDocument(this.getDocument());

                    this.resetCaches();
                };
                this.getDocument = function () {
                    return this.doc;
                };
                this.$resetRowCache = function (docRow) {
                    if (!docRow) {
                        this.$docRowCache = [];
                        this.$screenRowCache = [];
                        return;
                    }
                    var l = this.$docRowCache.length;
                    var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                    if (l > i) {
                        this.$docRowCache.splice(i, l);
                        this.$screenRowCache.splice(i, l);
                    }
                };

                this.$getRowCacheIndex = function (cacheArray, val) {
                    var low = 0;
                    var hi = cacheArray.length - 1;

                    while (low <= hi) {
                        var mid = low + hi >> 1;
                        var c = cacheArray[mid];

                        if (val > c) low = mid + 1;else if (val < c) hi = mid - 1;else return mid;
                    }

                    return low - 1;
                };

                this.resetCaches = function () {
                    this.$modified = true;
                    this.$wrapData = [];
                    this.$rowLengthCache = [];
                    this.$resetRowCache(0);
                    if (this.bgTokenizer) this.bgTokenizer.start(0);
                };

                this.onChangeFold = function (e) {
                    var fold = e.data;
                    this.$resetRowCache(fold.start.row);
                };

                this.onChange = function (delta) {
                    this.$modified = true;

                    this.$resetRowCache(delta.start.row);

                    var removedFolds = this.$updateInternalDataOnChange(delta);
                    if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
                        this.$deltasDoc.push(delta);
                        if (removedFolds && removedFolds.length != 0) {
                            this.$deltasFold.push({
                                action: "removeFolds",
                                folds: removedFolds
                            });
                        }

                        this.$informUndoManager.schedule();
                    }

                    this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
                    this._signal("change", delta);
                };
                this.setValue = function (text) {
                    this.doc.setValue(text);
                    this.selection.moveTo(0, 0);

                    this.$resetRowCache(0);
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];
                    this.setUndoManager(this.$undoManager);
                    this.getUndoManager().reset();
                };
                this.getValue = this.toString = function () {
                    return this.doc.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.getState = function (row) {
                    return this.bgTokenizer.getState(row);
                };
                this.getTokens = function (row) {
                    return this.bgTokenizer.getTokens(row);
                };
                this.getTokenAt = function (row, column) {
                    var tokens = this.bgTokenizer.getTokens(row);
                    var token,
                        c = 0;
                    if (column == null) {
                        i = tokens.length - 1;
                        c = this.getLine(row).length;
                    } else {
                        for (var i = 0; i < tokens.length; i++) {
                            c += tokens[i].value.length;
                            if (c >= column) break;
                        }
                    }
                    token = tokens[i];
                    if (!token) return null;
                    token.index = i;
                    token.start = c - token.value.length;
                    return token;
                };
                this.setUndoManager = function (undoManager) {
                    this.$undoManager = undoManager;
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];

                    if (this.$informUndoManager) this.$informUndoManager.cancel();

                    if (undoManager) {
                        var self = this;

                        this.$syncInformUndoManager = function () {
                            self.$informUndoManager.cancel();

                            if (self.$deltasFold.length) {
                                self.$deltas.push({
                                    group: "fold",
                                    deltas: self.$deltasFold
                                });
                                self.$deltasFold = [];
                            }

                            if (self.$deltasDoc.length) {
                                self.$deltas.push({
                                    group: "doc",
                                    deltas: self.$deltasDoc
                                });
                                self.$deltasDoc = [];
                            }

                            if (self.$deltas.length > 0) {
                                undoManager.execute({
                                    action: "aceupdate",
                                    args: [self.$deltas, self],
                                    merge: self.mergeUndoDeltas
                                });
                            }
                            self.mergeUndoDeltas = false;
                            self.$deltas = [];
                        };
                        this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
                    }
                };
                this.markUndoGroup = function () {
                    if (this.$syncInformUndoManager) this.$syncInformUndoManager();
                };

                this.$defaultUndoManager = {
                    undo: function () {},
                    redo: function () {},
                    reset: function () {}
                };
                this.getUndoManager = function () {
                    return this.$undoManager || this.$defaultUndoManager;
                };
                this.getTabString = function () {
                    if (this.getUseSoftTabs()) {
                        return lang.stringRepeat(" ", this.getTabSize());
                    } else {
                        return "\t";
                    }
                };
                this.setUseSoftTabs = function (val) {
                    this.setOption("useSoftTabs", val);
                };
                this.getUseSoftTabs = function () {
                    return this.$useSoftTabs && !this.$mode.$indentWithTabs;
                };
                this.setTabSize = function (tabSize) {
                    this.setOption("tabSize", tabSize);
                };
                this.getTabSize = function () {
                    return this.$tabSize;
                };
                this.isTabStop = function (position) {
                    return this.$useSoftTabs && position.column % this.$tabSize === 0;
                };

                this.$overwrite = false;
                this.setOverwrite = function (overwrite) {
                    this.setOption("overwrite", overwrite);
                };
                this.getOverwrite = function () {
                    return this.$overwrite;
                };
                this.toggleOverwrite = function () {
                    this.setOverwrite(!this.$overwrite);
                };
                this.addGutterDecoration = function (row, className) {
                    if (!this.$decorations[row]) this.$decorations[row] = "";
                    this.$decorations[row] += " " + className;
                    this._signal("changeBreakpoint", {});
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
                    this._signal("changeBreakpoint", {});
                };
                this.getBreakpoints = function () {
                    return this.$breakpoints;
                };
                this.setBreakpoints = function (rows) {
                    this.$breakpoints = [];
                    for (var i = 0; i < rows.length; i++) {
                        this.$breakpoints[rows[i]] = "ace_breakpoint";
                    }
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoints = function () {
                    this.$breakpoints = [];
                    this._signal("changeBreakpoint", {});
                };
                this.setBreakpoint = function (row, className) {
                    if (className === undefined) className = "ace_breakpoint";
                    if (className) this.$breakpoints[row] = className;else delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoint = function (row) {
                    delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.addMarker = function (range, clazz, type, inFront) {
                    var id = this.$markerId++;

                    var marker = {
                        range: range,
                        type: type || "line",
                        renderer: typeof type == "function" ? type : null,
                        clazz: clazz,
                        inFront: !!inFront,
                        id: id
                    };

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return id;
                };
                this.addDynamicMarker = function (marker, inFront) {
                    if (!marker.update) return;
                    var id = this.$markerId++;
                    marker.id = id;
                    marker.inFront = !!inFront;

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return marker;
                };
                this.removeMarker = function (markerId) {
                    var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                    if (!marker) return;

                    var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                    if (marker) {
                        delete markers[markerId];
                        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
                    }
                };
                this.getMarkers = function (inFront) {
                    return inFront ? this.$frontMarkers : this.$backMarkers;
                };

                this.highlight = function (re) {
                    if (!this.$searchHighlight) {
                        var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                        this.$searchHighlight = this.addDynamicMarker(highlight);
                    }
                    this.$searchHighlight.setRegexp(re);
                };
                this.highlightLines = function (startRow, endRow, clazz, inFront) {
                    if (typeof endRow != "number") {
                        clazz = endRow;
                        endRow = startRow;
                    }
                    if (!clazz) clazz = "ace_step";

                    var range = new Range(startRow, 0, endRow, Infinity);
                    range.id = this.addMarker(range, clazz, "fullLine", inFront);
                    return range;
                };
                this.setAnnotations = function (annotations) {
                    this.$annotations = annotations;
                    this._signal("changeAnnotation", {});
                };
                this.getAnnotations = function () {
                    return this.$annotations || [];
                };
                this.clearAnnotations = function () {
                    this.setAnnotations([]);
                };
                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r?\n)/m);
                    if (match) {
                        this.$autoNewLine = match[1];
                    } else {
                        this.$autoNewLine = "\n";
                    }
                };
                this.getWordRange = function (row, column) {
                    var line = this.getLine(row);

                    var inToken = false;
                    if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);

                    if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);

                    if (inToken) var re = this.tokenRe;else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;else var re = this.nonTokenRe;

                    var start = column;
                    if (start > 0) {
                        do {
                            start--;
                        } while (start >= 0 && line.charAt(start).match(re));
                        start++;
                    }

                    var end = column;
                    while (end < line.length && line.charAt(end).match(re)) {
                        end++;
                    }

                    return new Range(row, start, row, end);
                };
                this.getAWordRange = function (row, column) {
                    var wordRange = this.getWordRange(row, column);
                    var line = this.getLine(wordRange.end.row);

                    while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                        wordRange.end.column += 1;
                    }
                    return wordRange;
                };
                this.setNewLineMode = function (newLineMode) {
                    this.doc.setNewLineMode(newLineMode);
                };
                this.getNewLineMode = function () {
                    return this.doc.getNewLineMode();
                };
                this.setUseWorker = function (useWorker) {
                    this.setOption("useWorker", useWorker);
                };
                this.getUseWorker = function () {
                    return this.$useWorker;
                };
                this.onReloadTokenizer = function (e) {
                    var rows = e.data;
                    this.bgTokenizer.start(rows.first);
                    this._signal("tokenizerUpdate", e);
                };

                this.$modes = {};
                this.$mode = null;
                this.$modeId = null;
                this.setMode = function (mode, cb) {
                    if (mode && typeof mode === "object") {
                        if (mode.getTokenizer) return this.$onChangeMode(mode);
                        var options = mode;
                        var path = options.path;
                    } else {
                        path = mode || "ace/mode/text";
                    }
                    if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();

                    if (this.$modes[path] && !options) {
                        this.$onChangeMode(this.$modes[path]);
                        cb && cb();
                        return;
                    }
                    this.$modeId = path;
                    config.loadModule(["mode", path], function (m) {
                        if (this.$modeId !== path) return cb && cb();
                        if (this.$modes[path] && !options) {
                            this.$onChangeMode(this.$modes[path]);
                        } else if (m && m.Mode) {
                            m = new m.Mode(options);
                            if (!options) {
                                this.$modes[path] = m;
                                m.$id = path;
                            }
                            this.$onChangeMode(m);
                        }
                        cb && cb();
                    }.bind(this));
                    if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
                };

                this.$onChangeMode = function (mode, $isPlaceholder) {
                    if (!$isPlaceholder) this.$modeId = mode.$id;
                    if (this.$mode === mode) return;

                    this.$mode = mode;

                    this.$stopWorker();

                    if (this.$useWorker) this.$startWorker();

                    var tokenizer = mode.getTokenizer();

                    if (tokenizer.addEventListener !== undefined) {
                        var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                        tokenizer.addEventListener("update", onReloadTokenizer);
                    }

                    if (!this.bgTokenizer) {
                        this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                        var _self = this;
                        this.bgTokenizer.addEventListener("update", function (e) {
                            _self._signal("tokenizerUpdate", e);
                        });
                    } else {
                        this.bgTokenizer.setTokenizer(tokenizer);
                    }

                    this.bgTokenizer.setDocument(this.getDocument());

                    this.tokenRe = mode.tokenRe;
                    this.nonTokenRe = mode.nonTokenRe;

                    if (!$isPlaceholder) {
                        if (mode.attachToSession) mode.attachToSession(this);
                        this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                        this.$setFolding(mode.foldingRules);
                        this.bgTokenizer.start(0);
                        this._emit("changeMode");
                    }
                };

                this.$stopWorker = function () {
                    if (this.$worker) {
                        this.$worker.terminate();
                        this.$worker = null;
                    }
                };

                this.$startWorker = function () {
                    try {
                        this.$worker = this.$mode.createWorker(this);
                    } catch (e) {
                        config.warn("Could not load worker", e);
                        this.$worker = null;
                    }
                };
                this.getMode = function () {
                    return this.$mode;
                };

                this.$scrollTop = 0;
                this.setScrollTop = function (scrollTop) {
                    if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;

                    this.$scrollTop = scrollTop;
                    this._signal("changeScrollTop", scrollTop);
                };
                this.getScrollTop = function () {
                    return this.$scrollTop;
                };

                this.$scrollLeft = 0;
                this.setScrollLeft = function (scrollLeft) {
                    if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;

                    this.$scrollLeft = scrollLeft;
                    this._signal("changeScrollLeft", scrollLeft);
                };
                this.getScrollLeft = function () {
                    return this.$scrollLeft;
                };
                this.getScreenWidth = function () {
                    this.$computeWidth();
                    if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                    return this.screenWidth;
                };

                this.getLineWidgetMaxWidth = function () {
                    if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                    var width = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.screenWidth > width) width = w.screenWidth;
                    });
                    return this.lineWidgetWidth = width;
                };

                this.$computeWidth = function (force) {
                    if (this.$modified || force) {
                        this.$modified = false;

                        if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;

                        var lines = this.doc.getAllLines();
                        var cache = this.$rowLengthCache;
                        var longestScreenLine = 0;
                        var foldIndex = 0;
                        var foldLine = this.$foldData[foldIndex];
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        var len = lines.length;

                        for (var i = 0; i < len; i++) {
                            if (i > foldStart) {
                                i = foldLine.end.row + 1;
                                if (i >= len) break;
                                foldLine = this.$foldData[foldIndex++];
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }

                            if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];

                            if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                        }
                        this.screenWidth = longestScreenLine;
                    }
                };
                this.getLine = function (row) {
                    return this.doc.getLine(row);
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.doc.getLines(firstRow, lastRow);
                };
                this.getLength = function () {
                    return this.doc.getLength();
                };
                this.getTextRange = function (range) {
                    return this.doc.getTextRange(range || this.selection.getRange());
                };
                this.insert = function (position, text) {
                    return this.doc.insert(position, text);
                };
                this.remove = function (range) {
                    return this.doc.remove(range);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    return this.doc.removeFullLines(firstRow, lastRow);
                };
                this.undoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = deltas.length - 1; i != -1; i--) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.revertDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                        } else {
                            delta.deltas.forEach(function (foldDelta) {
                                this.addFolds(foldDelta.folds);
                            }, this);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.redoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = 0; i < deltas.length; i++) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.applyDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.setUndoSelect = function (enable) {
                    this.$undoSelect = enable;
                };

                this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
                    function isInsert(delta) {
                        return isUndo ? delta.action !== "insert" : delta.action === "insert";
                    }

                    var delta = deltas[0];
                    var range, point;
                    var lastDeltaIsInsert = false;
                    if (isInsert(delta)) {
                        range = Range.fromPoints(delta.start, delta.end);
                        lastDeltaIsInsert = true;
                    } else {
                        range = Range.fromPoints(delta.start, delta.start);
                        lastDeltaIsInsert = false;
                    }

                    for (var i = 1; i < deltas.length; i++) {
                        delta = deltas[i];
                        if (isInsert(delta)) {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range.setStart(point);
                            }
                            point = delta.end;
                            if (range.compare(point.row, point.column) == 1) {
                                range.setEnd(point);
                            }
                            lastDeltaIsInsert = true;
                        } else {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range = Range.fromPoints(delta.start, delta.start);
                            }
                            lastDeltaIsInsert = false;
                        }
                    }
                    if (lastUndoRange != null) {
                        if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                            lastUndoRange.start.column += range.end.column - range.start.column;
                            lastUndoRange.end.column += range.end.column - range.start.column;
                        }

                        var cmp = lastUndoRange.compareRange(range);
                        if (cmp == 1) {
                            range.setStart(lastUndoRange.start);
                        } else if (cmp == -1) {
                            range.setEnd(lastUndoRange.end);
                        }
                    }

                    return range;
                };
                this.replace = function (range, text) {
                    return this.doc.replace(range, text);
                };
                this.moveText = function (fromRange, toPosition, copy) {
                    var text = this.getTextRange(fromRange);
                    var folds = this.getFoldsInRange(fromRange);

                    var toRange = Range.fromPoints(toPosition, toPosition);
                    if (!copy) {
                        this.remove(fromRange);
                        var rowDiff = fromRange.start.row - fromRange.end.row;
                        var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                        if (collDiff) {
                            if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
                            if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
                        }
                        if (rowDiff && toRange.start.row >= fromRange.end.row) {
                            toRange.start.row += rowDiff;
                            toRange.end.row += rowDiff;
                        }
                    }

                    toRange.end = this.insert(toRange.start, text);
                    if (folds.length) {
                        var oldStart = fromRange.start;
                        var newStart = toRange.start;
                        var rowDiff = newStart.row - oldStart.row;
                        var collDiff = newStart.column - oldStart.column;
                        this.addFolds(folds.map(function (x) {
                            x = x.clone();
                            if (x.start.row == oldStart.row) x.start.column += collDiff;
                            if (x.end.row == oldStart.row) x.end.column += collDiff;
                            x.start.row += rowDiff;
                            x.end.row += rowDiff;
                            return x;
                        }));
                    }

                    return toRange;
                };
                this.indentRows = function (startRow, endRow, indentString) {
                    indentString = indentString.replace(/\t/g, this.getTabString());
                    for (var row = startRow; row <= endRow; row++) this.doc.insertInLine({ row: row, column: 0 }, indentString);
                };
                this.outdentRows = function (range) {
                    var rowRange = range.collapseRows();
                    var deleteRange = new Range(0, 0, 0, 0);
                    var size = this.getTabSize();

                    for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                        var line = this.getLine(i);

                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        for (var j = 0; j < size; ++j) if (line.charAt(j) != ' ') break;
                        if (j < size && line.charAt(j) == '\t') {
                            deleteRange.start.column = j;
                            deleteRange.end.column = j + 1;
                        } else {
                            deleteRange.start.column = 0;
                            deleteRange.end.column = j;
                        }
                        this.remove(deleteRange);
                    }
                };

                this.$moveLines = function (firstRow, lastRow, dir) {
                    firstRow = this.getRowFoldStart(firstRow);
                    lastRow = this.getRowFoldEnd(lastRow);
                    if (dir < 0) {
                        var row = this.getRowFoldStart(firstRow + dir);
                        if (row < 0) return 0;
                        var diff = row - firstRow;
                    } else if (dir > 0) {
                        var row = this.getRowFoldEnd(lastRow + dir);
                        if (row > this.doc.getLength() - 1) return 0;
                        var diff = row - lastRow;
                    } else {
                        firstRow = this.$clipRowToDocument(firstRow);
                        lastRow = this.$clipRowToDocument(lastRow);
                        var diff = lastRow - firstRow + 1;
                    }

                    var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                    var folds = this.getFoldsInRange(range).map(function (x) {
                        x = x.clone();
                        x.start.row += diff;
                        x.end.row += diff;
                        return x;
                    });

                    var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
                    this.doc.insertFullLines(firstRow + diff, lines);
                    folds.length && this.addFolds(folds);
                    return diff;
                };
                this.moveLinesUp = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, -1);
                };
                this.moveLinesDown = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 1);
                };
                this.duplicateLines = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 0);
                };

                this.$clipRowToDocument = function (row) {
                    return Math.max(0, Math.min(row, this.doc.getLength() - 1));
                };

                this.$clipColumnToRow = function (row, column) {
                    if (column < 0) return 0;
                    return Math.min(this.doc.getLine(row).length, column);
                };

                this.$clipPositionToDocument = function (row, column) {
                    column = Math.max(0, column);

                    if (row < 0) {
                        row = 0;
                        column = 0;
                    } else {
                        var len = this.doc.getLength();
                        if (row >= len) {
                            row = len - 1;
                            column = this.doc.getLine(len - 1).length;
                        } else {
                            column = Math.min(this.doc.getLine(row).length, column);
                        }
                    }

                    return {
                        row: row,
                        column: column
                    };
                };

                this.$clipRangeToDocument = function (range) {
                    if (range.start.row < 0) {
                        range.start.row = 0;
                        range.start.column = 0;
                    } else {
                        range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
                    }

                    var len = this.doc.getLength() - 1;
                    if (range.end.row > len) {
                        range.end.row = len;
                        range.end.column = this.doc.getLine(len).length;
                    } else {
                        range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
                    }
                    return range;
                };
                this.$wrapLimit = 80;
                this.$useWrapMode = false;
                this.$wrapLimitRange = {
                    min: null,
                    max: null
                };
                this.setUseWrapMode = function (useWrapMode) {
                    if (useWrapMode != this.$useWrapMode) {
                        this.$useWrapMode = useWrapMode;
                        this.$modified = true;
                        this.$resetRowCache(0);
                        if (useWrapMode) {
                            var len = this.getLength();
                            this.$wrapData = Array(len);
                            this.$updateWrapData(0, len - 1);
                        }

                        this._signal("changeWrapMode");
                    }
                };
                this.getUseWrapMode = function () {
                    return this.$useWrapMode;
                };
                this.setWrapLimitRange = function (min, max) {
                    if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                        this.$wrapLimitRange = { min: min, max: max };
                        this.$modified = true;
                        if (this.$useWrapMode) this._signal("changeWrapMode");
                    }
                };
                this.adjustWrapLimit = function (desiredLimit, $printMargin) {
                    var limits = this.$wrapLimitRange;
                    if (limits.max < 0) limits = { min: $printMargin, max: $printMargin };
                    var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                    if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                        this.$wrapLimit = wrapLimit;
                        this.$modified = true;
                        if (this.$useWrapMode) {
                            this.$updateWrapData(0, this.getLength() - 1);
                            this.$resetRowCache(0);
                            this._signal("changeWrapLimit");
                        }
                        return true;
                    }
                    return false;
                };

                this.$constrainWrapLimit = function (wrapLimit, min, max) {
                    if (min) wrapLimit = Math.max(min, wrapLimit);

                    if (max) wrapLimit = Math.min(max, wrapLimit);

                    return wrapLimit;
                };
                this.getWrapLimit = function () {
                    return this.$wrapLimit;
                };
                this.setWrapLimit = function (limit) {
                    this.setWrapLimitRange(limit, limit);
                };
                this.getWrapLimitRange = function () {
                    return {
                        min: this.$wrapLimitRange.min,
                        max: this.$wrapLimitRange.max
                    };
                };

                this.$updateInternalDataOnChange = function (delta) {
                    var useWrapMode = this.$useWrapMode;
                    var action = delta.action;
                    var start = delta.start;
                    var end = delta.end;
                    var firstRow = start.row;
                    var lastRow = end.row;
                    var len = lastRow - firstRow;
                    var removedFolds = null;

                    this.$updating = true;
                    if (len != 0) {
                        if (action === "remove") {
                            this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                            var foldLines = this.$foldData;
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            var foldLine = this.getFoldLine(end.row);
                            var idx = 0;
                            if (foldLine) {
                                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                foldLine.shiftRow(-len);

                                var foldLineBefore = this.getFoldLine(firstRow);
                                if (foldLineBefore && foldLineBefore !== foldLine) {
                                    foldLineBefore.merge(foldLine);
                                    foldLine = foldLineBefore;
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= end.row) {
                                    foldLine.shiftRow(-len);
                                }
                            }

                            lastRow = firstRow;
                        } else {
                            var args = Array(len);
                            args.unshift(firstRow, 0);
                            var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                            arr.splice.apply(arr, args);
                            var foldLines = this.$foldData;
                            var foldLine = this.getFoldLine(firstRow);
                            var idx = 0;
                            if (foldLine) {
                                var cmp = foldLine.range.compareInside(start.row, start.column);
                                if (cmp == 0) {
                                    foldLine = foldLine.split(start.row, start.column);
                                    if (foldLine) {
                                        foldLine.shiftRow(len);
                                        foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                    }
                                } else if (cmp == -1) {
                                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                    foldLine.shiftRow(len);
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= firstRow) {
                                    foldLine.shiftRow(len);
                                }
                            }
                        }
                    } else {
                        len = Math.abs(delta.start.column - delta.end.column);
                        if (action === "remove") {
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            len = -len;
                        }
                        var foldLine = this.getFoldLine(firstRow);
                        if (foldLine) {
                            foldLine.addRemoveChars(firstRow, start.column, len);
                        }
                    }

                    if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                        console.error("doc.getLength() and $wrapData.length have to be the same!");
                    }
                    this.$updating = false;

                    if (useWrapMode) this.$updateWrapData(firstRow, lastRow);else this.$updateRowLengthCache(firstRow, lastRow);

                    return removedFolds;
                };

                this.$updateRowLengthCache = function (firstRow, lastRow, b) {
                    this.$rowLengthCache[firstRow] = null;
                    this.$rowLengthCache[lastRow] = null;
                };

                this.$updateWrapData = function (firstRow, lastRow) {
                    var lines = this.doc.getAllLines();
                    var tabSize = this.getTabSize();
                    var wrapData = this.$wrapData;
                    var wrapLimit = this.$wrapLimit;
                    var tokens;
                    var foldLine;

                    var row = firstRow;
                    lastRow = Math.min(lastRow, lines.length - 1);
                    while (row <= lastRow) {
                        foldLine = this.getFoldLine(row, foldLine);
                        if (!foldLine) {
                            tokens = this.$getDisplayTokens(lines[row]);
                            wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row++;
                        } else {
                            tokens = [];
                            foldLine.walk(function (placeholder, row, column, lastColumn) {
                                var walkTokens;
                                if (placeholder != null) {
                                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                                    walkTokens[0] = PLACEHOLDER_START;
                                    for (var i = 1; i < walkTokens.length; i++) {
                                        walkTokens[i] = PLACEHOLDER_BODY;
                                    }
                                } else {
                                    walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                                }
                                tokens = tokens.concat(walkTokens);
                            }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);

                            wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row = foldLine.end.row + 1;
                        }
                    }
                };
                var CHAR = 1,
                    CHAR_EXT = 2,
                    PLACEHOLDER_START = 3,
                    PLACEHOLDER_BODY = 4,
                    PUNCTUATION = 9,
                    SPACE = 10,
                    TAB = 11,
                    TAB_SPACE = 12;

                this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
                    if (tokens.length == 0) {
                        return [];
                    }

                    var splits = [];
                    var displayLength = tokens.length;
                    var lastSplit = 0,
                        lastDocSplit = 0;

                    var isCode = this.$wrapAsCode;

                    var indentedSoftWrap = this.$indentedSoftWrap;
                    var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

                    function getWrapIndent() {
                        var indentation = 0;
                        if (maxIndent === 0) return indentation;
                        if (indentedSoftWrap) {
                            for (var i = 0; i < tokens.length; i++) {
                                var token = tokens[i];
                                if (token == SPACE) indentation += 1;else if (token == TAB) indentation += tabSize;else if (token == TAB_SPACE) continue;else break;
                            }
                        }
                        if (isCode && indentedSoftWrap !== false) indentation += tabSize;
                        return Math.min(indentation, maxIndent);
                    }
                    function addSplit(screenPos) {
                        var displayed = tokens.slice(lastSplit, screenPos);
                        var len = displayed.length;
                        displayed.join("").replace(/12/g, function () {
                            len -= 1;
                        }).replace(/2/g, function () {
                            len -= 1;
                        });

                        if (!splits.length) {
                            indent = getWrapIndent();
                            splits.indent = indent;
                        }
                        lastDocSplit += len;
                        splits.push(lastDocSplit);
                        lastSplit = screenPos;
                    }
                    var indent = 0;
                    while (displayLength - lastSplit > wrapLimit - indent) {
                        var split = lastSplit + wrapLimit - indent;
                        if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                            addSplit(split);
                            continue;
                        }
                        if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                            for (split; split != lastSplit - 1; split--) {
                                if (tokens[split] == PLACEHOLDER_START) {
                                    break;
                                }
                            }
                            if (split > lastSplit) {
                                addSplit(split);
                                continue;
                            }
                            split = lastSplit + wrapLimit;
                            for (split; split < tokens.length; split++) {
                                if (tokens[split] != PLACEHOLDER_BODY) {
                                    break;
                                }
                            }
                            if (split == tokens.length) {
                                break; // Breaks the while-loop.
                            }
                            addSplit(split);
                            continue;
                        }
                        var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                        while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                            split--;
                        }
                        if (isCode) {
                            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                                split--;
                            }
                            while (split > minSplit && tokens[split] == PUNCTUATION) {
                                split--;
                            }
                        } else {
                            while (split > minSplit && tokens[split] < SPACE) {
                                split--;
                            }
                        }
                        if (split > minSplit) {
                            addSplit(++split);
                            continue;
                        }
                        split = lastSplit + wrapLimit;
                        if (tokens[split] == CHAR_EXT) split--;
                        addSplit(split - indent);
                    }
                    return splits;
                };
                this.$getDisplayTokens = function (str, offset) {
                    var arr = [];
                    var tabSize;
                    offset = offset || 0;

                    for (var i = 0; i < str.length; i++) {
                        var c = str.charCodeAt(i);
                        if (c == 9) {
                            tabSize = this.getScreenTabSize(arr.length + offset);
                            arr.push(TAB);
                            for (var n = 1; n < tabSize; n++) {
                                arr.push(TAB_SPACE);
                            }
                        } else if (c == 32) {
                            arr.push(SPACE);
                        } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                            arr.push(PUNCTUATION);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            arr.push(CHAR, CHAR_EXT);
                        } else {
                            arr.push(CHAR);
                        }
                    }
                    return arr;
                };
                this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                    if (maxScreenColumn == 0) return [0, 0];
                    if (maxScreenColumn == null) maxScreenColumn = Infinity;
                    screenColumn = screenColumn || 0;

                    var c, column;
                    for (column = 0; column < str.length; column++) {
                        c = str.charCodeAt(column);
                        if (c == 9) {
                            screenColumn += this.getScreenTabSize(screenColumn);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            screenColumn += 2;
                        } else {
                            screenColumn += 1;
                        }
                        if (screenColumn > maxScreenColumn) {
                            break;
                        }
                    }

                    return [screenColumn, column];
                };

                this.lineWidgets = null;
                this.getRowLength = function (row) {
                    if (this.lineWidgets) var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };
                this.getRowLineCount = function (row) {
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1;
                    } else {
                        return this.$wrapData[row].length + 1;
                    }
                };

                this.getRowWrapIndent = function (screenRow) {
                    if (this.$useWrapMode) {
                        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                        var splits = this.$wrapData[pos.row];
                        return splits.length && splits[0] < pos.column ? splits.indent : 0;
                    } else {
                        return 0;
                    }
                };
                this.getScreenLastRowColumn = function (screenRow) {
                    var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                    return this.documentToScreenColumn(pos.row, pos.column);
                };
                this.getDocumentLastRowColumn = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.getScreenLastRowColumn(screenRow);
                };
                this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                };
                this.getRowSplitData = function (row) {
                    if (!this.$useWrapMode) {
                        return undefined;
                    } else {
                        return this.$wrapData[row];
                    }
                };
                this.getScreenTabSize = function (screenColumn) {
                    return this.$tabSize - screenColumn % this.$tabSize;
                };

                this.screenToDocumentRow = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).row;
                };

                this.screenToDocumentColumn = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).column;
                };
                this.screenToDocumentPosition = function (screenRow, screenColumn) {
                    if (screenRow < 0) return { row: 0, column: 0 };

                    var line;
                    var docRow = 0;
                    var docColumn = 0;
                    var column;
                    var row = 0;
                    var rowLength = 0;

                    var rowCache = this.$screenRowCache;
                    var i = this.$getRowCacheIndex(rowCache, screenRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var docRow = this.$docRowCache[i];
                        var doCache = screenRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var maxRow = this.getLength() - 1;
                    var foldLine = this.getNextFoldLine(docRow);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row <= screenRow) {
                        rowLength = this.getRowLength(docRow);
                        if (row + rowLength > screenRow || docRow >= maxRow) {
                            break;
                        } else {
                            row += rowLength;
                            docRow++;
                            if (docRow > foldStart) {
                                docRow = foldLine.end.row + 1;
                                foldLine = this.getNextFoldLine(docRow, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                        }

                        if (doCache) {
                            this.$docRowCache.push(docRow);
                            this.$screenRowCache.push(row);
                        }
                    }

                    if (foldLine && foldLine.start.row <= docRow) {
                        line = this.getFoldDisplayLine(foldLine);
                        docRow = foldLine.start.row;
                    } else if (row + rowLength <= screenRow || docRow > maxRow) {
                        return {
                            row: maxRow,
                            column: this.getLine(maxRow).length
                        };
                    } else {
                        line = this.getLine(docRow);
                        foldLine = null;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var splits = this.$wrapData[docRow];
                        if (splits) {
                            var splitIndex = Math.floor(screenRow - row);
                            column = splits[splitIndex];
                            if (splitIndex > 0 && splits.length) {
                                wrapIndent = splits.indent;
                                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                line = line.substring(docColumn);
                            }
                        }
                    }

                    docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
                    if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;

                    if (foldLine) return foldLine.idxToPosition(docColumn);

                    return { row: docRow, column: docColumn };
                };
                this.documentToScreenPosition = function (docRow, docColumn) {
                    if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(docRow.row, docRow.column);else pos = this.$clipPositionToDocument(docRow, docColumn);

                    docRow = pos.row;
                    docColumn = pos.column;

                    var screenRow = 0;
                    var foldStartRow = null;
                    var fold = null;
                    fold = this.getFoldAt(docRow, docColumn, 1);
                    if (fold) {
                        docRow = fold.start.row;
                        docColumn = fold.start.column;
                    }

                    var rowEnd,
                        row = 0;

                    var rowCache = this.$docRowCache;
                    var i = this.$getRowCacheIndex(rowCache, docRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var screenRow = this.$screenRowCache[i];
                        var doCache = docRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var foldLine = this.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row < docRow) {
                        if (row >= foldStart) {
                            rowEnd = foldLine.end.row + 1;
                            if (rowEnd > docRow) break;
                            foldLine = this.getNextFoldLine(rowEnd, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        } else {
                            rowEnd = row + 1;
                        }

                        screenRow += this.getRowLength(row);
                        row = rowEnd;

                        if (doCache) {
                            this.$docRowCache.push(row);
                            this.$screenRowCache.push(screenRow);
                        }
                    }
                    var textLine = "";
                    if (foldLine && row >= foldStart) {
                        textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                        foldStartRow = foldLine.start.row;
                    } else {
                        textLine = this.getLine(docRow).substring(0, docColumn);
                        foldStartRow = docRow;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var wrapRow = this.$wrapData[foldStartRow];
                        if (wrapRow) {
                            var screenRowOffset = 0;
                            while (textLine.length >= wrapRow[screenRowOffset]) {
                                screenRow++;
                                screenRowOffset++;
                            }
                            textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                            wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                        }
                    }

                    return {
                        row: screenRow,
                        column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
                    };
                };
                this.documentToScreenColumn = function (row, docColumn) {
                    return this.documentToScreenPosition(row, docColumn).column;
                };
                this.documentToScreenRow = function (docRow, docColumn) {
                    return this.documentToScreenPosition(docRow, docColumn).row;
                };
                this.getScreenLength = function () {
                    var screenRows = 0;
                    var fold = null;
                    if (!this.$useWrapMode) {
                        screenRows = this.getLength();
                        var foldData = this.$foldData;
                        for (var i = 0; i < foldData.length; i++) {
                            fold = foldData[i];
                            screenRows -= fold.end.row - fold.start.row;
                        }
                    } else {
                        var lastRow = this.$wrapData.length;
                        var row = 0,
                            i = 0;
                        var fold = this.$foldData[i++];
                        var foldStart = fold ? fold.start.row : Infinity;

                        while (row < lastRow) {
                            var splits = this.$wrapData[row];
                            screenRows += splits ? splits.length + 1 : 1;
                            row++;
                            if (row > foldStart) {
                                row = fold.end.row + 1;
                                fold = this.$foldData[i++];
                                foldStart = fold ? fold.start.row : Infinity;
                            }
                        }
                    }
                    if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();

                    return screenRows;
                };
                this.$setFontMetrics = function (fm) {
                    if (!this.$enableVarChar) return;
                    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                        if (maxScreenColumn === 0) return [0, 0];
                        if (!maxScreenColumn) maxScreenColumn = Infinity;
                        screenColumn = screenColumn || 0;

                        var c, column;
                        for (column = 0; column < str.length; column++) {
                            c = str.charAt(column);
                            if (c === "\t") {
                                screenColumn += this.getScreenTabSize(screenColumn);
                            } else {
                                screenColumn += fm.getCharacterWidth(c);
                            }
                            if (screenColumn > maxScreenColumn) {
                                break;
                            }
                        }

                        return [screenColumn, column];
                    };
                };

                this.destroy = function () {
                    if (this.bgTokenizer) {
                        this.bgTokenizer.setDocument(null);
                        this.bgTokenizer = null;
                    }
                    this.$stopWorker();
                };
                function isFullWidth(c) {
                    if (c < 0x1100) return false;
                    return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
                }
            }).call(EditSession.prototype);

            require("./edit_session/folding").Folding.call(EditSession.prototype);
            require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);

            config.defineOptions(EditSession.prototype, "session", {
                wrap: {
                    set: function (value) {
                        if (!value || value == "off") value = false;else if (value == "free") value = true;else if (value == "printMargin") value = -1;else if (typeof value == "string") value = parseInt(value, 10) || false;

                        if (this.$wrap == value) return;
                        this.$wrap = value;
                        if (!value) {
                            this.setUseWrapMode(false);
                        } else {
                            var col = typeof value == "number" ? value : null;
                            this.setWrapLimitRange(col, col);
                            this.setUseWrapMode(true);
                        }
                    },
                    get: function () {
                        if (this.getUseWrapMode()) {
                            if (this.$wrap == -1) return "printMargin";
                            if (!this.getWrapLimitRange().min) return "free";
                            return this.$wrap;
                        }
                        return "off";
                    },
                    handlesSet: true
                },
                wrapMethod: {
                    set: function (val) {
                        val = val == "auto" ? this.$mode.type != "text" : val != "text";
                        if (val != this.$wrapAsCode) {
                            this.$wrapAsCode = val;
                            if (this.$useWrapMode) {
                                this.$modified = true;
                                this.$resetRowCache(0);
                                this.$updateWrapData(0, this.getLength() - 1);
                            }
                        }
                    },
                    initialValue: "auto"
                },
                indentedSoftWrap: { initialValue: true },
                firstLineNumber: {
                    set: function () {
                        this._signal("changeBreakpoint");
                    },
                    initialValue: 1
                },
                useWorker: {
                    set: function (useWorker) {
                        this.$useWorker = useWorker;

                        this.$stopWorker();
                        if (useWorker) this.$startWorker();
                    },
                    initialValue: true
                },
                useSoftTabs: { initialValue: true },
                tabSize: {
                    set: function (tabSize) {
                        if (isNaN(tabSize) || this.$tabSize === tabSize) return;

                        this.$modified = true;
                        this.$rowLengthCache = [];
                        this.$tabSize = tabSize;
                        this._signal("changeTabSize");
                    },
                    initialValue: 4,
                    handlesSet: true
                },
                overwrite: {
                    set: function (val) {
                        this._signal("changeOverwrite");
                    },
                    initialValue: false
                },
                newLineMode: {
                    set: function (val) {
                        this.doc.setNewLineMode(val);
                    },
                    get: function () {
                        return this.doc.getNewLineMode();
                    },
                    handlesSet: true
                },
                mode: {
                    set: function (val) {
                        this.setMode(val);
                    },
                    get: function () {
                        return this.$modeId;
                    }
                }
            });

            exports.EditSession = EditSession;
        });

        ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var Search = function () {
                this.$options = {};
            };

            (function () {
                this.set = function (options) {
                    oop.mixin(this.$options, options);
                    return this;
                };
                this.getOptions = function () {
                    return lang.copyObject(this.$options);
                };
                this.setOptions = function (options) {
                    this.$options = options;
                };
                this.find = function (session) {
                    var options = this.$options;
                    var iterator = this.$matchIterator(session, options);
                    if (!iterator) return false;

                    var firstRange = null;
                    iterator.forEach(function (range, row, offset) {
                        if (!range.start) {
                            var column = range.offset + (offset || 0);
                            firstRange = new Range(row, column, row, column + range.length);
                            if (!range.length && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                                firstRange = null;
                                return false;
                            }
                        } else firstRange = range;
                        return true;
                    });

                    return firstRange;
                };
                this.findAll = function (session) {
                    var options = this.$options;
                    if (!options.needle) return [];
                    this.$assembleRegExp(options);

                    var range = options.range;
                    var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();

                    var ranges = [];
                    var re = options.re;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var maxRow = lines.length - len;
                        var prevRange;
                        outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                            for (var j = 0; j < len; j++) if (lines[row + j].search(re[j]) == -1) continue outer;

                            var startLine = lines[row];
                            var line = lines[row + len - 1];
                            var startIndex = startLine.length - startLine.match(re[0])[0].length;
                            var endIndex = line.match(re[len - 1])[0].length;

                            if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                                continue;
                            }
                            ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                            if (len > 2) row = row + len - 2;
                        }
                    } else {
                        for (var i = 0; i < lines.length; i++) {
                            var matches = lang.getMatchOffsets(lines[i], re);
                            for (var j = 0; j < matches.length; j++) {
                                var match = matches[j];
                                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                            }
                        }
                    }

                    if (range) {
                        var startColumn = range.start.column;
                        var endColumn = range.start.column;
                        var i = 0,
                            j = ranges.length - 1;
                        while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row) i++;

                        while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row) j--;

                        ranges = ranges.slice(i, j + 1);
                        for (i = 0, j = ranges.length; i < j; i++) {
                            ranges[i].start.row += range.start.row;
                            ranges[i].end.row += range.start.row;
                        }
                    }

                    return ranges;
                };
                this.replace = function (input, replacement) {
                    var options = this.$options;

                    var re = this.$assembleRegExp(options);
                    if (options.$isMultiLine) return replacement;

                    if (!re) return;

                    var match = re.exec(input);
                    if (!match || match[0].length != input.length) return null;

                    replacement = input.replace(re, replacement);
                    if (options.preserveCase) {
                        replacement = replacement.split("");
                        for (var i = Math.min(input.length, input.length); i--;) {
                            var ch = input[i];
                            if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();else replacement[i] = replacement[i].toLowerCase();
                        }
                        replacement = replacement.join("");
                    }

                    return replacement;
                };

                this.$matchIterator = function (session, options) {
                    var re = this.$assembleRegExp(options);
                    if (!re) return false;

                    var callback;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var matchIterator = function (line, row, offset) {
                            var startIndex = line.search(re[0]);
                            if (startIndex == -1) return;
                            for (var i = 1; i < len; i++) {
                                line = session.getLine(row + i);
                                if (line.search(re[i]) == -1) return;
                            }

                            var endIndex = line.match(re[len - 1])[0].length;

                            var range = new Range(row, startIndex, row + len - 1, endIndex);
                            if (re.offset == 1) {
                                range.start.row--;
                                range.start.column = Number.MAX_VALUE;
                            } else if (offset) range.start.column += offset;

                            if (callback(range)) return true;
                        };
                    } else if (options.backwards) {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = matches.length - 1; i >= 0; i--) if (callback(matches[i], row, startIndex)) return true;
                        };
                    } else {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = 0; i < matches.length; i++) if (callback(matches[i], row, startIndex)) return true;
                        };
                    }

                    var lineIterator = this.$lineIterator(session, options);

                    return {
                        forEach: function (_callback) {
                            callback = _callback;
                            lineIterator.forEach(matchIterator);
                        }
                    };
                };

                this.$assembleRegExp = function (options, $disableFakeMultiline) {
                    if (options.needle instanceof RegExp) return options.re = options.needle;

                    var needle = options.needle;

                    if (!options.needle) return options.re = false;

                    if (!options.regExp) needle = lang.escapeRegExp(needle);

                    if (options.wholeWord) needle = "\\b" + needle + "\\b";

                    var modifier = options.caseSensitive ? "gm" : "gmi";

                    options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
                    if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);

                    try {
                        var re = new RegExp(needle, modifier);
                    } catch (e) {
                        re = false;
                    }
                    return options.re = re;
                };

                this.$assembleMultilineRegExp = function (needle, modifier) {
                    var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
                    var re = [];
                    for (var i = 0; i < parts.length; i++) try {
                        re.push(new RegExp(parts[i], modifier));
                    } catch (e) {
                        return false;
                    }
                    if (parts[0] == "") {
                        re.shift();
                        re.offset = 1;
                    } else {
                        re.offset = 0;
                    }
                    return re;
                };

                this.$lineIterator = function (session, options) {
                    var backwards = options.backwards == true;
                    var skipCurrent = options.skipCurrent != false;

                    var range = options.range;
                    var start = options.start;
                    if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

                    if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];

                    var firstRow = range ? range.start.row : 0;
                    var lastRow = range ? range.end.row : session.getLength() - 1;

                    var forEach = backwards ? function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substring(0, start.column);
                        if (callback(line, row)) return;

                        for (row--; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = lastRow, firstRow = start.row; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;
                    } : function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substr(start.column);
                        if (callback(line, row, start.column)) return;

                        for (row = row + 1; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = firstRow, lastRow = start.row; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;
                    };

                    return { forEach: forEach };
                };
            }).call(Search.prototype);

            exports.Search = Search;
        });

        ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var useragent = require("../lib/useragent");
            var KEY_MODS = keyUtil.KEY_MODS;

            function HashHandler(config, platform) {
                this.platform = platform || (useragent.isMac ? "mac" : "win");
                this.commands = {};
                this.commandKeyBinding = {};
                this.addCommands(config);
                this.$singleCommand = true;
            }

            function MultiHashHandler(config, platform) {
                HashHandler.call(this, config, platform);
                this.$singleCommand = false;
            }

            MultiHashHandler.prototype = HashHandler.prototype;

            (function () {

                this.addCommand = function (command) {
                    if (this.commands[command.name]) this.removeCommand(command);

                    this.commands[command.name] = command;

                    if (command.bindKey) this._buildKeyHash(command);
                };

                this.removeCommand = function (command, keepCommand) {
                    var name = command && (typeof command === 'string' ? command : command.name);
                    command = this.commands[name];
                    if (!keepCommand) delete this.commands[name];
                    var ckb = this.commandKeyBinding;
                    for (var keyId in ckb) {
                        var cmdGroup = ckb[keyId];
                        if (cmdGroup == command) {
                            delete ckb[keyId];
                        } else if (Array.isArray(cmdGroup)) {
                            var i = cmdGroup.indexOf(command);
                            if (i != -1) {
                                cmdGroup.splice(i, 1);
                                if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
                            }
                        }
                    }
                };

                this.bindKey = function (key, command, position) {
                    if (typeof key == "object" && key) {
                        if (position == undefined) position = key.position;
                        key = key[this.platform];
                    }
                    if (!key) return;
                    if (typeof command == "function") return this.addCommand({ exec: command, bindKey: key, name: command.name || key });

                    key.split("|").forEach(function (keyPart) {
                        var chain = "";
                        if (keyPart.indexOf(" ") != -1) {
                            var parts = keyPart.split(/\s+/);
                            keyPart = parts.pop();
                            parts.forEach(function (keyPart) {
                                var binding = this.parseKeys(keyPart);
                                var id = KEY_MODS[binding.hashId] + binding.key;
                                chain += (chain ? " " : "") + id;
                                this._addCommandToBinding(chain, "chainKeys");
                            }, this);
                            chain += " ";
                        }
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        this._addCommandToBinding(chain + id, command, position);
                    }, this);
                };

                function getPosition(command) {
                    return typeof command == "object" && command.bindKey && command.bindKey.position || 0;
                }
                this._addCommandToBinding = function (keyId, command, position) {
                    var ckb = this.commandKeyBinding,
                        i;
                    if (!command) {
                        delete ckb[keyId];
                    } else if (!ckb[keyId] || this.$singleCommand) {
                        ckb[keyId] = command;
                    } else {
                        if (!Array.isArray(ckb[keyId])) {
                            ckb[keyId] = [ckb[keyId]];
                        } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                            ckb[keyId].splice(i, 1);
                        }

                        if (typeof position != "number") {
                            if (position || command.isDefault) position = -100;else position = getPosition(command);
                        }
                        var commands = ckb[keyId];
                        for (i = 0; i < commands.length; i++) {
                            var other = commands[i];
                            var otherPos = getPosition(other);
                            if (otherPos > position) break;
                        }
                        commands.splice(i, 0, command);
                    }
                };

                this.addCommands = function (commands) {
                    commands && Object.keys(commands).forEach(function (name) {
                        var command = commands[name];
                        if (!command) return;

                        if (typeof command === "string") return this.bindKey(command, name);

                        if (typeof command === "function") command = { exec: command };

                        if (typeof command !== "object") return;

                        if (!command.name) command.name = name;

                        this.addCommand(command);
                    }, this);
                };

                this.removeCommands = function (commands) {
                    Object.keys(commands).forEach(function (name) {
                        this.removeCommand(commands[name]);
                    }, this);
                };

                this.bindKeys = function (keyList) {
                    Object.keys(keyList).forEach(function (key) {
                        this.bindKey(key, keyList[key]);
                    }, this);
                };

                this._buildKeyHash = function (command) {
                    this.bindKey(command.bindKey, command);
                };
                this.parseKeys = function (keys) {
                    var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
                        return x;
                    });
                    var key = parts.pop();

                    var keyCode = keyUtil[key];
                    if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();else if (!parts.length) return { key: key, hashId: -1 };else if (parts.length == 1 && parts[0] == "shift") return { key: key.toUpperCase(), hashId: -1 };

                    var hashId = 0;
                    for (var i = parts.length; i--;) {
                        var modifier = keyUtil.KEY_MODS[parts[i]];
                        if (modifier == null) {
                            if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
                            return false;
                        }
                        hashId |= modifier;
                    }
                    return { key: key, hashId: hashId };
                };

                this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                    var key = KEY_MODS[hashId] + keyString;
                    return this.commandKeyBinding[key];
                };

                this.handleKeyboard = function (data, hashId, keyString, keyCode) {
                    if (keyCode < 0) return;
                    var key = KEY_MODS[hashId] + keyString;
                    var command = this.commandKeyBinding[key];
                    if (data.$keyChain) {
                        data.$keyChain += " " + key;
                        command = this.commandKeyBinding[data.$keyChain] || command;
                    }

                    if (command) {
                        if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                            data.$keyChain = data.$keyChain || key;
                            return { command: "null" };
                        }
                    }

                    if (data.$keyChain) {
                        if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                        else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
                    }
                    return { command: command };
                };

                this.getStatusText = function (editor, data) {
                    return data.$keyChain || "";
                };
            }).call(HashHandler.prototype);

            exports.HashHandler = HashHandler;
            exports.MultiHashHandler = MultiHashHandler;
        });

        ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CommandManager = function (platform, commands) {
                MultiHashHandler.call(this, commands, platform);
                this.byName = this.commands;
                this.setDefaultHandler("exec", function (e) {
                    return e.command.exec(e.editor, e.args || {});
                });
            };

            oop.inherits(CommandManager, MultiHashHandler);

            (function () {

                oop.implement(this, EventEmitter);

                this.exec = function (command, editor, args) {
                    if (Array.isArray(command)) {
                        for (var i = command.length; i--;) {
                            if (this.exec(command[i], editor, args)) return true;
                        }
                        return false;
                    }

                    if (typeof command === "string") command = this.commands[command];

                    if (!command) return false;

                    if (editor && editor.$readOnly && !command.readOnly) return false;

                    var e = { editor: editor, command: command, args: args };
                    e.returnValue = this._emit("exec", e);
                    this._signal("afterExec", e);

                    return e.returnValue === false ? false : true;
                };

                this.toggleRecording = function (editor) {
                    if (this.$inReplay) return;

                    editor && editor._emit("changeStatus");
                    if (this.recording) {
                        this.macro.pop();
                        this.removeEventListener("exec", this.$addCommandToMacro);

                        if (!this.macro.length) this.macro = this.oldMacro;

                        return this.recording = false;
                    }
                    if (!this.$addCommandToMacro) {
                        this.$addCommandToMacro = function (e) {
                            this.macro.push([e.command, e.args]);
                        }.bind(this);
                    }

                    this.oldMacro = this.macro;
                    this.macro = [];
                    this.on("exec", this.$addCommandToMacro);
                    return this.recording = true;
                };

                this.replay = function (editor) {
                    if (this.$inReplay || !this.macro) return;

                    if (this.recording) return this.toggleRecording(editor);

                    try {
                        this.$inReplay = true;
                        this.macro.forEach(function (x) {
                            if (typeof x == "string") this.exec(x, editor);else this.exec(x[0], editor, x[1]);
                        }, this);
                    } finally {
                        this.$inReplay = false;
                    }
                };

                this.trimMacro = function (m) {
                    return m.map(function (x) {
                        if (typeof x[0] != "string") x[0] = x[0].name;
                        if (!x[1]) x = x[0];
                        return x;
                    });
                };
            }).call(CommandManager.prototype);

            exports.CommandManager = CommandManager;
        });

        ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");
            var config = require("../config");
            var Range = require("../range").Range;

            function bindKey(win, mac) {
                return { win: win, mac: mac };
            }
            exports.commands = [{
                name: "showSettingsMenu",
                bindKey: bindKey("Ctrl-,", "Command-,"),
                exec: function (editor) {
                    config.loadModule("ace/ext/settings_menu", function (module) {
                        module.init(editor);
                        editor.showSettingsMenu();
                    });
                },
                readOnly: true
            }, {
                name: "goToNextError",
                bindKey: bindKey("Alt-E", "Ctrl-E"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, 1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "goToPreviousError",
                bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, -1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selectall",
                bindKey: bindKey("Ctrl-A", "Command-A"),
                exec: function (editor) {
                    editor.selectAll();
                },
                readOnly: true
            }, {
                name: "centerselection",
                bindKey: bindKey(null, "Ctrl-L"),
                exec: function (editor) {
                    editor.centerSelection();
                },
                readOnly: true
            }, {
                name: "gotoline",
                bindKey: bindKey("Ctrl-L", "Command-L"),
                exec: function (editor) {
                    var line = parseInt(prompt("Enter line number:"), 10);
                    if (!isNaN(line)) {
                        editor.gotoLine(line);
                    }
                },
                readOnly: true
            }, {
                name: "fold",
                bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfold",
                bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleFoldWidget",
                bindKey: bindKey("F2", "F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleParentFoldWidget",
                bindKey: bindKey("Alt-F2", "Alt-F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldall",
                bindKey: bindKey(null, "Ctrl-Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldOther",
                bindKey: bindKey("Alt-0", "Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                    editor.session.unfold(editor.selection.getAllRanges());
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfoldall",
                bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
                exec: function (editor) {
                    editor.session.unfold();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findnext",
                bindKey: bindKey("Ctrl-K", "Command-G"),
                exec: function (editor) {
                    editor.findNext();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findprevious",
                bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
                exec: function (editor) {
                    editor.findPrevious();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "selectOrFindNext",
                bindKey: bindKey("Alt-K", "Ctrl-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findNext();
                },
                readOnly: true
            }, {
                name: "selectOrFindPrevious",
                bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findPrevious();
                },
                readOnly: true
            }, {
                name: "find",
                bindKey: bindKey("Ctrl-F", "Command-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor);
                    });
                },
                readOnly: true
            }, {
                name: "overwrite",
                bindKey: "Insert",
                exec: function (editor) {
                    editor.toggleOverwrite();
                },
                readOnly: true
            }, {
                name: "selecttostart",
                bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
                exec: function (editor) {
                    editor.getSelection().selectFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotostart",
                bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
                exec: function (editor) {
                    editor.navigateFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectup",
                bindKey: bindKey("Shift-Up", "Shift-Up"),
                exec: function (editor) {
                    editor.getSelection().selectUp();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golineup",
                bindKey: bindKey("Up", "Up|Ctrl-P"),
                exec: function (editor, args) {
                    editor.navigateUp(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttoend",
                bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
                exec: function (editor) {
                    editor.getSelection().selectFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotoend",
                bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
                exec: function (editor) {
                    editor.navigateFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectdown",
                bindKey: bindKey("Shift-Down", "Shift-Down"),
                exec: function (editor) {
                    editor.getSelection().selectDown();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golinedown",
                bindKey: bindKey("Down", "Down|Ctrl-N"),
                exec: function (editor, args) {
                    editor.navigateDown(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordleft",
                bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordleft",
                bindKey: bindKey("Ctrl-Left", "Option-Left"),
                exec: function (editor) {
                    editor.navigateWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolinestart",
                bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolinestart",
                bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
                exec: function (editor) {
                    editor.navigateLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectleft",
                bindKey: bindKey("Shift-Left", "Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoleft",
                bindKey: bindKey("Left", "Left|Ctrl-B"),
                exec: function (editor, args) {
                    editor.navigateLeft(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordright",
                bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordright",
                bindKey: bindKey("Ctrl-Right", "Option-Right"),
                exec: function (editor) {
                    editor.navigateWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolineend",
                bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolineend",
                bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
                exec: function (editor) {
                    editor.navigateLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectright",
                bindKey: bindKey("Shift-Right", "Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoright",
                bindKey: bindKey("Right", "Right|Ctrl-F"),
                exec: function (editor, args) {
                    editor.navigateRight(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectpagedown",
                bindKey: "Shift-PageDown",
                exec: function (editor) {
                    editor.selectPageDown();
                },
                readOnly: true
            }, {
                name: "pagedown",
                bindKey: bindKey(null, "Option-PageDown"),
                exec: function (editor) {
                    editor.scrollPageDown();
                },
                readOnly: true
            }, {
                name: "gotopagedown",
                bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
                exec: function (editor) {
                    editor.gotoPageDown();
                },
                readOnly: true
            }, {
                name: "selectpageup",
                bindKey: "Shift-PageUp",
                exec: function (editor) {
                    editor.selectPageUp();
                },
                readOnly: true
            }, {
                name: "pageup",
                bindKey: bindKey(null, "Option-PageUp"),
                exec: function (editor) {
                    editor.scrollPageUp();
                },
                readOnly: true
            }, {
                name: "gotopageup",
                bindKey: "PageUp",
                exec: function (editor) {
                    editor.gotoPageUp();
                },
                readOnly: true
            }, {
                name: "scrollup",
                bindKey: bindKey("Ctrl-Up", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "scrolldown",
                bindKey: bindKey("Ctrl-Down", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "selectlinestart",
                bindKey: "Shift-Home",
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectlineend",
                bindKey: "Shift-End",
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "togglerecording",
                bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
                exec: function (editor) {
                    editor.commands.toggleRecording(editor);
                },
                readOnly: true
            }, {
                name: "replaymacro",
                bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
                exec: function (editor) {
                    editor.commands.replay(editor);
                },
                readOnly: true
            }, {
                name: "jumptomatching",
                bindKey: bindKey("Ctrl-P", "Ctrl-P"),
                exec: function (editor) {
                    editor.jumpToMatching();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selecttomatching",
                bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
                exec: function (editor) {
                    editor.jumpToMatching(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "expandToMatching",
                bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
                exec: function (editor) {
                    editor.jumpToMatching(true, true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "passKeysToBrowser",
                bindKey: bindKey(null, null),
                exec: function () {},
                passEvent: true,
                readOnly: true
            }, {
                name: "copy",
                exec: function (editor) {},
                readOnly: true
            }, {
                name: "cut",
                exec: function (editor) {
                    var range = editor.getSelectionRange();
                    editor._emit("cut", range);

                    if (!editor.selection.isEmpty()) {
                        editor.session.remove(range);
                        editor.clearSelection();
                    }
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "paste",
                exec: function (editor, args) {
                    editor.$handlePaste(args);
                },
                scrollIntoView: "cursor"
            }, {
                name: "removeline",
                bindKey: bindKey("Ctrl-D", "Command-D"),
                exec: function (editor) {
                    editor.removeLines();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEachLine"
            }, {
                name: "duplicateSelection",
                bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
                exec: function (editor) {
                    editor.duplicateSelection();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "sortlines",
                bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
                exec: function (editor) {
                    editor.sortLines();
                },
                scrollIntoView: "selection",
                multiSelectAction: "forEachLine"
            }, {
                name: "togglecomment",
                bindKey: bindKey("Ctrl-/", "Command-/"),
                exec: function (editor) {
                    editor.toggleCommentLines();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "toggleBlockComment",
                bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
                exec: function (editor) {
                    editor.toggleBlockComment();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "modifyNumberUp",
                bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
                exec: function (editor) {
                    editor.modifyNumber(1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "modifyNumberDown",
                bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
                exec: function (editor) {
                    editor.modifyNumber(-1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "replace",
                bindKey: bindKey("Ctrl-H", "Command-Option-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor, true);
                    });
                }
            }, {
                name: "undo",
                bindKey: bindKey("Ctrl-Z", "Command-Z"),
                exec: function (editor) {
                    editor.undo();
                }
            }, {
                name: "redo",
                bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
                exec: function (editor) {
                    editor.redo();
                }
            }, {
                name: "copylinesup",
                bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
                exec: function (editor) {
                    editor.copyLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesup",
                bindKey: bindKey("Alt-Up", "Option-Up"),
                exec: function (editor) {
                    editor.moveLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "copylinesdown",
                bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
                exec: function (editor) {
                    editor.copyLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesdown",
                bindKey: bindKey("Alt-Down", "Option-Down"),
                exec: function (editor) {
                    editor.moveLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "del",
                bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
                exec: function (editor) {
                    editor.remove("right");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "backspace",
                bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
                exec: function (editor) {
                    editor.remove("left");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "cut_or_delete",
                bindKey: bindKey("Shift-Delete", null),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) {
                        editor.remove("left");
                    } else {
                        return false;
                    }
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolinestart",
                bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
                exec: function (editor) {
                    editor.removeToLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolineend",
                bindKey: bindKey("Alt-Delete", "Ctrl-K"),
                exec: function (editor) {
                    editor.removeToLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordleft",
                bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
                exec: function (editor) {
                    editor.removeWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordright",
                bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
                exec: function (editor) {
                    editor.removeWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "outdent",
                bindKey: bindKey("Shift-Tab", "Shift-Tab"),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "indent",
                bindKey: bindKey("Tab", "Tab"),
                exec: function (editor) {
                    editor.indent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockoutdent",
                bindKey: bindKey("Ctrl-[", "Ctrl-["),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockindent",
                bindKey: bindKey("Ctrl-]", "Ctrl-]"),
                exec: function (editor) {
                    editor.blockIndent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "insertstring",
                exec: function (editor, str) {
                    editor.insert(str);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "inserttext",
                exec: function (editor, args) {
                    editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "splitline",
                bindKey: bindKey(null, "Ctrl-O"),
                exec: function (editor) {
                    editor.splitLine();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "transposeletters",
                bindKey: bindKey("Ctrl-T", "Ctrl-T"),
                exec: function (editor) {
                    editor.transposeLetters();
                },
                multiSelectAction: function (editor) {
                    editor.transposeSelections(1);
                },
                scrollIntoView: "cursor"
            }, {
                name: "touppercase",
                bindKey: bindKey("Ctrl-U", "Ctrl-U"),
                exec: function (editor) {
                    editor.toUpperCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "tolowercase",
                bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
                exec: function (editor) {
                    editor.toLowerCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "expandtoline",
                bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
                exec: function (editor) {
                    var range = editor.selection.getRange();

                    range.start.column = range.end.column = 0;
                    range.end.row++;
                    editor.selection.setRange(range, false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "joinlines",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var isBackwards = editor.selection.isBackwards();
                    var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                    var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                    var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                    var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                    var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                    var insertLine = editor.session.doc.getLine(selectionStart.row);

                    for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                        var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                        if (curLine.length !== 0) {
                            curLine = " " + curLine;
                        }
                        insertLine += curLine;
                    }

                    if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                        insertLine += editor.session.doc.getNewLineCharacter();
                    }

                    editor.clearSelection();
                    editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

                    if (selectedCount > 0) {
                        editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                        editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                    } else {
                        firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                        editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                    }
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "invertSelection",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var endRow = editor.session.doc.getLength() - 1;
                    var endCol = editor.session.doc.getLine(endRow).length;
                    var ranges = editor.selection.rangeList.ranges;
                    var newRanges = [];
                    if (ranges.length < 1) {
                        ranges = [editor.selection.getRange()];
                    }

                    for (var i = 0; i < ranges.length; i++) {
                        if (i == ranges.length - 1) {
                            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                            }
                        }

                        if (i === 0) {
                            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                            }
                        } else {
                            newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                        }
                    }

                    editor.exitMultiSelectMode();
                    editor.clearSelection();

                    for (var i = 0; i < newRanges.length; i++) {
                        editor.selection.addRange(newRanges[i], false);
                    }
                },
                readOnly: true,
                scrollIntoView: "none"
            }];
        });

        ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var lang = require("./lib/lang");
            var useragent = require("./lib/useragent");
            var TextInput = require("./keyboard/textinput").TextInput;
            var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
            var FoldHandler = require("./mouse/fold_handler").FoldHandler;
            var KeyBinding = require("./keyboard/keybinding").KeyBinding;
            var EditSession = require("./edit_session").EditSession;
            var Search = require("./search").Search;
            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var CommandManager = require("./commands/command_manager").CommandManager;
            var defaultCommands = require("./commands/default_commands").commands;
            var config = require("./config");
            var TokenIterator = require("./token_iterator").TokenIterator;
            var Editor = function (renderer, session) {
                var container = renderer.getContainerElement();
                this.container = container;
                this.renderer = renderer;

                this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                this.renderer.textarea = this.textInput.getElement();
                this.keyBinding = new KeyBinding(this);
                this.$mouseHandler = new MouseHandler(this);
                new FoldHandler(this);

                this.$blockScrolling = 0;
                this.$search = new Search().set({
                    wrap: true
                });

                this.$historyTracker = this.$historyTracker.bind(this);
                this.commands.on("exec", this.$historyTracker);

                this.$initOperationListeners();

                this._$emitInputEvent = lang.delayedCall(function () {
                    this._signal("input", {});
                    if (this.session && this.session.bgTokenizer) this.session.bgTokenizer.scheduleStart();
                }.bind(this));

                this.on("change", function (_, _self) {
                    _self._$emitInputEvent.schedule(31);
                });

                this.setSession(session || new EditSession(""));
                config.resetOptions(this);
                config._signal("editor", this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$initOperationListeners = function () {
                    function last(a) {
                        return a[a.length - 1];
                    }

                    this.selections = [];
                    this.commands.on("exec", this.startOperation.bind(this), true);
                    this.commands.on("afterExec", this.endOperation.bind(this), true);

                    this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

                    this.on("change", function () {
                        this.curOp || this.startOperation();
                        this.curOp.docChanged = true;
                    }.bind(this), true);

                    this.on("changeSelection", function () {
                        this.curOp || this.startOperation();
                        this.curOp.selectionChanged = true;
                    }.bind(this), true);
                };

                this.curOp = null;
                this.prevOp = {};
                this.startOperation = function (commadEvent) {
                    if (this.curOp) {
                        if (!commadEvent || this.curOp.command) return;
                        this.prevOp = this.curOp;
                    }
                    if (!commadEvent) {
                        this.previousCommand = null;
                        commadEvent = {};
                    }

                    this.$opResetTimer.schedule();
                    this.curOp = {
                        command: commadEvent.command || {},
                        args: commadEvent.args,
                        scrollTop: this.renderer.scrollTop
                    };
                    if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined) this.$blockScrolling++;
                };

                this.endOperation = function (e) {
                    if (this.curOp) {
                        if (e && e.returnValue === false) return this.curOp = null;
                        this._signal("beforeEndOperation");
                        var command = this.curOp.command;
                        if (command.name && this.$blockScrolling > 0) this.$blockScrolling--;
                        var scrollIntoView = command && command.scrollIntoView;
                        if (scrollIntoView) {
                            switch (scrollIntoView) {
                                case "center-animate":
                                    scrollIntoView = "animate";
                                case "center":
                                    this.renderer.scrollCursorIntoView(null, 0.5);
                                    break;
                                case "animate":
                                case "cursor":
                                    this.renderer.scrollCursorIntoView();
                                    break;
                                case "selectionPart":
                                    var range = this.selection.getRange();
                                    var config = this.renderer.layerConfig;
                                    if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                        this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                    }
                                    break;
                                default:
                                    break;
                            }
                            if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                        }

                        this.prevOp = this.curOp;
                        this.curOp = null;
                    }
                };
                this.$mergeableCommands = ["backspace", "del", "insertstring"];
                this.$historyTracker = function (e) {
                    if (!this.$mergeUndoDeltas) return;

                    var prev = this.prevOp;
                    var mergeableCommands = this.$mergeableCommands;
                    var shouldMerge = prev.command && e.command.name == prev.command.name;
                    if (e.command.name == "insertstring") {
                        var text = e.args;
                        if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;

                        shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
                        && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

                        this.mergeNextCommand = true;
                    } else {
                        shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
                    }

                    if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
                        shouldMerge = false; // the sequence is too long
                    }

                    if (shouldMerge) this.session.mergeUndoDeltas = true;else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
                };
                this.setKeyboardHandler = function (keyboardHandler, cb) {
                    if (keyboardHandler && typeof keyboardHandler === "string") {
                        this.$keybindingId = keyboardHandler;
                        var _self = this;
                        config.loadModule(["keybinding", keyboardHandler], function (module) {
                            if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module && module.handler);
                            cb && cb();
                        });
                    } else {
                        this.$keybindingId = null;
                        this.keyBinding.setKeyboardHandler(keyboardHandler);
                        cb && cb();
                    }
                };
                this.getKeyboardHandler = function () {
                    return this.keyBinding.getKeyboardHandler();
                };
                this.setSession = function (session) {
                    if (this.session == session) return;
                    if (this.curOp) this.endOperation();
                    this.curOp = {};

                    var oldSession = this.session;
                    if (oldSession) {
                        this.session.off("change", this.$onDocumentChange);
                        this.session.off("changeMode", this.$onChangeMode);
                        this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                        this.session.off("changeTabSize", this.$onChangeTabSize);
                        this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                        this.session.off("changeWrapMode", this.$onChangeWrapMode);
                        this.session.off("changeFold", this.$onChangeFold);
                        this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                        this.session.off("changeBackMarker", this.$onChangeBackMarker);
                        this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                        this.session.off("changeAnnotation", this.$onChangeAnnotation);
                        this.session.off("changeOverwrite", this.$onCursorChange);
                        this.session.off("changeScrollTop", this.$onScrollTopChange);
                        this.session.off("changeScrollLeft", this.$onScrollLeftChange);

                        var selection = this.session.getSelection();
                        selection.off("changeCursor", this.$onCursorChange);
                        selection.off("changeSelection", this.$onSelectionChange);
                    }

                    this.session = session;
                    if (session) {
                        this.$onDocumentChange = this.onDocumentChange.bind(this);
                        session.on("change", this.$onDocumentChange);
                        this.renderer.setSession(session);

                        this.$onChangeMode = this.onChangeMode.bind(this);
                        session.on("changeMode", this.$onChangeMode);

                        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                        session.on("tokenizerUpdate", this.$onTokenizerUpdate);

                        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                        session.on("changeTabSize", this.$onChangeTabSize);

                        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                        session.on("changeWrapLimit", this.$onChangeWrapLimit);

                        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                        session.on("changeWrapMode", this.$onChangeWrapMode);

                        this.$onChangeFold = this.onChangeFold.bind(this);
                        session.on("changeFold", this.$onChangeFold);

                        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                        this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

                        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                        this.session.on("changeBackMarker", this.$onChangeBackMarker);

                        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                        this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

                        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                        this.session.on("changeAnnotation", this.$onChangeAnnotation);

                        this.$onCursorChange = this.onCursorChange.bind(this);
                        this.session.on("changeOverwrite", this.$onCursorChange);

                        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                        this.session.on("changeScrollTop", this.$onScrollTopChange);

                        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                        this.session.on("changeScrollLeft", this.$onScrollLeftChange);

                        this.selection = session.getSelection();
                        this.selection.on("changeCursor", this.$onCursorChange);

                        this.$onSelectionChange = this.onSelectionChange.bind(this);
                        this.selection.on("changeSelection", this.$onSelectionChange);

                        this.onChangeMode();

                        this.$blockScrolling += 1;
                        this.onCursorChange();
                        this.$blockScrolling -= 1;

                        this.onScrollTopChange();
                        this.onScrollLeftChange();
                        this.onSelectionChange();
                        this.onChangeFrontMarker();
                        this.onChangeBackMarker();
                        this.onChangeBreakpoint();
                        this.onChangeAnnotation();
                        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                        this.renderer.updateFull();
                    } else {
                        this.selection = null;
                        this.renderer.setSession(session);
                    }

                    this._signal("changeSession", {
                        session: session,
                        oldSession: oldSession
                    });

                    this.curOp = null;

                    oldSession && oldSession._signal("changeEditor", { oldEditor: this });
                    session && session._signal("changeEditor", { editor: this });
                };
                this.getSession = function () {
                    return this.session;
                };
                this.setValue = function (val, cursorPos) {
                    this.session.doc.setValue(val);

                    if (!cursorPos) this.selectAll();else if (cursorPos == 1) this.navigateFileEnd();else if (cursorPos == -1) this.navigateFileStart();

                    return val;
                };
                this.getValue = function () {
                    return this.session.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.resize = function (force) {
                    this.renderer.onResize(force);
                };
                this.setTheme = function (theme, cb) {
                    this.renderer.setTheme(theme, cb);
                };
                this.getTheme = function () {
                    return this.renderer.getTheme();
                };
                this.setStyle = function (style) {
                    this.renderer.setStyle(style);
                };
                this.unsetStyle = function (style) {
                    this.renderer.unsetStyle(style);
                };
                this.getFontSize = function () {
                    return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
                };
                this.setFontSize = function (size) {
                    this.setOption("fontSize", size);
                };

                this.$highlightBrackets = function () {
                    if (this.session.$bracketHighlight) {
                        this.session.removeMarker(this.session.$bracketHighlight);
                        this.session.$bracketHighlight = null;
                    }

                    if (this.$highlightPending) {
                        return;
                    }
                    var self = this;
                    this.$highlightPending = true;
                    setTimeout(function () {
                        self.$highlightPending = false;
                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;
                        var pos = session.findMatchingBracket(self.getCursorPosition());
                        if (pos) {
                            var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                        } else if (session.$mode.getMatching) {
                            var range = session.$mode.getMatching(self.session);
                        }
                        if (range) session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.$highlightTags = function () {
                    if (this.$highlightTagPending) return;
                    var self = this;
                    this.$highlightTagPending = true;
                    setTimeout(function () {
                        self.$highlightTagPending = false;

                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;

                        var pos = self.getCursorPosition();
                        var iterator = new TokenIterator(self.session, pos.row, pos.column);
                        var token = iterator.getCurrentToken();

                        if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        if (token.type.indexOf("tag-open") != -1) {
                            token = iterator.stepForward();
                            if (!token) return;
                        }

                        var tag = token.value;
                        var depth = 0;
                        var prevToken = iterator.stepBackward();

                        if (prevToken.value == '<') {
                            do {
                                prevToken = token;
                                token = iterator.stepForward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (token && depth >= 0);
                        } else {
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (prevToken && depth <= 0);
                            iterator.stepForward();
                        }

                        if (!token) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn();
                        var range = new Range(row, column, row, column + token.value.length);
                        if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                        }

                        if (range && !session.$tagHighlight) session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.focus = function () {
                    var _self = this;
                    setTimeout(function () {
                        _self.textInput.focus();
                    });
                    this.textInput.focus();
                };
                this.isFocused = function () {
                    return this.textInput.isFocused();
                };
                this.blur = function () {
                    this.textInput.blur();
                };
                this.onFocus = function (e) {
                    if (this.$isFocused) return;
                    this.$isFocused = true;
                    this.renderer.showCursor();
                    this.renderer.visualizeFocus();
                    this._emit("focus", e);
                };
                this.onBlur = function (e) {
                    if (!this.$isFocused) return;
                    this.$isFocused = false;
                    this.renderer.hideCursor();
                    this.renderer.visualizeBlur();
                    this._emit("blur", e);
                };

                this.$cursorChange = function () {
                    this.renderer.updateCursor();
                };
                this.onDocumentChange = function (delta) {
                    var wrap = this.session.$useWrapMode;
                    var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
                    this.renderer.updateLines(delta.start.row, lastRow, wrap);

                    this._signal("change", delta);
                    this.$cursorChange();
                    this.$updateHighlightActiveLine();
                };

                this.onTokenizerUpdate = function (e) {
                    var rows = e.data;
                    this.renderer.updateLines(rows.first, rows.last);
                };

                this.onScrollTopChange = function () {
                    this.renderer.scrollToY(this.session.getScrollTop());
                };

                this.onScrollLeftChange = function () {
                    this.renderer.scrollToX(this.session.getScrollLeft());
                };
                this.onCursorChange = function () {
                    this.$cursorChange();

                    if (!this.$blockScrolling) {
                        config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
                        this.renderer.scrollCursorIntoView();
                    }

                    this.$highlightBrackets();
                    this.$highlightTags();
                    this.$updateHighlightActiveLine();
                    this._signal("changeSelection");
                };

                this.$updateHighlightActiveLine = function () {
                    var session = this.getSession();

                    var highlight;
                    if (this.$highlightActiveLine) {
                        if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
                        if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
                    }

                    if (session.$highlightLineMarker && !highlight) {
                        session.removeMarker(session.$highlightLineMarker.id);
                        session.$highlightLineMarker = null;
                    } else if (!session.$highlightLineMarker && highlight) {
                        var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                        range.id = session.addMarker(range, "ace_active-line", "screenLine");
                        session.$highlightLineMarker = range;
                    } else if (highlight) {
                        session.$highlightLineMarker.start.row = highlight.row;
                        session.$highlightLineMarker.end.row = highlight.row;
                        session.$highlightLineMarker.start.column = highlight.column;
                        session._signal("changeBackMarker");
                    }
                };

                this.onSelectionChange = function (e) {
                    var session = this.session;

                    if (session.$selectionMarker) {
                        session.removeMarker(session.$selectionMarker);
                    }
                    session.$selectionMarker = null;

                    if (!this.selection.isEmpty()) {
                        var range = this.selection.getRange();
                        var style = this.getSelectionStyle();
                        session.$selectionMarker = session.addMarker(range, "ace_selection", style);
                    } else {
                        this.$updateHighlightActiveLine();
                    }

                    var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
                    this.session.highlight(re);

                    this._signal("changeSelection");
                };

                this.$getSelectionHighLightRegexp = function () {
                    var session = this.session;

                    var selection = this.getSelectionRange();
                    if (selection.isEmpty() || selection.isMultiLine()) return;

                    var startOuter = selection.start.column - 1;
                    var endOuter = selection.end.column + 1;
                    var line = session.getLine(selection.start.row);
                    var lineCols = line.length;
                    var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
                    if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle)) return;

                    needle = line.substring(selection.start.column, selection.end.column);
                    if (!/^[\w\d]+$/.test(needle)) return;

                    var re = this.$search.$assembleRegExp({
                        wholeWord: true,
                        caseSensitive: true,
                        needle: needle
                    });

                    return re;
                };

                this.onChangeFrontMarker = function () {
                    this.renderer.updateFrontMarkers();
                };

                this.onChangeBackMarker = function () {
                    this.renderer.updateBackMarkers();
                };

                this.onChangeBreakpoint = function () {
                    this.renderer.updateBreakpoints();
                };

                this.onChangeAnnotation = function () {
                    this.renderer.setAnnotations(this.session.getAnnotations());
                };

                this.onChangeMode = function (e) {
                    this.renderer.updateText();
                    this._emit("changeMode", e);
                };

                this.onChangeWrapLimit = function () {
                    this.renderer.updateFull();
                };

                this.onChangeWrapMode = function () {
                    this.renderer.onResize(true);
                };

                this.onChangeFold = function () {
                    this.$updateHighlightActiveLine();
                    this.renderer.updateFull();
                };
                this.getSelectedText = function () {
                    return this.session.getTextRange(this.getSelectionRange());
                };
                this.getCopyText = function () {
                    var text = this.getSelectedText();
                    this._signal("copy", text);
                    return text;
                };
                this.onCopy = function () {
                    this.commands.exec("copy", this);
                };
                this.onCut = function () {
                    this.commands.exec("cut", this);
                };
                this.onPaste = function (text, event) {
                    var e = { text: text, event: event };
                    this.commands.exec("paste", this, e);
                };

                this.$handlePaste = function (e) {
                    if (typeof e == "string") e = { text: e };
                    this._signal("paste", e);
                    var text = e.text;
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                        this.insert(text);
                    } else {
                        var lines = text.split(/\r\n|\r|\n/);
                        var ranges = this.selection.rangeList.ranges;

                        if (lines.length > ranges.length || lines.length < 2 || !lines[1]) return this.commands.exec("insertstring", this, text);

                        for (var i = ranges.length; i--;) {
                            var range = ranges[i];
                            if (!range.isEmpty()) this.session.remove(range);

                            this.session.insert(range.start, lines[i]);
                        }
                    }
                };

                this.execCommand = function (command, args) {
                    return this.commands.exec(command, this, args);
                };
                this.insert = function (text, pasted) {
                    var session = this.session;
                    var mode = session.getMode();
                    var cursor = this.getCursorPosition();

                    if (this.getBehavioursEnabled() && !pasted) {
                        var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                        if (transform) {
                            if (text !== transform.text) {
                                this.session.mergeUndoDeltas = false;
                                this.$mergeNextCommand = false;
                            }
                            text = transform.text;
                        }
                    }

                    if (text == "\t") text = this.session.getTabString();
                    if (!this.selection.isEmpty()) {
                        var range = this.getSelectionRange();
                        cursor = this.session.remove(range);
                        this.clearSelection();
                    } else if (this.session.getOverwrite()) {
                        var range = new Range.fromPoints(cursor, cursor);
                        range.end.column += text.length;
                        this.session.remove(range);
                    }

                    if (text == "\n" || text == "\r\n") {
                        var line = session.getLine(cursor.row);
                        if (cursor.column > line.search(/\S|$/)) {
                            var d = line.substr(cursor.column).search(/\S|$/);
                            session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                        }
                    }
                    this.clearSelection();

                    var start = cursor.column;
                    var lineState = session.getState(cursor.row);
                    var line = session.getLine(cursor.row);
                    var shouldOutdent = mode.checkOutdent(lineState, line, text);
                    var end = session.insert(cursor, text);

                    if (transform && transform.selection) {
                        if (transform.selection.length == 2) {
                            // Transform relative to the current column
                            this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                        } else {
                            // Transform relative to the current row.
                            this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                        }
                    }

                    if (session.getDocument().isNewLine(text)) {
                        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                        session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
                    }
                    if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
                };

                this.onTextInput = function (text) {
                    this.keyBinding.onTextInput(text);
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    this.keyBinding.onCommandKey(e, hashId, keyCode);
                };
                this.setOverwrite = function (overwrite) {
                    this.session.setOverwrite(overwrite);
                };
                this.getOverwrite = function () {
                    return this.session.getOverwrite();
                };
                this.toggleOverwrite = function () {
                    this.session.toggleOverwrite();
                };
                this.setScrollSpeed = function (speed) {
                    this.setOption("scrollSpeed", speed);
                };
                this.getScrollSpeed = function () {
                    return this.getOption("scrollSpeed");
                };
                this.setDragDelay = function (dragDelay) {
                    this.setOption("dragDelay", dragDelay);
                };
                this.getDragDelay = function () {
                    return this.getOption("dragDelay");
                };
                this.setSelectionStyle = function (val) {
                    this.setOption("selectionStyle", val);
                };
                this.getSelectionStyle = function () {
                    return this.getOption("selectionStyle");
                };
                this.setHighlightActiveLine = function (shouldHighlight) {
                    this.setOption("highlightActiveLine", shouldHighlight);
                };
                this.getHighlightActiveLine = function () {
                    return this.getOption("highlightActiveLine");
                };
                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };
                this.setHighlightSelectedWord = function (shouldHighlight) {
                    this.setOption("highlightSelectedWord", shouldHighlight);
                };
                this.getHighlightSelectedWord = function () {
                    return this.$highlightSelectedWord;
                };

                this.setAnimatedScroll = function (shouldAnimate) {
                    this.renderer.setAnimatedScroll(shouldAnimate);
                };

                this.getAnimatedScroll = function () {
                    return this.renderer.getAnimatedScroll();
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.renderer.setShowInvisibles(showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.renderer.getShowInvisibles();
                };

                this.setDisplayIndentGuides = function (display) {
                    this.renderer.setDisplayIndentGuides(display);
                };

                this.getDisplayIndentGuides = function () {
                    return this.renderer.getDisplayIndentGuides();
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.renderer.setShowPrintMargin(showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.renderer.getShowPrintMargin();
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.renderer.setPrintMarginColumn(showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.renderer.getPrintMarginColumn();
                };
                this.setReadOnly = function (readOnly) {
                    this.setOption("readOnly", readOnly);
                };
                this.getReadOnly = function () {
                    return this.getOption("readOnly");
                };
                this.setBehavioursEnabled = function (enabled) {
                    this.setOption("behavioursEnabled", enabled);
                };
                this.getBehavioursEnabled = function () {
                    return this.getOption("behavioursEnabled");
                };
                this.setWrapBehavioursEnabled = function (enabled) {
                    this.setOption("wrapBehavioursEnabled", enabled);
                };
                this.getWrapBehavioursEnabled = function () {
                    return this.getOption("wrapBehavioursEnabled");
                };
                this.setShowFoldWidgets = function (show) {
                    this.setOption("showFoldWidgets", show);
                };
                this.getShowFoldWidgets = function () {
                    return this.getOption("showFoldWidgets");
                };

                this.setFadeFoldWidgets = function (fade) {
                    this.setOption("fadeFoldWidgets", fade);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };
                this.remove = function (dir) {
                    if (this.selection.isEmpty()) {
                        if (dir == "left") this.selection.selectLeft();else this.selection.selectRight();
                    }

                    var range = this.getSelectionRange();
                    if (this.getBehavioursEnabled()) {
                        var session = this.session;
                        var state = session.getState(range.start.row);
                        var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

                        if (range.end.column === 0) {
                            var text = session.getTextRange(range);
                            if (text[text.length - 1] == "\n") {
                                var line = session.getLine(range.end.row);
                                if (/^\s+$/.test(line)) {
                                    range.end.column = line.length;
                                }
                            }
                        }
                        if (new_range) range = new_range;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.removeWordRight = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordRight();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeWordLeft = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordLeft();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineStart = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineStart();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineEnd = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineEnd();

                    var range = this.getSelectionRange();
                    if (range.start.column == range.end.column && range.start.row == range.end.row) {
                        range.end.column = 0;
                        range.end.row++;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.splitLine = function () {
                    if (!this.selection.isEmpty()) {
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }

                    var cursor = this.getCursorPosition();
                    this.insert("\n");
                    this.moveCursorToPosition(cursor);
                };
                this.transposeLetters = function () {
                    if (!this.selection.isEmpty()) {
                        return;
                    }

                    var cursor = this.getCursorPosition();
                    var column = cursor.column;
                    if (column === 0) return;

                    var line = this.session.getLine(cursor.row);
                    var swap, range;
                    if (column < line.length) {
                        swap = line.charAt(column) + line.charAt(column - 1);
                        range = new Range(cursor.row, column - 1, cursor.row, column + 1);
                    } else {
                        swap = line.charAt(column - 1) + line.charAt(column - 2);
                        range = new Range(cursor.row, column - 2, cursor.row, column);
                    }
                    this.session.replace(range, swap);
                };
                this.toLowerCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toLowerCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.toUpperCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toUpperCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.indent = function () {
                    var session = this.session;
                    var range = this.getSelectionRange();

                    if (range.start.row < range.end.row) {
                        var rows = this.$getSelectedRows();
                        session.indentRows(rows.first, rows.last, "\t");
                        return;
                    } else if (range.start.column < range.end.column) {
                        var text = session.getTextRange(range);
                        if (!/^\s+$/.test(text)) {
                            var rows = this.$getSelectedRows();
                            session.indentRows(rows.first, rows.last, "\t");
                            return;
                        }
                    }

                    var line = session.getLine(range.start.row);
                    var position = range.start;
                    var size = session.getTabSize();
                    var column = session.documentToScreenColumn(position.row, position.column);

                    if (this.session.getUseSoftTabs()) {
                        var count = size - column % size;
                        var indentString = lang.stringRepeat(" ", count);
                    } else {
                        var count = column % size;
                        while (line[range.start.column - 1] == " " && count) {
                            range.start.column--;
                            count--;
                        }
                        this.selection.setSelectionRange(range);
                        indentString = "\t";
                    }
                    return this.insert(indentString);
                };
                this.blockIndent = function () {
                    var rows = this.$getSelectedRows();
                    this.session.indentRows(rows.first, rows.last, "\t");
                };
                this.blockOutdent = function () {
                    var selection = this.session.getSelection();
                    this.session.outdentRows(selection.getRange());
                };
                this.sortLines = function () {
                    var rows = this.$getSelectedRows();
                    var session = this.session;

                    var lines = [];
                    for (i = rows.first; i <= rows.last; i++) lines.push(session.getLine(i));

                    lines.sort(function (a, b) {
                        if (a.toLowerCase() < b.toLowerCase()) return -1;
                        if (a.toLowerCase() > b.toLowerCase()) return 1;
                        return 0;
                    });

                    var deleteRange = new Range(0, 0, 0, 0);
                    for (var i = rows.first; i <= rows.last; i++) {
                        var line = session.getLine(i);
                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        deleteRange.end.column = line.length;
                        session.replace(deleteRange, lines[i - rows.first]);
                    }
                };
                this.toggleCommentLines = function () {
                    var state = this.session.getState(this.getCursorPosition().row);
                    var rows = this.$getSelectedRows();
                    this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                };

                this.toggleBlockComment = function () {
                    var cursor = this.getCursorPosition();
                    var state = this.session.getState(cursor.row);
                    var range = this.getSelectionRange();
                    this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                };
                this.getNumberAt = function (row, column) {
                    var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                    _numberRx.lastIndex = 0;

                    var s = this.session.getLine(row);
                    while (_numberRx.lastIndex < column) {
                        var m = _numberRx.exec(s);
                        if (m.index <= column && m.index + m[0].length >= column) {
                            var number = {
                                value: m[0],
                                start: m.index,
                                end: m.index + m[0].length
                            };
                            return number;
                        }
                    }
                    return null;
                };
                this.modifyNumber = function (amount) {
                    var row = this.selection.getCursor().row;
                    var column = this.selection.getCursor().column;
                    var charRange = new Range(row, column - 1, row, column);

                    var c = this.session.getTextRange(charRange);
                    if (!isNaN(parseFloat(c)) && isFinite(c)) {
                        var nr = this.getNumberAt(row, column);
                        if (nr) {
                            var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                            var decimals = nr.start + nr.value.length - fp;

                            var t = parseFloat(nr.value);
                            t *= Math.pow(10, decimals);

                            if (fp !== nr.end && column < fp) {
                                amount *= Math.pow(10, nr.end - column - 1);
                            } else {
                                amount *= Math.pow(10, nr.end - column);
                            }

                            t += amount;
                            t /= Math.pow(10, decimals);
                            var nnr = t.toFixed(decimals);
                            var replaceRange = new Range(row, nr.start, row, nr.end);
                            this.session.replace(replaceRange, nnr);
                            this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                        }
                    }
                };
                this.removeLines = function () {
                    var rows = this.$getSelectedRows();
                    this.session.removeFullLines(rows.first, rows.last);
                    this.clearSelection();
                };

                this.duplicateSelection = function () {
                    var sel = this.selection;
                    var doc = this.session;
                    var range = sel.getRange();
                    var reverse = sel.isBackwards();
                    if (range.isEmpty()) {
                        var row = range.start.row;
                        doc.duplicateLines(row, row);
                    } else {
                        var point = reverse ? range.start : range.end;
                        var endPoint = doc.insert(point, doc.getTextRange(range), false);
                        range.start = point;
                        range.end = endPoint;

                        sel.setSelectionRange(range, reverse);
                    }
                };
                this.moveLinesDown = function () {
                    this.$moveLines(1, false);
                };
                this.moveLinesUp = function () {
                    this.$moveLines(-1, false);
                };
                this.moveText = function (range, toPosition, copy) {
                    return this.session.moveText(range, toPosition, copy);
                };
                this.copyLinesUp = function () {
                    this.$moveLines(-1, true);
                };
                this.copyLinesDown = function () {
                    this.$moveLines(1, true);
                };
                this.$moveLines = function (dir, copy) {
                    var rows, moved;
                    var selection = this.selection;
                    if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                        var range = selection.toOrientedRange();
                        rows = this.$getSelectedRows(range);
                        moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                        if (copy && dir == -1) moved = 0;
                        range.moveBy(moved, 0);
                        selection.fromOrientedRange(range);
                    } else {
                        var ranges = selection.rangeList.ranges;
                        selection.rangeList.detach(this.session);
                        this.inVirtualSelectionMode = true;

                        var diff = 0;
                        var totalDiff = 0;
                        var l = ranges.length;
                        for (var i = 0; i < l; i++) {
                            var rangeIndex = i;
                            ranges[i].moveBy(diff, 0);
                            rows = this.$getSelectedRows(ranges[i]);
                            var first = rows.first;
                            var last = rows.last;
                            while (++i < l) {
                                if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                                var subRows = this.$getSelectedRows(ranges[i]);
                                if (copy && subRows.first != last) break;else if (!copy && subRows.first > last + 1) break;
                                last = subRows.last;
                            }
                            i--;
                            diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                            if (copy && dir == -1) rangeIndex = i + 1;
                            while (rangeIndex <= i) {
                                ranges[rangeIndex].moveBy(diff, 0);
                                rangeIndex++;
                            }
                            if (!copy) diff = 0;
                            totalDiff += diff;
                        }

                        selection.fromOrientedRange(selection.ranges[0]);
                        selection.rangeList.attach(this.session);
                        this.inVirtualSelectionMode = false;
                    }
                };
                this.$getSelectedRows = function (range) {
                    range = (range || this.getSelectionRange()).collapseRows();

                    return {
                        first: this.session.getRowFoldStart(range.start.row),
                        last: this.session.getRowFoldEnd(range.end.row)
                    };
                };

                this.onCompositionStart = function (text) {
                    this.renderer.showComposition(this.getCursorPosition());
                };

                this.onCompositionUpdate = function (text) {
                    this.renderer.setCompositionText(text);
                };

                this.onCompositionEnd = function () {
                    this.renderer.hideComposition();
                };
                this.getFirstVisibleRow = function () {
                    return this.renderer.getFirstVisibleRow();
                };
                this.getLastVisibleRow = function () {
                    return this.renderer.getLastVisibleRow();
                };
                this.isRowVisible = function (row) {
                    return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
                };
                this.isRowFullyVisible = function (row) {
                    return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
                };
                this.$getVisibleRowCount = function () {
                    return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                };

                this.$moveByPage = function (dir, select) {
                    var renderer = this.renderer;
                    var config = this.renderer.layerConfig;
                    var rows = dir * Math.floor(config.height / config.lineHeight);

                    this.$blockScrolling++;
                    if (select === true) {
                        this.selection.$moveSelection(function () {
                            this.moveCursorBy(rows, 0);
                        });
                    } else if (select === false) {
                        this.selection.moveCursorBy(rows, 0);
                        this.selection.clearSelection();
                    }
                    this.$blockScrolling--;

                    var scrollTop = renderer.scrollTop;

                    renderer.scrollBy(0, rows * config.lineHeight);
                    if (select != null) renderer.scrollCursorIntoView(null, 0.5);

                    renderer.animateScrolling(scrollTop);
                };
                this.selectPageDown = function () {
                    this.$moveByPage(1, true);
                };
                this.selectPageUp = function () {
                    this.$moveByPage(-1, true);
                };
                this.gotoPageDown = function () {
                    this.$moveByPage(1, false);
                };
                this.gotoPageUp = function () {
                    this.$moveByPage(-1, false);
                };
                this.scrollPageDown = function () {
                    this.$moveByPage(1);
                };
                this.scrollPageUp = function () {
                    this.$moveByPage(-1);
                };
                this.scrollToRow = function (row) {
                    this.renderer.scrollToRow(row);
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    this.renderer.scrollToLine(line, center, animate, callback);
                };
                this.centerSelection = function () {
                    var range = this.getSelectionRange();
                    var pos = {
                        row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                        column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                    };
                    this.renderer.alignCursor(pos, 0.5);
                };
                this.getCursorPosition = function () {
                    return this.selection.getCursor();
                };
                this.getCursorPositionScreen = function () {
                    return this.session.documentToScreenPosition(this.getCursorPosition());
                };
                this.getSelectionRange = function () {
                    return this.selection.getRange();
                };
                this.selectAll = function () {
                    this.$blockScrolling += 1;
                    this.selection.selectAll();
                    this.$blockScrolling -= 1;
                };
                this.clearSelection = function () {
                    this.selection.clearSelection();
                };
                this.moveCursorTo = function (row, column) {
                    this.selection.moveCursorTo(row, column);
                };
                this.moveCursorToPosition = function (pos) {
                    this.selection.moveCursorToPosition(pos);
                };
                this.jumpToMatching = function (select, expand) {
                    var cursor = this.getCursorPosition();
                    var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                    var prevToken = iterator.getCurrentToken();
                    var token = prevToken || iterator.stepForward();

                    if (!token) return;
                    var matchType;
                    var found = false;
                    var depth = {};
                    var i = cursor.column - token.start;
                    var bracketType;
                    var brackets = {
                        ")": "(",
                        "(": "(",
                        "]": "[",
                        "[": "[",
                        "{": "{",
                        "}": "{"
                    };

                    do {
                        if (token.value.match(/[{}()\[\]]/g)) {
                            for (; i < token.value.length && !found; i++) {
                                if (!brackets[token.value[i]]) {
                                    continue;
                                }

                                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                                if (isNaN(depth[bracketType])) {
                                    depth[bracketType] = 0;
                                }

                                switch (token.value[i]) {
                                    case '(':
                                    case '[':
                                    case '{':
                                        depth[bracketType]++;
                                        break;
                                    case ')':
                                    case ']':
                                    case '}':
                                        depth[bracketType]--;

                                        if (depth[bracketType] === -1) {
                                            matchType = 'bracket';
                                            found = true;
                                        }
                                        break;
                                }
                            }
                        } else if (token && token.type.indexOf('tag-name') !== -1) {
                            if (isNaN(depth[token.value])) {
                                depth[token.value] = 0;
                            }

                            if (prevToken.value === '<') {
                                depth[token.value]++;
                            } else if (prevToken.value === '</') {
                                depth[token.value]--;
                            }

                            if (depth[token.value] === -1) {
                                matchType = 'tag';
                                found = true;
                            }
                        }

                        if (!found) {
                            prevToken = token;
                            token = iterator.stepForward();
                            i = 0;
                        }
                    } while (token && !found);
                    if (!matchType) return;

                    var range, pos;
                    if (matchType === 'bracket') {
                        range = this.session.getBracketRange(cursor);
                        if (!range) {
                            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                            pos = range.start;
                            if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                        }
                    } else if (matchType === 'tag') {
                        if (token && token.type.indexOf('tag-name') !== -1) var tag = token.value;else return;

                        range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                        if (range.compare(cursor.row, cursor.column) === 0) {
                            found = false;
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (prevToken) {
                                    if (prevToken.type.indexOf('tag-close') !== -1) {
                                        range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                                    }

                                    if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                        if (prevToken.value === '<') {
                                            depth[tag]++;
                                        } else if (prevToken.value === '</') {
                                            depth[tag]--;
                                        }

                                        if (depth[tag] === 0) found = true;
                                    }
                                }
                            } while (prevToken && !found);
                        }
                        if (token && token.type.indexOf('tag-name')) {
                            pos = range.start;
                            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2) pos = range.end;
                        }
                    }

                    pos = range && range.cursor || pos;
                    if (pos) {
                        if (select) {
                            if (range && expand) {
                                this.selection.setRange(range);
                            } else if (range && range.isEqual(this.getSelectionRange())) {
                                this.clearSelection();
                            } else {
                                this.selection.selectTo(pos.row, pos.column);
                            }
                        } else {
                            this.selection.moveTo(pos.row, pos.column);
                        }
                    }
                };
                this.gotoLine = function (lineNumber, column, animate) {
                    this.selection.clearSelection();
                    this.session.unfold({ row: lineNumber - 1, column: column || 0 });

                    this.$blockScrolling += 1;
                    this.exitMultiSelectMode && this.exitMultiSelectMode();
                    this.moveCursorTo(lineNumber - 1, column || 0);
                    this.$blockScrolling -= 1;

                    if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
                };
                this.navigateTo = function (row, column) {
                    this.selection.moveTo(row, column);
                };
                this.navigateUp = function (times) {
                    if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                        var selectionStart = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionStart);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(-times || -1, 0);
                };
                this.navigateDown = function (times) {
                    if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                        var selectionEnd = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionEnd);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(times || 1, 0);
                };
                this.navigateLeft = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionStart = this.getSelectionRange().start;
                        this.moveCursorToPosition(selectionStart);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorLeft();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateRight = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionEnd = this.getSelectionRange().end;
                        this.moveCursorToPosition(selectionEnd);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorRight();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateLineStart = function () {
                    this.selection.moveCursorLineStart();
                    this.clearSelection();
                };
                this.navigateLineEnd = function () {
                    this.selection.moveCursorLineEnd();
                    this.clearSelection();
                };
                this.navigateFileEnd = function () {
                    this.selection.moveCursorFileEnd();
                    this.clearSelection();
                };
                this.navigateFileStart = function () {
                    this.selection.moveCursorFileStart();
                    this.clearSelection();
                };
                this.navigateWordRight = function () {
                    this.selection.moveCursorWordRight();
                    this.clearSelection();
                };
                this.navigateWordLeft = function () {
                    this.selection.moveCursorWordLeft();
                    this.clearSelection();
                };
                this.replace = function (replacement, options) {
                    if (options) this.$search.set(options);

                    var range = this.$search.find(this.session);
                    var replaced = 0;
                    if (!range) return replaced;

                    if (this.$tryReplace(range, replacement)) {
                        replaced = 1;
                    }
                    if (range !== null) {
                        this.selection.setSelectionRange(range);
                        this.renderer.scrollSelectionIntoView(range.start, range.end);
                    }

                    return replaced;
                };
                this.replaceAll = function (replacement, options) {
                    if (options) {
                        this.$search.set(options);
                    }

                    var ranges = this.$search.findAll(this.session);
                    var replaced = 0;
                    if (!ranges.length) return replaced;

                    this.$blockScrolling += 1;

                    var selection = this.getSelectionRange();
                    this.selection.moveTo(0, 0);

                    for (var i = ranges.length - 1; i >= 0; --i) {
                        if (this.$tryReplace(ranges[i], replacement)) {
                            replaced++;
                        }
                    }

                    this.selection.setSelectionRange(selection);
                    this.$blockScrolling -= 1;

                    return replaced;
                };

                this.$tryReplace = function (range, replacement) {
                    var input = this.session.getTextRange(range);
                    replacement = this.$search.replace(input, replacement);
                    if (replacement !== null) {
                        range.end = this.session.replace(range, replacement);
                        return range;
                    } else {
                        return null;
                    }
                };
                this.getLastSearchOptions = function () {
                    return this.$search.getOptions();
                };
                this.find = function (needle, options, animate) {
                    if (!options) options = {};

                    if (typeof needle == "string" || needle instanceof RegExp) options.needle = needle;else if (typeof needle == "object") oop.mixin(options, needle);

                    var range = this.selection.getRange();
                    if (options.needle == null) {
                        needle = this.session.getTextRange(range) || this.$search.$options.needle;
                        if (!needle) {
                            range = this.session.getWordRange(range.start.row, range.start.column);
                            needle = this.session.getTextRange(range);
                        }
                        this.$search.set({ needle: needle });
                    }

                    this.$search.set(options);
                    if (!options.start) this.$search.set({ start: range });

                    var newRange = this.$search.find(this.session);
                    if (options.preventScroll) return newRange;
                    if (newRange) {
                        this.revealRange(newRange, animate);
                        return newRange;
                    }
                    if (options.backwards) range.start = range.end;else range.end = range.start;
                    this.selection.setRange(range);
                };
                this.findNext = function (options, animate) {
                    this.find({ skipCurrent: true, backwards: false }, options, animate);
                };
                this.findPrevious = function (options, animate) {
                    this.find(options, { skipCurrent: true, backwards: true }, animate);
                };

                this.revealRange = function (range, animate) {
                    this.$blockScrolling += 1;
                    this.session.unfold(range);
                    this.selection.setSelectionRange(range);
                    this.$blockScrolling -= 1;

                    var scrollTop = this.renderer.scrollTop;
                    this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                    if (animate !== false) this.renderer.animateScrolling(scrollTop);
                };
                this.undo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().undo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.redo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().redo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.destroy = function () {
                    this.renderer.destroy();
                    this._signal("destroy", this);
                    if (this.session) {
                        this.session.destroy();
                    }
                };
                this.setAutoScrollEditorIntoView = function (enable) {
                    if (!enable) return;
                    var rect;
                    var self = this;
                    var shouldScroll = false;
                    if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
                    var scrollAnchor = this.$scrollAnchor;
                    scrollAnchor.style.cssText = "position:absolute";
                    this.container.insertBefore(scrollAnchor, this.container.firstChild);
                    var onChangeSelection = this.on("changeSelection", function () {
                        shouldScroll = true;
                    });
                    var onBeforeRender = this.renderer.on("beforeRender", function () {
                        if (shouldScroll) rect = self.renderer.container.getBoundingClientRect();
                    });
                    var onAfterRender = this.renderer.on("afterRender", function () {
                        if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
                            var renderer = self.renderer;
                            var pos = renderer.$cursorLayer.$pixelPos;
                            var config = renderer.layerConfig;
                            var top = pos.top - config.offset;
                            if (pos.top >= 0 && top + rect.top < 0) {
                                shouldScroll = true;
                            } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                                shouldScroll = false;
                            } else {
                                shouldScroll = null;
                            }
                            if (shouldScroll != null) {
                                scrollAnchor.style.top = top + "px";
                                scrollAnchor.style.left = pos.left + "px";
                                scrollAnchor.style.height = config.lineHeight + "px";
                                scrollAnchor.scrollIntoView(shouldScroll);
                            }
                            shouldScroll = rect = null;
                        }
                    });
                    this.setAutoScrollEditorIntoView = function (enable) {
                        if (enable) return;
                        delete this.setAutoScrollEditorIntoView;
                        this.off("changeSelection", onChangeSelection);
                        this.renderer.off("afterRender", onAfterRender);
                        this.renderer.off("beforeRender", onBeforeRender);
                    };
                };

                this.$resetCursorStyle = function () {
                    var style = this.$cursorStyle || "ace";
                    var cursorLayer = this.renderer.$cursorLayer;
                    if (!cursorLayer) return;
                    cursorLayer.setSmoothBlinking(/smooth/.test(style));
                    cursorLayer.isBlinking = !this.$readOnly && style != "wide";
                    dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
                };
            }).call(Editor.prototype);

            config.defineOptions(Editor.prototype, "editor", {
                selectionStyle: {
                    set: function (style) {
                        this.onSelectionChange();
                        this._signal("changeSelectionStyle", { data: style });
                    },
                    initialValue: "line"
                },
                highlightActiveLine: {
                    set: function () {
                        this.$updateHighlightActiveLine();
                    },
                    initialValue: true
                },
                highlightSelectedWord: {
                    set: function (shouldHighlight) {
                        this.$onSelectionChange();
                    },
                    initialValue: true
                },
                readOnly: {
                    set: function (readOnly) {
                        this.$resetCursorStyle();
                    },
                    initialValue: false
                },
                cursorStyle: {
                    set: function (val) {
                        this.$resetCursorStyle();
                    },
                    values: ["ace", "slim", "smooth", "wide"],
                    initialValue: "ace"
                },
                mergeUndoDeltas: {
                    values: [false, true, "always"],
                    initialValue: true
                },
                behavioursEnabled: { initialValue: true },
                wrapBehavioursEnabled: { initialValue: true },
                autoScrollEditorIntoView: {
                    set: function (val) {
                        this.setAutoScrollEditorIntoView(val);
                    }
                },
                keyboardHandler: {
                    set: function (val) {
                        this.setKeyboardHandler(val);
                    },
                    get: function () {
                        return this.keybindingId;
                    },
                    handlesSet: true
                },

                hScrollBarAlwaysVisible: "renderer",
                vScrollBarAlwaysVisible: "renderer",
                highlightGutterLine: "renderer",
                animatedScroll: "renderer",
                showInvisibles: "renderer",
                showPrintMargin: "renderer",
                printMarginColumn: "renderer",
                printMargin: "renderer",
                fadeFoldWidgets: "renderer",
                showFoldWidgets: "renderer",
                showLineNumbers: "renderer",
                showGutter: "renderer",
                displayIndentGuides: "renderer",
                fontSize: "renderer",
                fontFamily: "renderer",
                maxLines: "renderer",
                minLines: "renderer",
                scrollPastEnd: "renderer",
                fixedWidthGutter: "renderer",
                theme: "renderer",

                scrollSpeed: "$mouseHandler",
                dragDelay: "$mouseHandler",
                dragEnabled: "$mouseHandler",
                focusTimout: "$mouseHandler",
                tooltipFollowsMouse: "$mouseHandler",

                firstLineNumber: "session",
                overwrite: "session",
                newLineMode: "session",
                useWorker: "session",
                useSoftTabs: "session",
                tabSize: "session",
                wrap: "session",
                indentedSoftWrap: "session",
                foldStyle: "session",
                mode: "session"
            });

            exports.Editor = Editor;
        });

        ace.define("ace/undomanager", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var UndoManager = function () {
                this.reset();
            };

            (function () {
                this.execute = function (options) {
                    var deltaSets = options.args[0];
                    this.$doc = options.args[1];
                    if (options.merge && this.hasUndo()) {
                        this.dirtyCounter--;
                        deltaSets = this.$undoStack.pop().concat(deltaSets);
                    }
                    this.$undoStack.push(deltaSets);
                    this.$redoStack = [];
                    if (this.dirtyCounter < 0) {
                        this.dirtyCounter = NaN;
                    }
                    this.dirtyCounter++;
                };
                this.undo = function (dontSelect) {
                    var deltaSets = this.$undoStack.pop();
                    var undoSelectionRange = null;
                    if (deltaSets) {
                        undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
                        this.$redoStack.push(deltaSets);
                        this.dirtyCounter--;
                    }

                    return undoSelectionRange;
                };
                this.redo = function (dontSelect) {
                    var deltaSets = this.$redoStack.pop();
                    var redoSelectionRange = null;
                    if (deltaSets) {
                        redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
                        this.$undoStack.push(deltaSets);
                        this.dirtyCounter++;
                    }
                    return redoSelectionRange;
                };
                this.reset = function () {
                    this.$undoStack = [];
                    this.$redoStack = [];
                    this.dirtyCounter = 0;
                };
                this.hasUndo = function () {
                    return this.$undoStack.length > 0;
                };
                this.hasRedo = function () {
                    return this.$redoStack.length > 0;
                };
                this.markClean = function () {
                    this.dirtyCounter = 0;
                };
                this.isClean = function () {
                    return this.dirtyCounter === 0;
                };
                this.$serializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $serializeDelta);
                };
                this.$deserializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
                };

                function $serializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines.length == 1 ? null : delta.lines,
                        text: delta.lines.length == 1 ? delta.lines[0] : null
                    };
                }

                function $deserializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines || [delta.text]
                    };
                }

                function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
                    var deltaSets_new = new Array(deltaSets_old.length);
                    for (var i = 0; i < deltaSets_old.length; i++) {
                        var deltaSet_old = deltaSets_old[i];
                        var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length) };

                        for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                            var delta_old = deltaSet_old.deltas[j];
                            deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
                        }

                        deltaSets_new[i] = deltaSet_new;
                    }
                    return deltaSets_new;
                }
            }).call(UndoManager.prototype);

            exports.UndoManager = UndoManager;
        });

        ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Gutter = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_gutter-layer";
                parentEl.appendChild(this.element);
                this.setShowFoldWidgets(this.$showFoldWidgets);

                this.gutterWidth = 0;

                this.$annotations = [];
                this.$updateAnnotations = this.$updateAnnotations.bind(this);

                this.$cells = [];
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.setSession = function (session) {
                    if (this.session) this.session.removeEventListener("change", this.$updateAnnotations);
                    this.session = session;
                    if (session) session.on("change", this.$updateAnnotations);
                };

                this.addGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
                    this.session.addGutterDecoration(row, className);
                };

                this.removeGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
                    this.session.removeGutterDecoration(row, className);
                };

                this.setAnnotations = function (annotations) {
                    this.$annotations = [];
                    for (var i = 0; i < annotations.length; i++) {
                        var annotation = annotations[i];
                        var row = annotation.row;
                        var rowInfo = this.$annotations[row];
                        if (!rowInfo) rowInfo = this.$annotations[row] = { text: [] };

                        var annoText = annotation.text;
                        annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

                        if (rowInfo.text.indexOf(annoText) === -1) rowInfo.text.push(annoText);

                        var type = annotation.type;
                        if (type == "error") rowInfo.className = " ace_error";else if (type == "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";else if (type == "info" && !rowInfo.className) rowInfo.className = " ace_info";
                    }
                };

                this.$updateAnnotations = function (delta) {
                    if (!this.$annotations.length) return;
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;
                    if (len === 0) {} else if (delta.action == 'remove') {
                        this.$annotations.splice(firstRow, len + 1, null);
                    } else {
                        var args = new Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.$annotations.splice.apply(this.$annotations, args);
                    }
                };

                this.update = function (config) {
                    var session = this.session;
                    var firstRow = config.firstRow;
                    var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
                    session.getLength() - 1);
                    var fold = session.getNextFoldLine(firstRow);
                    var foldStart = fold ? fold.start.row : Infinity;
                    var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
                    var breakpoints = session.$breakpoints;
                    var decorations = session.$decorations;
                    var firstLineNumber = session.$firstLineNumber;
                    var lastLineNumber = 0;

                    var gutterRenderer = session.gutterRenderer || this.$renderer;

                    var cell = null;
                    var index = -1;
                    var row = firstRow;
                    while (true) {
                        if (row > foldStart) {
                            row = fold.end.row + 1;
                            fold = session.getNextFoldLine(row, fold);
                            foldStart = fold ? fold.start.row : Infinity;
                        }
                        if (row > lastRow) {
                            while (this.$cells.length > index + 1) {
                                cell = this.$cells.pop();
                                this.element.removeChild(cell.element);
                            }
                            break;
                        }

                        cell = this.$cells[++index];
                        if (!cell) {
                            cell = { element: null, textNode: null, foldWidget: null };
                            cell.element = dom.createElement("div");
                            cell.textNode = document.createTextNode('');
                            cell.element.appendChild(cell.textNode);
                            this.element.appendChild(cell.element);
                            this.$cells[index] = cell;
                        }

                        var className = "ace_gutter-cell ";
                        if (breakpoints[row]) className += breakpoints[row];
                        if (decorations[row]) className += decorations[row];
                        if (this.$annotations[row]) className += this.$annotations[row].className;
                        if (cell.element.className != className) cell.element.className = className;

                        var height = session.getRowLength(row) * config.lineHeight + "px";
                        if (height != cell.element.style.height) cell.element.style.height = height;

                        if (foldWidgets) {
                            var c = foldWidgets[row];
                            if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
                        }

                        if (c) {
                            if (!cell.foldWidget) {
                                cell.foldWidget = dom.createElement("span");
                                cell.element.appendChild(cell.foldWidget);
                            }
                            var className = "ace_fold-widget ace_" + c;
                            if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";else className += " ace_open";
                            if (cell.foldWidget.className != className) cell.foldWidget.className = className;

                            var height = config.lineHeight + "px";
                            if (cell.foldWidget.style.height != height) cell.foldWidget.style.height = height;
                        } else {
                            if (cell.foldWidget) {
                                cell.element.removeChild(cell.foldWidget);
                                cell.foldWidget = null;
                            }
                        }

                        var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
                        if (text != cell.textNode.data) cell.textNode.data = text;

                        row++;
                    }

                    this.element.style.height = config.minHeight + "px";

                    if (this.$fixedWidth || session.$useWrapMode) lastLineNumber = session.getLength() + firstLineNumber;

                    var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;

                    var padding = this.$padding || this.$computePadding();
                    gutterWidth += padding.left + padding.right;
                    if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                        this.gutterWidth = gutterWidth;
                        this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                        this._emit("changeGutterWidth", gutterWidth);
                    }
                };

                this.$fixedWidth = false;

                this.$showLineNumbers = true;
                this.$renderer = "";
                this.setShowLineNumbers = function (show) {
                    this.$renderer = !show && {
                        getWidth: function () {
                            return "";
                        },
                        getText: function () {
                            return "";
                        }
                    };
                };

                this.getShowLineNumbers = function () {
                    return this.$showLineNumbers;
                };

                this.$showFoldWidgets = true;
                this.setShowFoldWidgets = function (show) {
                    if (show) dom.addCssClass(this.element, "ace_folding-enabled");else dom.removeCssClass(this.element, "ace_folding-enabled");

                    this.$showFoldWidgets = show;
                    this.$padding = null;
                };

                this.getShowFoldWidgets = function () {
                    return this.$showFoldWidgets;
                };

                this.$computePadding = function () {
                    if (!this.element.firstChild) return { left: 0, right: 0 };
                    var style = dom.computedStyle(this.element.firstChild);
                    this.$padding = {};
                    this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
                    this.$padding.right = parseInt(style.paddingRight) || 0;
                    return this.$padding;
                };

                this.getRegion = function (point) {
                    var padding = this.$padding || this.$computePadding();
                    var rect = this.element.getBoundingClientRect();
                    if (point.x < padding.left + rect.left) return "markers";
                    if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
                };
            }).call(Gutter.prototype);

            exports.Gutter = Gutter;
        });

        ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var dom = require("../lib/dom");

            var Marker = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_marker-layer";
                parentEl.appendChild(this.element);
            };

            (function () {

                this.$padding = 0;

                this.setPadding = function (padding) {
                    this.$padding = padding;
                };
                this.setSession = function (session) {
                    this.session = session;
                };

                this.setMarkers = function (markers) {
                    this.markers = markers;
                };

                this.update = function (config) {
                    var config = config || this.config;
                    if (!config) return;

                    this.config = config;

                    var html = [];
                    for (var key in this.markers) {
                        var marker = this.markers[key];

                        if (!marker.range) {
                            marker.update(html, this, this.session, config);
                            continue;
                        }

                        var range = marker.range.clipRows(config.firstRow, config.lastRow);
                        if (range.isEmpty()) continue;

                        range = range.toScreenRange(this.session);
                        if (marker.renderer) {
                            var top = this.$getTop(range.start.row, config);
                            var left = this.$padding + range.start.column * config.characterWidth;
                            marker.renderer(html, range, left, top, config);
                        } else if (marker.type == "fullLine") {
                            this.drawFullLineMarker(html, range, marker.clazz, config);
                        } else if (marker.type == "screenLine") {
                            this.drawScreenLineMarker(html, range, marker.clazz, config);
                        } else if (range.isMultiLine()) {
                            if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);else this.drawMultiLineMarker(html, range, marker.clazz, config);
                        } else {
                            this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                        }
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$getTop = function (row, layerConfig) {
                    return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                };

                function getBorderClass(tl, tr, br, bl) {
                    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
                }
                this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
                    var session = this.session;
                    var start = range.start.row;
                    var end = range.end.row;
                    var row = start;
                    var prev = 0;
                    var curr = 0;
                    var next = session.getScreenLastRowColumn(row);
                    var lineRange = new Range(row, range.start.column, row, curr);
                    for (; row <= end; row++) {
                        lineRange.start.row = lineRange.end.row = row;
                        lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                        lineRange.end.column = next;
                        prev = curr;
                        curr = next;
                        next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
                    }
                };
                this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var padding = this.$padding;
                    var height = config.lineHeight;
                    var top = this.$getTop(range.start.row, config);
                    var left = padding + range.start.column * config.characterWidth;
                    extraStyle = extraStyle || "";

                    stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
                    top = this.$getTop(range.end.row, config);
                    var width = range.end.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                    height = (range.end.row - range.start.row - 1) * config.lineHeight;
                    if (height <= 0) return;
                    top = this.$getTop(range.start.row + 1, config);

                    var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

                    stringBuilder.push("<div class='", clazz, radiusClass ? " ace_br" + radiusClass : "", "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                };
                this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
                    var height = config.lineHeight;
                    var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
                };

                this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;
                    if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };

                this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };
            }).call(Marker.prototype);

            exports.Marker = Marker;
        });

        ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Text = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_text-layer";
                parentEl.appendChild(this.element);
                this.$updateEolChar = this.$updateEolChar.bind(this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.EOF_CHAR = "\xB6";
                this.EOL_CHAR_LF = "\xAC";
                this.EOL_CHAR_CRLF = "\xa4";
                this.EOL_CHAR = this.EOL_CHAR_LF;
                this.TAB_CHAR = "\u2014"; //"\u21E5";
                this.SPACE_CHAR = "\xB7";
                this.$padding = 0;

                this.$updateEolChar = function () {
                    var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
                    if (this.EOL_CHAR != EOL_CHAR) {
                        this.EOL_CHAR = EOL_CHAR;
                        return true;
                    }
                };

                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.element.style.padding = "0 " + padding + "px";
                };

                this.getLineHeight = function () {
                    return this.$fontMetrics.$characterSize.height || 0;
                };

                this.getCharacterWidth = function () {
                    return this.$fontMetrics.$characterSize.width || 0;
                };

                this.$setFontMetrics = function (measure) {
                    this.$fontMetrics = measure;
                    this.$fontMetrics.on("changeCharacterSize", function (e) {
                        this._signal("changeCharacterSize", e);
                    }.bind(this));
                    this.$pollSizeChanges();
                };

                this.checkForSizeChanges = function () {
                    this.$fontMetrics.checkForSizeChanges();
                };
                this.$pollSizeChanges = function () {
                    return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                };
                this.setSession = function (session) {
                    this.session = session;
                    if (session) this.$computeTabString();
                };

                this.showInvisibles = false;
                this.setShowInvisibles = function (showInvisibles) {
                    if (this.showInvisibles == showInvisibles) return false;

                    this.showInvisibles = showInvisibles;
                    this.$computeTabString();
                    return true;
                };

                this.displayIndentGuides = true;
                this.setDisplayIndentGuides = function (display) {
                    if (this.displayIndentGuides == display) return false;

                    this.displayIndentGuides = display;
                    this.$computeTabString();
                    return true;
                };

                this.$tabStrings = [];
                this.onChangeTabSize = this.$computeTabString = function () {
                    var tabSize = this.session.getTabSize();
                    this.tabSize = tabSize;
                    var tabStr = this.$tabStrings = [0];
                    for (var i = 1; i < tabSize + 1; i++) {
                        if (this.showInvisibles) {
                            tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
                        } else {
                            tabStr.push(lang.stringRepeat(" ", i));
                        }
                    }
                    if (this.displayIndentGuides) {
                        this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                        var className = "ace_indent-guide";
                        var spaceClass = "";
                        var tabClass = "";
                        if (this.showInvisibles) {
                            className += " ace_invisible";
                            spaceClass = " ace_invisible_space";
                            tabClass = " ace_invisible_tab";
                            var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                            var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
                        } else {
                            var spaceContent = lang.stringRepeat(" ", this.tabSize);
                            var tabContent = spaceContent;
                        }

                        this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
                        this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
                    }
                };

                this.updateLines = function (config, firstRow, lastRow) {
                    if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
                        this.scrollLines(config);
                    }
                    this.config = config;

                    var first = Math.max(firstRow, config.firstRow);
                    var last = Math.min(lastRow, config.lastRow);

                    var lineElements = this.element.childNodes;
                    var lineElementsIdx = 0;

                    for (var row = config.firstRow; row < first; row++) {
                        var foldLine = this.session.getFoldLine(row);
                        if (foldLine) {
                            if (foldLine.containsRow(first)) {
                                first = foldLine.start.row;
                                break;
                            } else {
                                row = foldLine.end.row;
                            }
                        }
                        lineElementsIdx++;
                    }

                    var row = first;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > last) break;

                        var lineElement = lineElements[lineElementsIdx++];
                        if (lineElement) {
                            var html = [];
                            this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
                            lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                            lineElement.innerHTML = html.join("");
                        }
                        row++;
                    }
                };

                this.scrollLines = function (config) {
                    var oldConfig = this.config;
                    this.config = config;

                    if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);

                    if (config.lastRow < oldConfig.firstRow) return this.update(config);

                    var el = this.element;
                    if (oldConfig.firstRow < config.firstRow) for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--) el.removeChild(el.firstChild);

                    if (oldConfig.lastRow > config.lastRow) for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--) el.removeChild(el.lastChild);

                    if (config.firstRow < oldConfig.firstRow) {
                        var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                        if (el.firstChild) el.insertBefore(fragment, el.firstChild);else el.appendChild(fragment);
                    }

                    if (config.lastRow > oldConfig.lastRow) {
                        var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                        el.appendChild(fragment);
                    }
                };

                this.$renderLinesFragment = function (config, firstRow, lastRow) {
                    var fragment = this.element.ownerDocument.createDocumentFragment();
                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        var container = dom.createElement("div");

                        var html = [];
                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                        container.innerHTML = html.join("");
                        if (this.$useLineGroups()) {
                            container.className = 'ace_line_group';
                            fragment.appendChild(container);
                            container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                        } else {
                            while (container.firstChild) fragment.appendChild(container.firstChild);
                        }

                        row++;
                    }
                    return fragment;
                };

                this.update = function (config) {
                    this.config = config;

                    var html = [];
                    var firstRow = config.firstRow,
                        lastRow = config.lastRow;

                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        if (this.$useLineGroups()) html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");

                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

                        if (this.$useLineGroups()) html.push("</div>"); // end the line group

                        row++;
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$textToken = {
                    "text": true,
                    "rparen": true,
                    "lparen": true
                };

                this.$renderToken = function (stringBuilder, screenColumn, token, value) {
                    var self = this;
                    var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
                    var replaceFunc = function (c, a, b, tabIdx, idx4) {
                        if (a) {
                            return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : c;
                        } else if (c == "&") {
                            return "&#38;";
                        } else if (c == "<") {
                            return "&#60;";
                        } else if (c == ">") {
                            return "&#62;";
                        } else if (c == "\t") {
                            var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                            screenColumn += tabSize - 1;
                            return self.$tabStrings[tabSize];
                        } else if (c == "\u3000") {
                            var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                            var space = self.showInvisibles ? self.SPACE_CHAR : "";
                            screenColumn += 1;
                            return "<span class='" + classToUse + "' style='width:" + self.config.characterWidth * 2 + "px'>" + space + "</span>";
                        } else if (b) {
                            return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
                        } else {
                            screenColumn += 1;
                            return "<span class='ace_cjk' style='width:" + self.config.characterWidth * 2 + "px'>" + c + "</span>";
                        }
                    };

                    var output = value.replace(replaceReg, replaceFunc);

                    if (!this.$textToken[token.type]) {
                        var classes = "ace_" + token.type.replace(/\./g, " ace_");
                        var style = "";
                        if (token.type == "fold") style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
                        stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
                    } else {
                        stringBuilder.push(output);
                    }
                    return screenColumn + value.length;
                };

                this.renderIndentGuide = function (stringBuilder, value, max) {
                    var cols = value.search(this.$indentGuideRe);
                    if (cols <= 0 || cols >= max) return value;
                    if (value[0] == " ") {
                        cols -= cols % this.tabSize;
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
                        return value.substr(cols);
                    } else if (value[0] == "\t") {
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
                        return value.substr(cols);
                    }
                    return value;
                };

                this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
                    var chars = 0;
                    var split = 0;
                    var splitChars = splits[0];
                    var screenColumn = 0;

                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        var value = token.value;
                        if (i == 0 && this.displayIndentGuides) {
                            chars = value.length;
                            value = this.renderIndentGuide(stringBuilder, value, splitChars);
                            if (!value) continue;
                            chars -= value.length;
                        }

                        if (chars + value.length < splitChars) {
                            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            chars += value.length;
                        } else {
                            while (chars + value.length >= splitChars) {
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                                value = value.substring(splitChars - chars);
                                chars = splitChars;

                                if (!onlyContents) {
                                    stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                                }

                                stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                                split++;
                                screenColumn = 0;
                                splitChars = splits[split] || Number.MAX_VALUE;
                            }
                            if (value.length != 0) {
                                chars += value.length;
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            }
                        }
                    }
                };

                this.$renderSimpleLine = function (stringBuilder, tokens) {
                    var screenColumn = 0;
                    var token = tokens[0];
                    var value = token.value;
                    if (this.displayIndentGuides) value = this.renderIndentGuide(stringBuilder, value);
                    if (value) screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    for (var i = 1; i < tokens.length; i++) {
                        token = tokens[i];
                        value = token.value;
                        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    }
                };
                this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
                    if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);

                    if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);else var tokens = this.session.getTokens(row);

                    if (!onlyContents) {
                        stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
                    }

                    if (tokens.length) {
                        var splits = this.session.getRowSplitData(row);
                        if (splits && splits.length) this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);else this.$renderSimpleLine(stringBuilder, tokens);
                    }

                    if (this.showInvisibles) {
                        if (foldLine) row = foldLine.end.row;

                        stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
                    }
                    if (!onlyContents) stringBuilder.push("</div>");
                };

                this.$getFoldLineTokens = function (row, foldLine) {
                    var session = this.session;
                    var renderTokens = [];

                    function addTokens(tokens, from, to) {
                        var idx = 0,
                            col = 0;
                        while (col + tokens[idx].value.length < from) {
                            col += tokens[idx].value.length;
                            idx++;

                            if (idx == tokens.length) return;
                        }
                        if (col != from) {
                            var value = tokens[idx].value.substring(from - col);
                            if (value.length > to - from) value = value.substring(0, to - from);

                            renderTokens.push({
                                type: tokens[idx].type,
                                value: value
                            });

                            col = from + value.length;
                            idx += 1;
                        }

                        while (col < to && idx < tokens.length) {
                            var value = tokens[idx].value;
                            if (value.length + col > to) {
                                renderTokens.push({
                                    type: tokens[idx].type,
                                    value: value.substring(0, to - col)
                                });
                            } else renderTokens.push(tokens[idx]);
                            col += value.length;
                            idx += 1;
                        }
                    }

                    var tokens = session.getTokens(row);
                    foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
                        if (placeholder != null) {
                            renderTokens.push({
                                type: "fold",
                                value: placeholder
                            });
                        } else {
                            if (isNewRow) tokens = session.getTokens(row);

                            if (tokens.length) addTokens(tokens, lastColumn, column);
                        }
                    }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

                    return renderTokens;
                };

                this.$useLineGroups = function () {
                    return this.session.getUseWrapMode();
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.$measureNode) this.$measureNode.parentNode.removeChild(this.$measureNode);
                    delete this.$measureNode;
                };
            }).call(Text.prototype);

            exports.Text = Text;
        });

        ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var isIE8;

            var Cursor = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_cursor-layer";
                parentEl.appendChild(this.element);

                if (isIE8 === undefined) isIE8 = !("opacity" in this.element.style);

                this.isVisible = false;
                this.isBlinking = true;
                this.blinkInterval = 1000;
                this.smoothBlinking = false;

                this.cursors = [];
                this.cursor = this.addCursor();
                dom.addCssClass(this.element, "ace_hidden-cursors");
                this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
            };

            (function () {

                this.$updateVisibility = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.visibility = val ? "" : "hidden";
                };
                this.$updateOpacity = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.opacity = val ? "" : "0";
                };

                this.$padding = 0;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                };

                this.setSession = function (session) {
                    this.session = session;
                };

                this.setBlinking = function (blinking) {
                    if (blinking != this.isBlinking) {
                        this.isBlinking = blinking;
                        this.restartTimer();
                    }
                };

                this.setBlinkInterval = function (blinkInterval) {
                    if (blinkInterval != this.blinkInterval) {
                        this.blinkInterval = blinkInterval;
                        this.restartTimer();
                    }
                };

                this.setSmoothBlinking = function (smoothBlinking) {
                    if (smoothBlinking != this.smoothBlinking && !isIE8) {
                        this.smoothBlinking = smoothBlinking;
                        dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                        this.$updateCursors(true);
                        this.$updateCursors = this.$updateOpacity.bind(this);
                        this.restartTimer();
                    }
                };

                this.addCursor = function () {
                    var el = dom.createElement("div");
                    el.className = "ace_cursor";
                    this.element.appendChild(el);
                    this.cursors.push(el);
                    return el;
                };

                this.removeCursor = function () {
                    if (this.cursors.length > 1) {
                        var el = this.cursors.pop();
                        el.parentNode.removeChild(el);
                        return el;
                    }
                };

                this.hideCursor = function () {
                    this.isVisible = false;
                    dom.addCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.showCursor = function () {
                    this.isVisible = true;
                    dom.removeCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.restartTimer = function () {
                    var update = this.$updateCursors;
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                    if (this.smoothBlinking) {
                        dom.removeCssClass(this.element, "ace_smooth-blinking");
                    }

                    update(true);

                    if (!this.isBlinking || !this.blinkInterval || !this.isVisible) return;

                    if (this.smoothBlinking) {
                        setTimeout(function () {
                            dom.addCssClass(this.element, "ace_smooth-blinking");
                        }.bind(this));
                    }

                    var blink = function () {
                        this.timeoutId = setTimeout(function () {
                            update(false);
                        }, 0.6 * this.blinkInterval);
                    }.bind(this);

                    this.intervalId = setInterval(function () {
                        update(true);
                        blink();
                    }, this.blinkInterval);

                    blink();
                };

                this.getPixelPosition = function (position, onScreen) {
                    if (!this.config || !this.session) return { left: 0, top: 0 };

                    if (!position) position = this.session.selection.getCursor();
                    var pos = this.session.documentToScreenPosition(position);
                    var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
                    var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;

                    return { left: cursorLeft, top: cursorTop };
                };

                this.update = function (config) {
                    this.config = config;

                    var selections = this.session.$selectionMarkers;
                    var i = 0,
                        cursorIndex = 0;

                    if (selections === undefined || selections.length === 0) {
                        selections = [{ cursor: null }];
                    }

                    for (var i = 0, n = selections.length; i < n; i++) {
                        var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                        if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                            continue;
                        }

                        var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

                        if (!this.drawCursor) {
                            style.left = pixelPos.left + "px";
                            style.top = pixelPos.top + "px";
                            style.width = config.characterWidth + "px";
                            style.height = config.lineHeight + "px";
                        } else {
                            this.drawCursor(style, pixelPos, config, selections[i], this.session);
                        }
                    }
                    while (this.cursors.length > cursorIndex) this.removeCursor();

                    var overwrite = this.session.getOverwrite();
                    this.$setOverwrite(overwrite);
                    this.$pixelPos = pixelPos;
                    this.restartTimer();
                };

                this.drawCursor = null;

                this.$setOverwrite = function (overwrite) {
                    if (overwrite != this.overwrite) {
                        this.overwrite = overwrite;
                        if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");else dom.removeCssClass(this.element, "ace_overwrite-cursors");
                    }
                };

                this.destroy = function () {
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                };
            }).call(Cursor.prototype);

            exports.Cursor = Cursor;
        });

        ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var event = require("./lib/event");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var MAX_SCROLL_H = 0x8000;
            var ScrollBar = function (parent) {
                this.element = dom.createElement("div");
                this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

                this.inner = dom.createElement("div");
                this.inner.className = "ace_scrollbar-inner";
                this.element.appendChild(this.inner);

                parent.appendChild(this.element);

                this.setVisible(false);
                this.skipEvent = false;

                event.addListener(this.element, "scroll", this.onScroll.bind(this));
                event.addListener(this.element, "mousedown", event.preventDefault);
            };

            (function () {
                oop.implement(this, EventEmitter);

                this.setVisible = function (isVisible) {
                    this.element.style.display = isVisible ? "" : "none";
                    this.isVisible = isVisible;
                    this.coeff = 1;
                };
            }).call(ScrollBar.prototype);
            var VScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollTop = 0;
                this.scrollHeight = 0;
                renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
                this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
            };

            oop.inherits(VScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-v';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollTop = this.element.scrollTop;
                        if (this.coeff != 1) {
                            var h = this.element.clientHeight / this.scrollHeight;
                            this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                        }
                        this._emit("scroll", { data: this.scrollTop });
                    }
                    this.skipEvent = false;
                };
                this.getWidth = function () {
                    return this.isVisible ? this.width : 0;
                };
                this.setHeight = function (height) {
                    this.element.style.height = height + "px";
                };
                this.setInnerHeight = this.setScrollHeight = function (height) {
                    this.scrollHeight = height;
                    if (height > MAX_SCROLL_H) {
                        this.coeff = MAX_SCROLL_H / height;
                        height = MAX_SCROLL_H;
                    } else if (this.coeff != 1) {
                        this.coeff = 1;
                    }
                    this.inner.style.height = height + "px";
                };
                this.setScrollTop = function (scrollTop) {
                    if (this.scrollTop != scrollTop) {
                        this.skipEvent = true;
                        this.scrollTop = scrollTop;
                        this.element.scrollTop = scrollTop * this.coeff;
                    }
                };
            }).call(VScrollBar.prototype);
            var HScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollLeft = 0;
                this.height = renderer.$scrollbarWidth;
                this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
            };

            oop.inherits(HScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-h';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollLeft = this.element.scrollLeft;
                        this._emit("scroll", { data: this.scrollLeft });
                    }
                    this.skipEvent = false;
                };
                this.getHeight = function () {
                    return this.isVisible ? this.height : 0;
                };
                this.setWidth = function (width) {
                    this.element.style.width = width + "px";
                };
                this.setInnerWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollLeft = function (scrollLeft) {
                    if (this.scrollLeft != scrollLeft) {
                        this.skipEvent = true;
                        this.scrollLeft = this.element.scrollLeft = scrollLeft;
                    }
                };
            }).call(HScrollBar.prototype);

            exports.ScrollBar = VScrollBar; // backward compatibility
            exports.ScrollBarV = VScrollBar; // backward compatibility
            exports.ScrollBarH = HScrollBar; // backward compatibility

            exports.VScrollBar = VScrollBar;
            exports.HScrollBar = HScrollBar;
        });

        ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var event = require("./lib/event");

            var RenderLoop = function (onRender, win) {
                this.onRender = onRender;
                this.pending = false;
                this.changes = 0;
                this.window = win || window;
            };

            (function () {

                this.schedule = function (change) {
                    this.changes = this.changes | change;
                    if (!this.pending && this.changes) {
                        this.pending = true;
                        var _self = this;
                        event.nextFrame(function () {
                            _self.pending = false;
                            var changes;
                            while (changes = _self.changes) {
                                _self.changes = 0;
                                _self.onRender(changes);
                            }
                        }, this.window);
                    }
                };
            }).call(RenderLoop.prototype);

            exports.RenderLoop = RenderLoop;
        });

        ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CHAR_COUNT = 0;

            var FontMetrics = exports.FontMetrics = function (parentEl) {
                this.el = dom.createElement("div");
                this.$setMeasureNodeStyles(this.el.style, true);

                this.$main = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$main.style);

                this.$measureNode = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$measureNode.style);

                this.el.appendChild(this.$main);
                this.el.appendChild(this.$measureNode);
                parentEl.appendChild(this.el);

                if (!CHAR_COUNT) this.$testFractionalRect();
                this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);

                this.$characterSize = { width: 0, height: 0 };
                this.checkForSizeChanges();
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$characterSize = { width: 0, height: 0 };

                this.$testFractionalRect = function () {
                    var el = dom.createElement("div");
                    this.$setMeasureNodeStyles(el.style);
                    el.style.width = "0.2px";
                    document.documentElement.appendChild(el);
                    var w = el.getBoundingClientRect().width;
                    if (w > 0 && w < 1) CHAR_COUNT = 50;else CHAR_COUNT = 100;
                    el.parentNode.removeChild(el);
                };

                this.$setMeasureNodeStyles = function (style, isRoot) {
                    style.width = style.height = "auto";
                    style.left = style.top = "0px";
                    style.visibility = "hidden";
                    style.position = "absolute";
                    style.whiteSpace = "pre";

                    if (useragent.isIE < 8) {
                        style["font-family"] = "inherit";
                    } else {
                        style.font = "inherit";
                    }
                    style.overflow = isRoot ? "hidden" : "visible";
                };

                this.checkForSizeChanges = function () {
                    var size = this.$measureSizes();
                    if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                        this.$measureNode.style.fontWeight = "bold";
                        var boldSize = this.$measureSizes();
                        this.$measureNode.style.fontWeight = "";
                        this.$characterSize = size;
                        this.charSizes = Object.create(null);
                        this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                        this._emit("changeCharacterSize", { data: size });
                    }
                };

                this.$pollSizeChanges = function () {
                    if (this.$pollSizeChangesTimer) return this.$pollSizeChangesTimer;
                    var self = this;
                    return this.$pollSizeChangesTimer = setInterval(function () {
                        self.checkForSizeChanges();
                    }, 500);
                };

                this.setPolling = function (val) {
                    if (val) {
                        this.$pollSizeChanges();
                    } else if (this.$pollSizeChangesTimer) {
                        clearInterval(this.$pollSizeChangesTimer);
                        this.$pollSizeChangesTimer = 0;
                    }
                };

                this.$measureSizes = function () {
                    if (CHAR_COUNT === 50) {
                        var rect = null;
                        try {
                            rect = this.$measureNode.getBoundingClientRect();
                        } catch (e) {
                            rect = { width: 0, height: 0 };
                        }
                        var size = {
                            height: rect.height,
                            width: rect.width / CHAR_COUNT
                        };
                    } else {
                        var size = {
                            height: this.$measureNode.clientHeight,
                            width: this.$measureNode.clientWidth / CHAR_COUNT
                        };
                    }
                    if (size.width === 0 || size.height === 0) return null;
                    return size;
                };

                this.$measureCharWidth = function (ch) {
                    this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
                    var rect = this.$main.getBoundingClientRect();
                    return rect.width / CHAR_COUNT;
                };

                this.getCharacterWidth = function (ch) {
                    var w = this.charSizes[ch];
                    if (w === undefined) {
                        w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                    }
                    return w;
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
                };
            }).call(FontMetrics.prototype);
        });

        ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var config = require("./config");
            var useragent = require("./lib/useragent");
            var GutterLayer = require("./layer/gutter").Gutter;
            var MarkerLayer = require("./layer/marker").Marker;
            var TextLayer = require("./layer/text").Text;
            var CursorLayer = require("./layer/cursor").Cursor;
            var HScrollBar = require("./scrollbar").HScrollBar;
            var VScrollBar = require("./scrollbar").VScrollBar;
            var RenderLoop = require("./renderloop").RenderLoop;
            var FontMetrics = require("./layer/font_metrics").FontMetrics;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";

            dom.importCssString(editorCss, "ace_editor.css");

            var VirtualRenderer = function (container, theme) {
                var _self = this;

                this.container = container || dom.createElement("div");
                this.$keepTextAreaAtCursor = !useragent.isOldIE;

                dom.addCssClass(this.container, "ace_editor");

                this.setTheme(theme);

                this.$gutter = dom.createElement("div");
                this.$gutter.className = "ace_gutter";
                this.container.appendChild(this.$gutter);

                this.scroller = dom.createElement("div");
                this.scroller.className = "ace_scroller";
                this.container.appendChild(this.scroller);

                this.content = dom.createElement("div");
                this.content.className = "ace_content";
                this.scroller.appendChild(this.content);

                this.$gutterLayer = new GutterLayer(this.$gutter);
                this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

                this.$markerBack = new MarkerLayer(this.content);

                var textLayer = this.$textLayer = new TextLayer(this.content);
                this.canvas = textLayer.element;

                this.$markerFront = new MarkerLayer(this.content);

                this.$cursorLayer = new CursorLayer(this.content);
                this.$horizScroll = false;
                this.$vScroll = false;

                this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
                this.scrollBarH = new HScrollBar(this.container, this);
                this.scrollBarV.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                });

                this.scrollTop = 0;
                this.scrollLeft = 0;

                this.cursorPos = {
                    row: 0,
                    column: 0
                };

                this.$fontMetrics = new FontMetrics(this.container);
                this.$textLayer.$setFontMetrics(this.$fontMetrics);
                this.$textLayer.addEventListener("changeCharacterSize", function (e) {
                    _self.updateCharacterSize();
                    _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                    _self._signal("changeCharacterSize", e);
                });

                this.$size = {
                    width: 0,
                    height: 0,
                    scrollerHeight: 0,
                    scrollerWidth: 0,
                    $dirty: true
                };

                this.layerConfig = {
                    width: 1,
                    padding: 0,
                    firstRow: 0,
                    firstRowScreen: 0,
                    lastRow: 0,
                    lineHeight: 0,
                    characterWidth: 0,
                    minHeight: 1,
                    maxHeight: 1,
                    offset: 0,
                    height: 1,
                    gutterOffset: 1
                };

                this.scrollMargin = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    v: 0,
                    h: 0
                };

                this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                this.$loop.schedule(this.CHANGE_FULL);

                this.updateCharacterSize();
                this.setPadding(4);
                config.resetOptions(this);
                config._emit("renderer", this);
            };

            (function () {

                this.CHANGE_CURSOR = 1;
                this.CHANGE_MARKER = 2;
                this.CHANGE_GUTTER = 4;
                this.CHANGE_SCROLL = 8;
                this.CHANGE_LINES = 16;
                this.CHANGE_TEXT = 32;
                this.CHANGE_SIZE = 64;
                this.CHANGE_MARKER_BACK = 128;
                this.CHANGE_MARKER_FRONT = 256;
                this.CHANGE_FULL = 512;
                this.CHANGE_H_SCROLL = 1024;

                oop.implement(this, EventEmitter);

                this.updateCharacterSize = function () {
                    if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                        this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                        this.setStyle("ace_nobold", !this.$allowBoldFonts);
                    }

                    this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
                    this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
                    this.$updatePrintMargin();
                };
                this.setSession = function (session) {
                    if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

                    this.session = session;
                    if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);

                    this.$cursorLayer.setSession(session);
                    this.$markerBack.setSession(session);
                    this.$markerFront.setSession(session);
                    this.$gutterLayer.setSession(session);
                    this.$textLayer.setSession(session);
                    if (!session) return;

                    this.$loop.schedule(this.CHANGE_FULL);
                    this.session.$setFontMetrics(this.$fontMetrics);
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;

                    this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                    this.onChangeNewLineMode();
                    this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
                };
                this.updateLines = function (firstRow, lastRow, force) {
                    if (lastRow === undefined) lastRow = Infinity;

                    if (!this.$changedLines) {
                        this.$changedLines = {
                            firstRow: firstRow,
                            lastRow: lastRow
                        };
                    } else {
                        if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;

                        if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
                    }
                    if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                        if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;else return;
                    }
                    if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
                    this.$loop.schedule(this.CHANGE_LINES);
                };

                this.onChangeNewLineMode = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                    this.$textLayer.$updateEolChar();
                };

                this.onChangeTabSize = function () {
                    this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
                    this.$textLayer.onChangeTabSize();
                };
                this.updateText = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                };
                this.updateFull = function (force) {
                    if (force) this.$renderChanges(this.CHANGE_FULL, true);else this.$loop.schedule(this.CHANGE_FULL);
                };
                this.updateFontSize = function () {
                    this.$textLayer.checkForSizeChanges();
                };

                this.$changes = 0;
                this.$updateSizeAsync = function () {
                    if (this.$loop.pending) this.$size.$dirty = true;else this.onResize();
                };
                this.onResize = function (force, gutterWidth, width, height) {
                    if (this.resizing > 2) return;else if (this.resizing > 0) this.resizing++;else this.resizing = force ? 1 : 0;
                    var el = this.container;
                    if (!height) height = el.clientHeight || el.scrollHeight;
                    if (!width) width = el.clientWidth || el.scrollWidth;
                    var changes = this.$updateCachedSize(force, gutterWidth, width, height);

                    if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;

                    if (force) this.$gutterLayer.$padding = null;

                    if (force) this.$renderChanges(changes | this.$changes, true);else this.$loop.schedule(changes | this.$changes);

                    if (this.resizing) this.resizing = 0;
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
                };

                this.$updateCachedSize = function (force, gutterWidth, width, height) {
                    height -= this.$extraHeight || 0;
                    var changes = 0;
                    var size = this.$size;
                    var oldSize = {
                        width: size.width,
                        height: size.height,
                        scrollerHeight: size.scrollerHeight,
                        scrollerWidth: size.scrollerWidth
                    };
                    if (height && (force || size.height != height)) {
                        size.height = height;
                        changes |= this.CHANGE_SIZE;

                        size.scrollerHeight = size.height;
                        if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
                        this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

                        changes = changes | this.CHANGE_SCROLL;
                    }

                    if (width && (force || size.width != width)) {
                        changes |= this.CHANGE_SIZE;
                        size.width = width;

                        if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

                        this.gutterWidth = gutterWidth;

                        this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
                        size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());

                        this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                        this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

                        if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= this.CHANGE_FULL;
                    }

                    size.$dirty = !width || !height;

                    if (changes) this._signal("resize", oldSize);

                    return changes;
                };

                this.onGutterResize = function () {
                    var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                    if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

                    if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else if (this.$size.$dirty) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else {
                        this.$computeLayerConfig();
                        this.$loop.schedule(this.CHANGE_MARKER);
                    }
                };
                this.adjustWrapLimit = function () {
                    var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                    var limit = Math.floor(availableWidth / this.characterWidth);
                    return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
                };
                this.setAnimatedScroll = function (shouldAnimate) {
                    this.setOption("animatedScroll", shouldAnimate);
                };
                this.getAnimatedScroll = function () {
                    return this.$animatedScroll;
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.setOption("showInvisibles", showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.getOption("showInvisibles");
                };
                this.getDisplayIndentGuides = function () {
                    return this.getOption("displayIndentGuides");
                };

                this.setDisplayIndentGuides = function (display) {
                    this.setOption("displayIndentGuides", display);
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.setOption("showPrintMargin", showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.getOption("showPrintMargin");
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.setOption("printMarginColumn", showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.getOption("printMarginColumn");
                };
                this.getShowGutter = function () {
                    return this.getOption("showGutter");
                };
                this.setShowGutter = function (show) {
                    return this.setOption("showGutter", show);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };

                this.setFadeFoldWidgets = function (show) {
                    this.setOption("fadeFoldWidgets", show);
                };

                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };

                this.$updateGutterLineHighlight = function () {
                    var pos = this.$cursorLayer.$pixelPos;
                    var height = this.layerConfig.lineHeight;
                    if (this.session.getUseWrapMode()) {
                        var cursor = this.session.selection.getCursor();
                        cursor.column = 0;
                        pos = this.$cursorLayer.getPixelPosition(cursor, true);
                        height *= this.session.getRowLength(cursor.row);
                    }
                    this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
                    this.$gutterLineHighlight.style.height = height + "px";
                };

                this.$updatePrintMargin = function () {
                    if (!this.$showPrintMargin && !this.$printMarginEl) return;

                    if (!this.$printMarginEl) {
                        var containerEl = dom.createElement("div");
                        containerEl.className = "ace_layer ace_print-margin-layer";
                        this.$printMarginEl = dom.createElement("div");
                        this.$printMarginEl.className = "ace_print-margin";
                        containerEl.appendChild(this.$printMarginEl);
                        this.content.insertBefore(containerEl, this.content.firstChild);
                    }

                    var style = this.$printMarginEl.style;
                    style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
                    style.visibility = this.$showPrintMargin ? "visible" : "hidden";

                    if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
                };
                this.getContainerElement = function () {
                    return this.container;
                };
                this.getMouseEventTarget = function () {
                    return this.scroller;
                };
                this.getTextAreaContainer = function () {
                    return this.container;
                };
                this.$moveTextAreaToCursor = function () {
                    if (!this.$keepTextAreaAtCursor) return;
                    var config = this.layerConfig;
                    var posTop = this.$cursorLayer.$pixelPos.top;
                    var posLeft = this.$cursorLayer.$pixelPos.left;
                    posTop -= config.offset;

                    var style = this.textarea.style;
                    var h = this.lineHeight;
                    if (posTop < 0 || posTop > config.height - h) {
                        style.top = style.left = "0";
                        return;
                    }

                    var w = this.characterWidth;
                    if (this.$composition) {
                        var val = this.textarea.value.replace(/^\x01+/, "");
                        w *= this.session.$getStringScreenWidth(val)[0] + 2;
                        h += 2;
                    }
                    posLeft -= this.scrollLeft;
                    if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;

                    posLeft += this.gutterWidth;
                    style.height = h + "px";
                    style.width = w + "px";
                    style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
                    style.top = Math.min(posTop, this.$size.height - h) + "px";
                };
                this.getFirstVisibleRow = function () {
                    return this.layerConfig.firstRow;
                };
                this.getFirstFullyVisibleRow = function () {
                    return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                };
                this.getLastFullyVisibleRow = function () {
                    var config = this.layerConfig;
                    var lastRow = config.lastRow;
                    var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
                    if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
                    return lastRow;
                };
                this.getLastVisibleRow = function () {
                    return this.layerConfig.lastRow;
                };

                this.$padding = null;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.$textLayer.setPadding(padding);
                    this.$cursorLayer.setPadding(padding);
                    this.$markerFront.setPadding(padding);
                    this.$markerBack.setPadding(padding);
                    this.$loop.schedule(this.CHANGE_FULL);
                    this.$updatePrintMargin();
                };

                this.setScrollMargin = function (top, bottom, left, right) {
                    var sm = this.scrollMargin;
                    sm.top = top | 0;
                    sm.bottom = bottom | 0;
                    sm.right = right | 0;
                    sm.left = left | 0;
                    sm.v = sm.top + sm.bottom;
                    sm.h = sm.left + sm.right;
                    if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
                    this.updateFull();
                };
                this.getHScrollBarAlwaysVisible = function () {
                    return this.$hScrollBarAlwaysVisible;
                };
                this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
                };
                this.getVScrollBarAlwaysVisible = function () {
                    return this.$vScrollBarAlwaysVisible;
                };
                this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
                };

                this.$updateScrollBarV = function () {
                    var scrollHeight = this.layerConfig.maxHeight;
                    var scrollerHeight = this.$size.scrollerHeight;
                    if (!this.$maxLines && this.$scrollPastEnd) {
                        scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                        if (this.scrollTop > scrollHeight - scrollerHeight) {
                            scrollHeight = this.scrollTop + scrollerHeight;
                            this.scrollBarV.scrollTop = null;
                        }
                    }
                    this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                    this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                };
                this.$updateScrollBarH = function () {
                    this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                    this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                };

                this.$frozen = false;
                this.freeze = function () {
                    this.$frozen = true;
                };

                this.unfreeze = function () {
                    this.$frozen = false;
                };

                this.$renderChanges = function (changes, force) {
                    if (this.$changes) {
                        changes |= this.$changes;
                        this.$changes = 0;
                    }
                    if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                        this.$changes |= changes;
                        return;
                    }
                    if (this.$size.$dirty) {
                        this.$changes |= changes;
                        return this.onResize(true);
                    }
                    if (!this.lineHeight) {
                        this.$textLayer.checkForSizeChanges();
                    }

                    this._signal("beforeRender");
                    var config = this.layerConfig;
                    if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
                        changes |= this.$computeLayerConfig();
                        if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                            var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                            if (st > 0) {
                                this.scrollTop = st;
                                changes = changes | this.CHANGE_SCROLL;
                                changes |= this.$computeLayerConfig();
                            }
                        }
                        config = this.layerConfig;
                        this.$updateScrollBarV();
                        if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
                        this.$gutterLayer.element.style.marginTop = -config.offset + "px";
                        this.content.style.marginTop = -config.offset + "px";
                        this.content.style.width = config.width + 2 * this.$padding + "px";
                        this.content.style.height = config.minHeight + "px";
                    }
                    if (changes & this.CHANGE_H_SCROLL) {
                        this.content.style.marginLeft = -this.scrollLeft + "px";
                        this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
                    }
                    if (changes & this.CHANGE_FULL) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this._signal("afterRender");
                        return;
                    }
                    if (changes & this.CHANGE_SCROLL) {
                        if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);else this.$textLayer.scrollLines(config);

                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this.$moveTextAreaToCursor();
                        this._signal("afterRender");
                        return;
                    }

                    if (changes & this.CHANGE_TEXT) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_LINES) {
                        if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    }

                    if (changes & this.CHANGE_CURSOR) {
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                        this.$markerFront.update(config);
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                        this.$markerBack.update(config);
                    }

                    this._signal("afterRender");
                };

                this.$autosize = function () {
                    var height = this.session.getScreenLength() * this.lineHeight;
                    var maxHeight = this.$maxLines * this.lineHeight;
                    var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
                    if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
                    if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
                    var vScroll = height > maxHeight;

                    if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                        if (vScroll != this.$vScroll) {
                            this.$vScroll = vScroll;
                            this.scrollBarV.setVisible(vScroll);
                        }

                        var w = this.container.clientWidth;
                        this.container.style.height = desiredHeight + "px";
                        this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                        this.desiredHeight = desiredHeight;

                        this._signal("autosize");
                    }
                };

                this.$computeLayerConfig = function () {
                    var session = this.session;
                    var size = this.$size;

                    var hideScrollbars = size.height <= 2 * this.lineHeight;
                    var screenLines = this.session.getScreenLength();
                    var maxHeight = screenLines * this.lineHeight;

                    var longestLine = this.$getLongestLine();

                    var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);

                    var hScrollChanged = this.$horizScroll !== horizScroll;
                    if (hScrollChanged) {
                        this.$horizScroll = horizScroll;
                        this.scrollBarH.setVisible(horizScroll);
                    }
                    var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
                    if (this.$maxLines && this.lineHeight > 1) this.$autosize();

                    var offset = this.scrollTop % this.lineHeight;
                    var minHeight = size.scrollerHeight + this.lineHeight;

                    var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
                    maxHeight += scrollPastEnd;

                    var sm = this.scrollMargin;
                    this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

                    this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

                    var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
                    var vScrollChanged = vScrollBefore !== vScroll;
                    if (vScrollChanged) {
                        this.$vScroll = vScroll;
                        this.scrollBarV.setVisible(vScroll);
                    }

                    var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                    var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                    var lastRow = firstRow + lineCount;
                    var firstRowScreen, firstRowHeight;
                    var lineHeight = this.lineHeight;
                    firstRow = session.screenToDocumentRow(firstRow, 0);
                    var foldLine = session.getFoldLine(firstRow);
                    if (foldLine) {
                        firstRow = foldLine.start.row;
                    }

                    firstRowScreen = session.documentToScreenRow(firstRow, 0);
                    firstRowHeight = session.getRowLength(firstRow) * lineHeight;

                    lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                    minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;

                    offset = this.scrollTop - firstRowScreen * lineHeight;

                    var changes = 0;
                    if (this.layerConfig.width != longestLine) changes = this.CHANGE_H_SCROLL;
                    if (hScrollChanged || vScrollChanged) {
                        changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                        this._signal("scrollbarVisibilityChanged");
                        if (vScrollChanged) longestLine = this.$getLongestLine();
                    }

                    this.layerConfig = {
                        width: longestLine,
                        padding: this.$padding,
                        firstRow: firstRow,
                        firstRowScreen: firstRowScreen,
                        lastRow: lastRow,
                        lineHeight: lineHeight,
                        characterWidth: this.characterWidth,
                        minHeight: minHeight,
                        maxHeight: maxHeight,
                        offset: offset,
                        gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                        height: this.$size.scrollerHeight
                    };

                    return changes;
                };

                this.$updateLines = function () {
                    var firstRow = this.$changedLines.firstRow;
                    var lastRow = this.$changedLines.lastRow;
                    this.$changedLines = null;

                    var layerConfig = this.layerConfig;

                    if (firstRow > layerConfig.lastRow + 1) {
                        return;
                    }
                    if (lastRow < layerConfig.firstRow) {
                        return;
                    }
                    if (lastRow === Infinity) {
                        if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                        this.$textLayer.update(layerConfig);
                        return;
                    }
                    this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                    return true;
                };

                this.$getLongestLine = function () {
                    var charCount = this.session.getScreenWidth();
                    if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;

                    return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                };
                this.updateFrontMarkers = function () {
                    this.$markerFront.setMarkers(this.session.getMarkers(true));
                    this.$loop.schedule(this.CHANGE_MARKER_FRONT);
                };
                this.updateBackMarkers = function () {
                    this.$markerBack.setMarkers(this.session.getMarkers());
                    this.$loop.schedule(this.CHANGE_MARKER_BACK);
                };
                this.addGutterDecoration = function (row, className) {
                    this.$gutterLayer.addGutterDecoration(row, className);
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$gutterLayer.removeGutterDecoration(row, className);
                };
                this.updateBreakpoints = function (rows) {
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.setAnnotations = function (annotations) {
                    this.$gutterLayer.setAnnotations(annotations);
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.updateCursor = function () {
                    this.$loop.schedule(this.CHANGE_CURSOR);
                };
                this.hideCursor = function () {
                    this.$cursorLayer.hideCursor();
                };
                this.showCursor = function () {
                    this.$cursorLayer.showCursor();
                };

                this.scrollSelectionIntoView = function (anchor, lead, offset) {
                    this.scrollCursorIntoView(anchor, offset);
                    this.scrollCursorIntoView(lead, offset);
                };
                this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
                    if (this.$size.scrollerHeight === 0) return;

                    var pos = this.$cursorLayer.getPixelPosition(cursor);

                    var left = pos.left;
                    var top = pos.top;

                    var topMargin = $viewMargin && $viewMargin.top || 0;
                    var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

                    var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

                    if (scrollTop + topMargin > top) {
                        if (offset && scrollTop + topMargin > top + this.lineHeight) top -= offset * this.$size.scrollerHeight;
                        if (top === 0) top = -this.scrollMargin.top;
                        this.session.setScrollTop(top);
                    } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                        if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight) top += offset * this.$size.scrollerHeight;
                        this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
                    }

                    var scrollLeft = this.scrollLeft;

                    if (scrollLeft > left) {
                        if (left < this.$padding + 2 * this.layerConfig.characterWidth) left = -this.scrollMargin.left;
                        this.session.setScrollLeft(left);
                    } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                        this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
                    } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                        this.session.setScrollLeft(0);
                    }
                };
                this.getScrollTop = function () {
                    return this.session.getScrollTop();
                };
                this.getScrollLeft = function () {
                    return this.session.getScrollLeft();
                };
                this.getScrollTopRow = function () {
                    return this.scrollTop / this.lineHeight;
                };
                this.getScrollBottomRow = function () {
                    return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                };
                this.scrollToRow = function (row) {
                    this.session.setScrollTop(row * this.lineHeight);
                };

                this.alignCursor = function (cursor, alignment) {
                    if (typeof cursor == "number") cursor = { row: cursor, column: 0 };

                    var pos = this.$cursorLayer.getPixelPosition(cursor);
                    var h = this.$size.scrollerHeight - this.lineHeight;
                    var offset = pos.top - h * (alignment || 0);

                    this.session.setScrollTop(offset);
                    return offset;
                };

                this.STEPS = 8;
                this.$calcSteps = function (fromValue, toValue) {
                    var i = 0;
                    var l = this.STEPS;
                    var steps = [];

                    var func = function (t, x_min, dx) {
                        return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                    };

                    for (i = 0; i < l; ++i) steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

                    return steps;
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
                    var offset = pos.top;
                    if (center) offset -= this.$size.scrollerHeight / 2;

                    var initialScroll = this.scrollTop;
                    this.session.setScrollTop(offset);
                    if (animate !== false) this.animateScrolling(initialScroll, callback);
                };

                this.animateScrolling = function (fromValue, callback) {
                    var toValue = this.scrollTop;
                    if (!this.$animatedScroll) return;
                    var _self = this;

                    if (fromValue == toValue) return;

                    if (this.$scrollAnimation) {
                        var oldSteps = this.$scrollAnimation.steps;
                        if (oldSteps.length) {
                            fromValue = oldSteps[0];
                            if (fromValue == toValue) return;
                        }
                    }

                    var steps = _self.$calcSteps(fromValue, toValue);
                    this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };

                    clearInterval(this.$timer);

                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                    this.$timer = setInterval(function () {
                        if (steps.length) {
                            _self.session.setScrollTop(steps.shift());
                            _self.session.$scrollTop = toValue;
                        } else if (toValue != null) {
                            _self.session.$scrollTop = -1;
                            _self.session.setScrollTop(toValue);
                            toValue = null;
                        } else {
                            _self.$timer = clearInterval(_self.$timer);
                            _self.$scrollAnimation = null;
                            callback && callback();
                        }
                    }, 10);
                };
                this.scrollToY = function (scrollTop) {
                    if (this.scrollTop !== scrollTop) {
                        this.$loop.schedule(this.CHANGE_SCROLL);
                        this.scrollTop = scrollTop;
                    }
                };
                this.scrollToX = function (scrollLeft) {
                    if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
                    this.$loop.schedule(this.CHANGE_H_SCROLL);
                };
                this.scrollTo = function (x, y) {
                    this.session.setScrollTop(y);
                    this.session.setScrollLeft(y);
                };
                this.scrollBy = function (deltaX, deltaY) {
                    deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                    deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                };
                this.isScrollableBy = function (deltaX, deltaY) {
                    if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
                    if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
                    if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
                    if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
                };

                this.pixelToScreenCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
                    var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                    var col = Math.round(offset);

                    return { row: row, column: col, side: offset - col > 0 ? 1 : -1 };
                };

                this.screenToTextCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);

                    var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

                    return this.session.screenToDocumentPosition(row, Math.max(col, 0));
                };
                this.textToScreenCoordinates = function (row, column) {
                    var canvasPos = this.scroller.getBoundingClientRect();
                    var pos = this.session.documentToScreenPosition(row, column);

                    var x = this.$padding + Math.round(pos.column * this.characterWidth);
                    var y = pos.row * this.lineHeight;

                    return {
                        pageX: canvasPos.left + x - this.scrollLeft,
                        pageY: canvasPos.top + y - this.scrollTop
                    };
                };
                this.visualizeFocus = function () {
                    dom.addCssClass(this.container, "ace_focus");
                };
                this.visualizeBlur = function () {
                    dom.removeCssClass(this.container, "ace_focus");
                };
                this.showComposition = function (position) {
                    if (!this.$composition) this.$composition = {
                        keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                        cssText: this.textarea.style.cssText
                    };

                    this.$keepTextAreaAtCursor = true;
                    dom.addCssClass(this.textarea, "ace_composition");
                    this.textarea.style.cssText = "";
                    this.$moveTextAreaToCursor();
                };
                this.setCompositionText = function (text) {
                    this.$moveTextAreaToCursor();
                };
                this.hideComposition = function () {
                    if (!this.$composition) return;

                    dom.removeCssClass(this.textarea, "ace_composition");
                    this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
                    this.textarea.style.cssText = this.$composition.cssText;
                    this.$composition = null;
                };
                this.setTheme = function (theme, cb) {
                    var _self = this;
                    this.$themeId = theme;
                    _self._dispatchEvent('themeChange', { theme: theme });

                    if (!theme || typeof theme == "string") {
                        var moduleName = theme || this.$options.theme.initialValue;
                        config.loadModule(["theme", moduleName], afterLoad);
                    } else {
                        afterLoad(theme);
                    }

                    function afterLoad(module) {
                        if (_self.$themeId != theme) return cb && cb();
                        if (!module || !module.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
                        dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);

                        if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);

                        var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                        if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
                        _self.$theme = module.cssClass;

                        _self.theme = module;
                        dom.addCssClass(_self.container, module.cssClass);
                        dom.setCssClass(_self.container, "ace_dark", module.isDark);
                        if (_self.$size) {
                            _self.$size.width = 0;
                            _self.$updateSizeAsync();
                        }

                        _self._dispatchEvent('themeLoaded', { theme: module });
                        cb && cb();
                    }
                };
                this.getTheme = function () {
                    return this.$themeId;
                };
                this.setStyle = function (style, include) {
                    dom.setCssClass(this.container, style, include !== false);
                };
                this.unsetStyle = function (style) {
                    dom.removeCssClass(this.container, style);
                };

                this.setCursorStyle = function (style) {
                    if (this.scroller.style.cursor != style) this.scroller.style.cursor = style;
                };
                this.setMouseCursor = function (cursorStyle) {
                    this.scroller.style.cursor = cursorStyle;
                };
                this.destroy = function () {
                    this.$textLayer.destroy();
                    this.$cursorLayer.destroy();
                };
            }).call(VirtualRenderer.prototype);

            config.defineOptions(VirtualRenderer.prototype, "renderer", {
                animatedScroll: { initialValue: false },
                showInvisibles: {
                    set: function (value) {
                        if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: false
                },
                showPrintMargin: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: true
                },
                printMarginColumn: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: 80
                },
                printMargin: {
                    set: function (val) {
                        if (typeof val == "number") this.$printMarginColumn = val;
                        this.$showPrintMargin = !!val;
                        this.$updatePrintMargin();
                    },
                    get: function () {
                        return this.$showPrintMargin && this.$printMarginColumn;
                    }
                },
                showGutter: {
                    set: function (show) {
                        this.$gutter.style.display = show ? "block" : "none";
                        this.$loop.schedule(this.CHANGE_FULL);
                        this.onGutterResize();
                    },
                    initialValue: true
                },
                fadeFoldWidgets: {
                    set: function (show) {
                        dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
                    },
                    initialValue: false
                },
                showFoldWidgets: {
                    set: function (show) {
                        this.$gutterLayer.setShowFoldWidgets(show);
                    },
                    initialValue: true
                },
                showLineNumbers: {
                    set: function (show) {
                        this.$gutterLayer.setShowLineNumbers(show);
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    },
                    initialValue: true
                },
                displayIndentGuides: {
                    set: function (show) {
                        if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: true
                },
                highlightGutterLine: {
                    set: function (shouldHighlight) {
                        if (!this.$gutterLineHighlight) {
                            this.$gutterLineHighlight = dom.createElement("div");
                            this.$gutterLineHighlight.className = "ace_gutter-active-line";
                            this.$gutter.appendChild(this.$gutterLineHighlight);
                            return;
                        }

                        this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
                        if (this.$cursorLayer.$pixelPos) this.$updateGutterLineHighlight();
                    },
                    initialValue: false,
                    value: true
                },
                hScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                vScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                fontSize: {
                    set: function (size) {
                        if (typeof size == "number") size = size + "px";
                        this.container.style.fontSize = size;
                        this.updateFontSize();
                    },
                    initialValue: 12
                },
                fontFamily: {
                    set: function (name) {
                        this.container.style.fontFamily = name;
                        this.updateFontSize();
                    }
                },
                maxLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                minLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                maxPixelHeight: {
                    set: function (val) {
                        this.updateFull();
                    },
                    initialValue: 0
                },
                scrollPastEnd: {
                    set: function (val) {
                        val = +val || 0;
                        if (this.$scrollPastEnd == val) return;
                        this.$scrollPastEnd = val;
                        this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: 0,
                    handlesSet: true
                },
                fixedWidthGutter: {
                    set: function (val) {
                        this.$gutterLayer.$fixedWidth = !!val;
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    }
                },
                theme: {
                    set: function (val) {
                        this.setTheme(val);
                    },
                    get: function () {
                        return this.$themeId || this.theme;
                    },
                    initialValue: "./theme/textmate",
                    handlesSet: true
                }
            });

            exports.VirtualRenderer = VirtualRenderer;
        });

        ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var net = require("../lib/net");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;
            var config = require("../config");

            var WorkerClient = function (topLevelNamespaces, mod, classname, workerUrl) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.onMessage = this.onMessage.bind(this);
                if (require.nameToUrl && !require.toUrl) require.toUrl = require.nameToUrl;

                if (config.get("packaged") || !require.toUrl) {
                    workerUrl = workerUrl || config.moduleUrl(mod, "worker");
                } else {
                    var normalizePath = this.$normalizePath;
                    workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

                    var tlns = {};
                    topLevelNamespaces.forEach(function (ns) {
                        tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                    });
                }

                try {
                    this.$worker = new Worker(workerUrl);
                } catch (e) {
                    if (e instanceof window.DOMException) {
                        var blob = this.$workerBlob(workerUrl);
                        var URL = window.URL || window.webkitURL;
                        var blobURL = URL.createObjectURL(blob);

                        this.$worker = new Worker(blobURL);
                        URL.revokeObjectURL(blobURL);
                    } else {
                        throw e;
                    }
                }
                this.$worker.postMessage({
                    init: true,
                    tlns: tlns,
                    module: mod,
                    classname: classname
                });

                this.callbackId = 1;
                this.callbacks = {};

                this.$worker.onmessage = this.onMessage;
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.onMessage = function (e) {
                    var msg = e.data;
                    switch (msg.type) {
                        case "event":
                            this._signal(msg.name, { data: msg.data });
                            break;
                        case "call":
                            var callback = this.callbacks[msg.id];
                            if (callback) {
                                callback(msg.data);
                                delete this.callbacks[msg.id];
                            }
                            break;
                        case "error":
                            this.reportError(msg.data);
                            break;
                        case "log":
                            window.console && console.log && console.log.apply(console, msg.data);
                            break;
                    }
                };

                this.reportError = function (err) {
                    window.console && console.error && console.error(err);
                };

                this.$normalizePath = function (path) {
                    return net.qualifyURL(path);
                };

                this.terminate = function () {
                    this._signal("terminate", {});
                    this.deltaQueue = null;
                    this.$worker.terminate();
                    this.$worker = null;
                    if (this.$doc) this.$doc.off("change", this.changeListener);
                    this.$doc = null;
                };

                this.send = function (cmd, args) {
                    this.$worker.postMessage({ command: cmd, args: args });
                };

                this.call = function (cmd, args, callback) {
                    if (callback) {
                        var id = this.callbackId++;
                        this.callbacks[id] = callback;
                        args.push(id);
                    }
                    this.send(cmd, args);
                };

                this.emit = function (event, data) {
                    try {
                        this.$worker.postMessage({ event: event, data: { data: data.data } });
                    } catch (ex) {
                        console.error(ex.stack);
                    }
                };

                this.attachToDocument = function (doc) {
                    if (this.$doc) this.terminate();

                    this.$doc = doc;
                    this.call("setValue", [doc.getValue()]);
                    doc.on("change", this.changeListener);
                };

                this.changeListener = function (delta) {
                    if (!this.deltaQueue) {
                        this.deltaQueue = [];
                        setTimeout(this.$sendDeltaQueue, 0);
                    }
                    if (delta.action == "insert") this.deltaQueue.push(delta.start, delta.lines);else this.deltaQueue.push(delta.start, delta.end);
                };

                this.$sendDeltaQueue = function () {
                    var q = this.deltaQueue;
                    if (!q) return;
                    this.deltaQueue = null;
                    if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                        this.call("setValue", [this.$doc.getValue()]);
                    } else this.emit("change", { data: q });
                };

                this.$workerBlob = function (workerUrl) {
                    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
                    try {
                        return new Blob([script], { "type": "application/javascript" });
                    } catch (e) {
                        // Backwards-compatibility
                        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
                        var blobBuilder = new BlobBuilder();
                        blobBuilder.append(script);
                        return blobBuilder.getBlob("application/javascript");
                    }
                };
            }).call(WorkerClient.prototype);

            var UIWorkerClient = function (topLevelNamespaces, mod, classname) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.callbackId = 1;
                this.callbacks = {};
                this.messageBuffer = [];

                var main = null;
                var emitSync = false;
                var sender = Object.create(EventEmitter);
                var _self = this;

                this.$worker = {};
                this.$worker.terminate = function () {};
                this.$worker.postMessage = function (e) {
                    _self.messageBuffer.push(e);
                    if (main) {
                        if (emitSync) setTimeout(processNext);else processNext();
                    }
                };
                this.setEmitSync = function (val) {
                    emitSync = val;
                };

                var processNext = function () {
                    var msg = _self.messageBuffer.shift();
                    if (msg.command) main[msg.command].apply(main, msg.args);else if (msg.event) sender._signal(msg.event, msg.data);
                };

                sender.postMessage = function (msg) {
                    _self.onMessage({ data: msg });
                };
                sender.callback = function (data, callbackId) {
                    this.postMessage({ type: "call", id: callbackId, data: data });
                };
                sender.emit = function (name, data) {
                    this.postMessage({ type: "event", name: name, data: data });
                };

                config.loadModule(["worker", mod], function (Main) {
                    main = new Main[classname](sender);
                    while (_self.messageBuffer.length) processNext();
                });
            };

            UIWorkerClient.prototype = WorkerClient.prototype;

            exports.UIWorkerClient = UIWorkerClient;
            exports.WorkerClient = WorkerClient;
        });

        ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var oop = require("./lib/oop");

            var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
                var _self = this;
                this.length = length;
                this.session = session;
                this.doc = session.getDocument();
                this.mainClass = mainClass;
                this.othersClass = othersClass;
                this.$onUpdate = this.onUpdate.bind(this);
                this.doc.on("change", this.$onUpdate);
                this.$others = others;

                this.$onCursorChange = function () {
                    setTimeout(function () {
                        _self.onCursorChange();
                    });
                };

                this.$pos = pos;
                var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
                this.$undoStackDepth = undoStack.length;
                this.setup();

                session.selection.on("changeCursor", this.$onCursorChange);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setup = function () {
                    var _self = this;
                    var doc = this.doc;
                    var session = this.session;

                    this.selectionBefore = session.selection.toJSON();
                    if (session.selection.inMultiSelectMode) session.selection.toSingleRange();

                    this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
                    var pos = this.pos;
                    pos.$insertRight = true;
                    pos.detach();
                    pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
                    this.others = [];
                    this.$others.forEach(function (other) {
                        var anchor = doc.createAnchor(other.row, other.column);
                        anchor.$insertRight = true;
                        anchor.detach();
                        _self.others.push(anchor);
                    });
                    session.setUndoSelect(false);
                };
                this.showOtherMarkers = function () {
                    if (this.othersActive) return;
                    var session = this.session;
                    var _self = this;
                    this.othersActive = true;
                    this.others.forEach(function (anchor) {
                        anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
                    });
                };
                this.hideOtherMarkers = function () {
                    if (!this.othersActive) return;
                    this.othersActive = false;
                    for (var i = 0; i < this.others.length; i++) {
                        this.session.removeMarker(this.others[i].markerId);
                    }
                };
                this.onUpdate = function (delta) {
                    if (this.$updating) return this.updateAnchors(delta);

                    var range = delta;
                    if (range.start.row !== range.end.row) return;
                    if (range.start.row !== this.pos.row) return;
                    this.$updating = true;
                    var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
                    var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
                    var distanceFromStart = range.start.column - this.pos.column;

                    this.updateAnchors(delta);

                    if (inMainRange) this.length += lengthDiff;

                    if (inMainRange && !this.session.$fromUndo) {
                        if (delta.action === 'insert') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.insertMergedLines(newPos, delta.lines);
                            }
                        } else if (delta.action === 'remove') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                            }
                        }
                    }

                    this.$updating = false;
                    this.updateMarkers();
                };

                this.updateAnchors = function (delta) {
                    this.pos.onChange(delta);
                    for (var i = this.others.length; i--;) this.others[i].onChange(delta);
                    this.updateMarkers();
                };

                this.updateMarkers = function () {
                    if (this.$updating) return;
                    var _self = this;
                    var session = this.session;
                    var updateMarker = function (pos, className) {
                        session.removeMarker(pos.markerId);
                        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
                    };
                    updateMarker(this.pos, this.mainClass);
                    for (var i = this.others.length; i--;) updateMarker(this.others[i], this.othersClass);
                };

                this.onCursorChange = function (event) {
                    if (this.$updating || !this.session) return;
                    var pos = this.session.selection.getCursor();
                    if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                        this.showOtherMarkers();
                        this._emit("cursorEnter", event);
                    } else {
                        this.hideOtherMarkers();
                        this._emit("cursorLeave", event);
                    }
                };
                this.detach = function () {
                    this.session.removeMarker(this.pos && this.pos.markerId);
                    this.hideOtherMarkers();
                    this.doc.removeEventListener("change", this.$onUpdate);
                    this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
                    this.session.setUndoSelect(true);
                    this.session = null;
                };
                this.cancel = function () {
                    if (this.$undoStackDepth === -1) return;
                    var undoManager = this.session.getUndoManager();
                    var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
                    for (var i = 0; i < undosRequired; i++) {
                        undoManager.undo(true);
                    }
                    if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
                };
            }).call(PlaceHolder.prototype);

            exports.PlaceHolder = PlaceHolder;
        });

        ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }

            function onMouseDown(e) {
                var ev = e.domEvent;
                var alt = ev.altKey;
                var shift = ev.shiftKey;
                var ctrl = ev.ctrlKey;
                var accel = e.getAccelKey();
                var button = e.getButton();

                if (ctrl && useragent.isMac) button = ev.button;

                if (e.editor.inMultiSelectMode && button == 2) {
                    e.editor.textInput.onContextMenu(e.domEvent);
                    return;
                }

                if (!ctrl && !alt && !accel) {
                    if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
                    return;
                }

                if (button !== 0) return;

                var editor = e.editor;
                var selection = editor.selection;
                var isMultiSelect = editor.inMultiSelectMode;
                var pos = e.getDocumentPosition();
                var cursor = selection.getCursor();
                var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);

                var mouseX = e.x,
                    mouseY = e.y;
                var onMouseSelection = function (e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                };

                var session = editor.session;
                var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var screenCursor = screenAnchor;

                var selectionMode;
                if (editor.$mouseHandler.$enableJumpToDef) {
                    if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
                } else {
                    if (accel && !alt) {
                        selectionMode = "add";
                        if (!isMultiSelect && shift) return;
                    } else if (alt && editor.$blockSelectEnabled) {
                        selectionMode = "block";
                    }
                }

                if (selectionMode && useragent.isMac && ev.ctrlKey) {
                    editor.$mouseHandler.cancelContextMenu();
                }

                if (selectionMode == "add") {
                    if (!isMultiSelect && inSelection) return; // dragging

                    if (!isMultiSelect) {
                        var range = selection.toOrientedRange();
                        editor.addSelectionMarker(range);
                    }

                    var oldRange = selection.rangeList.rangeAtPoint(pos);

                    editor.$blockScrolling++;
                    editor.inVirtualSelectionMode = true;

                    if (shift) {
                        oldRange = null;
                        range = selection.ranges[0] || range;
                        editor.removeSelectionMarker(range);
                    }
                    editor.once("mouseup", function () {
                        var tmpSel = selection.toOrientedRange();

                        if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);else {
                            if (shift) {
                                selection.substractPoint(range.cursor);
                            } else if (range) {
                                editor.removeSelectionMarker(range);
                                selection.addRange(range);
                            }
                            selection.addRange(tmpSel);
                        }
                        editor.$blockScrolling--;
                        editor.inVirtualSelectionMode = false;
                    });
                } else if (selectionMode == "block") {
                    e.stop();
                    editor.inVirtualSelectionMode = true;
                    var initialRange;
                    var rectSel = [];
                    var blockSelect = function () {
                        var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                        var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

                        if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
                        screenCursor = newCursor;

                        editor.$blockScrolling++;
                        editor.selection.moveToPosition(cursor);
                        editor.renderer.scrollCursorIntoView();

                        editor.removeSelectionMarkers(rectSel);
                        rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                        if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                        rectSel.forEach(editor.addSelectionMarker, editor);
                        editor.updateSelectionMarkers();
                        editor.$blockScrolling--;
                    };
                    editor.$blockScrolling++;
                    if (isMultiSelect && !accel) {
                        selection.toSingleRange();
                    } else if (!isMultiSelect && accel) {
                        initialRange = selection.toOrientedRange();
                        editor.addSelectionMarker(initialRange);
                    }

                    if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);else selection.moveToPosition(pos);
                    editor.$blockScrolling--;

                    screenCursor = { row: -1, column: -1 };

                    var onMouseSelectionEnd = function (e) {
                        clearInterval(timerId);
                        editor.removeSelectionMarkers(rectSel);
                        if (!rectSel.length) rectSel = [selection.toOrientedRange()];
                        editor.$blockScrolling++;
                        if (initialRange) {
                            editor.removeSelectionMarker(initialRange);
                            selection.toSingleRange(initialRange);
                        }
                        for (var i = 0; i < rectSel.length; i++) selection.addRange(rectSel[i]);
                        editor.inVirtualSelectionMode = false;
                        editor.$mouseHandler.$clickSelection = null;
                        editor.$blockScrolling--;
                    };

                    var onSelectionInterval = blockSelect;

                    event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
                    var timerId = setInterval(function () {
                        onSelectionInterval();
                    }, 20);

                    return e.preventDefault();
                }
            }

            exports.onMouseDown = onMouseDown;
        });

        ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function (require, exports, module) {
            exports.defaultCommands = [{
                name: "addCursorAbove",
                exec: function (editor) {
                    editor.selectMoreLines(-1);
                },
                bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelow",
                exec: function (editor) {
                    editor.selectMoreLines(1);
                },
                bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorAboveSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelowSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreBefore",
                exec: function (editor) {
                    editor.selectMore(-1);
                },
                bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreAfter",
                exec: function (editor) {
                    editor.selectMore(1);
                },
                bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextBefore",
                exec: function (editor) {
                    editor.selectMore(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextAfter",
                exec: function (editor) {
                    editor.selectMore(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "splitIntoLines",
                exec: function (editor) {
                    editor.multiSelect.splitIntoLines();
                },
                bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
                readOnly: true
            }, {
                name: "alignCursors",
                exec: function (editor) {
                    editor.alignCursors();
                },
                bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
                scrollIntoView: "cursor"
            }, {
                name: "findAll",
                exec: function (editor) {
                    editor.findAll();
                },
                bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
                scrollIntoView: "cursor",
                readOnly: true
            }];
            exports.multiSelectCommands = [{
                name: "singleSelection",
                bindKey: "esc",
                exec: function (editor) {
                    editor.exitMultiSelectMode();
                },
                scrollIntoView: "cursor",
                readOnly: true,
                isAvailable: function (editor) {
                    return editor && editor.inMultiSelectMode;
                }
            }];

            var HashHandler = require("../keyboard/hash_handler").HashHandler;
            exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
        });

        ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function (require, exports, module) {

            var RangeList = require("./range_list").RangeList;
            var Range = require("./range").Range;
            var Selection = require("./selection").Selection;
            var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
            var event = require("./lib/event");
            var lang = require("./lib/lang");
            var commands = require("./commands/multi_select_commands");
            exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
            var Search = require("./search").Search;
            var search = new Search();

            function find(session, needle, dir) {
                search.$options.wrap = true;
                search.$options.needle = needle;
                search.$options.backwards = dir == -1;
                return search.find(session);
            }
            var EditSession = require("./edit_session").EditSession;
            (function () {
                this.getSelectionMarkers = function () {
                    return this.$selectionMarkers;
                };
            }).call(EditSession.prototype);
            (function () {
                this.ranges = null;
                this.rangeList = null;
                this.addRange = function (range, $blockChangeEvents) {
                    if (!range) return;

                    if (!this.inMultiSelectMode && this.rangeCount === 0) {
                        var oldRange = this.toOrientedRange();
                        this.rangeList.add(oldRange);
                        this.rangeList.add(range);
                        if (this.rangeList.ranges.length != 2) {
                            this.rangeList.removeAll();
                            return $blockChangeEvents || this.fromOrientedRange(range);
                        }
                        this.rangeList.removeAll();
                        this.rangeList.add(oldRange);
                        this.$onAddRange(oldRange);
                    }

                    if (!range.cursor) range.cursor = range.end;

                    var removed = this.rangeList.add(range);

                    this.$onAddRange(range);

                    if (removed.length) this.$onRemoveRange(removed);

                    if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                        this._signal("multiSelect");
                        this.inMultiSelectMode = true;
                        this.session.$undoSelect = false;
                        this.rangeList.attach(this.session);
                    }

                    return $blockChangeEvents || this.fromOrientedRange(range);
                };

                this.toSingleRange = function (range) {
                    range = range || this.ranges[0];
                    var removed = this.rangeList.removeAll();
                    if (removed.length) this.$onRemoveRange(removed);

                    range && this.fromOrientedRange(range);
                };
                this.substractPoint = function (pos) {
                    var removed = this.rangeList.substractPoint(pos);
                    if (removed) {
                        this.$onRemoveRange(removed);
                        return removed[0];
                    }
                };
                this.mergeOverlappingRanges = function () {
                    var removed = this.rangeList.merge();
                    if (removed.length) this.$onRemoveRange(removed);else if (this.ranges[0]) this.fromOrientedRange(this.ranges[0]);
                };

                this.$onAddRange = function (range) {
                    this.rangeCount = this.rangeList.ranges.length;
                    this.ranges.unshift(range);
                    this._signal("addRange", { range: range });
                };

                this.$onRemoveRange = function (removed) {
                    this.rangeCount = this.rangeList.ranges.length;
                    if (this.rangeCount == 1 && this.inMultiSelectMode) {
                        var lastRange = this.rangeList.ranges.pop();
                        removed.push(lastRange);
                        this.rangeCount = 0;
                    }

                    for (var i = removed.length; i--;) {
                        var index = this.ranges.indexOf(removed[i]);
                        this.ranges.splice(index, 1);
                    }

                    this._signal("removeRange", { ranges: removed });

                    if (this.rangeCount === 0 && this.inMultiSelectMode) {
                        this.inMultiSelectMode = false;
                        this._signal("singleSelect");
                        this.session.$undoSelect = true;
                        this.rangeList.detach(this.session);
                    }

                    lastRange = lastRange || this.ranges[0];
                    if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
                };
                this.$initRangeList = function () {
                    if (this.rangeList) return;

                    this.rangeList = new RangeList();
                    this.ranges = [];
                    this.rangeCount = 0;
                };
                this.getAllRanges = function () {
                    return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
                };

                this.splitIntoLines = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var range = this.getRange();
                        var isBackwards = this.isBackwards();
                        var startRow = range.start.row;
                        var endRow = range.end.row;
                        if (startRow == endRow) {
                            if (isBackwards) var start = range.end,
                                end = range.start;else var start = range.start,
                                end = range.end;

                            this.addRange(Range.fromPoints(end, end));
                            this.addRange(Range.fromPoints(start, start));
                            return;
                        }

                        var rectSel = [];
                        var r = this.getLineRange(startRow, true);
                        r.start.column = range.start.column;
                        rectSel.push(r);

                        for (var i = startRow + 1; i < endRow; i++) rectSel.push(this.getLineRange(i, true));

                        r = this.getLineRange(endRow, true);
                        r.end.column = range.end.column;
                        rectSel.push(r);

                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.toggleBlockSelection = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var cursor = this.session.documentToScreenPosition(this.selectionLead);
                        var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

                        var rectSel = this.rectangularRangeBlock(cursor, anchor);
                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
                    var rectSel = [];

                    var xBackwards = screenCursor.column < screenAnchor.column;
                    if (xBackwards) {
                        var startColumn = screenCursor.column;
                        var endColumn = screenAnchor.column;
                    } else {
                        var startColumn = screenAnchor.column;
                        var endColumn = screenCursor.column;
                    }

                    var yBackwards = screenCursor.row < screenAnchor.row;
                    if (yBackwards) {
                        var startRow = screenCursor.row;
                        var endRow = screenAnchor.row;
                    } else {
                        var startRow = screenAnchor.row;
                        var endRow = screenCursor.row;
                    }

                    if (startColumn < 0) startColumn = 0;
                    if (startRow < 0) startRow = 0;

                    if (startRow == endRow) includeEmptyLines = true;

                    for (var row = startRow; row <= endRow; row++) {
                        var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
                        if (range.isEmpty()) {
                            if (docEnd && isSamePoint(range.end, docEnd)) break;
                            var docEnd = range.end;
                        }
                        range.cursor = xBackwards ? range.start : range.end;
                        rectSel.push(range);
                    }

                    if (yBackwards) rectSel.reverse();

                    if (!includeEmptyLines) {
                        var end = rectSel.length - 1;
                        while (rectSel[end].isEmpty() && end > 0) end--;
                        if (end > 0) {
                            var start = 0;
                            while (rectSel[start].isEmpty()) start++;
                        }
                        for (var i = end; i >= start; i--) {
                            if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
                        }
                    }

                    return rectSel;
                };
            }).call(Selection.prototype);
            var Editor = require("./editor").Editor;
            (function () {
                this.updateSelectionMarkers = function () {
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };
                this.addSelectionMarker = function (orientedRange) {
                    if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;

                    var style = this.getSelectionStyle();
                    orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

                    this.session.$selectionMarkers.push(orientedRange);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                    return orientedRange;
                };
                this.removeSelectionMarker = function (range) {
                    if (!range.marker) return;
                    this.session.removeMarker(range.marker);
                    var index = this.session.$selectionMarkers.indexOf(range);
                    if (index != -1) this.session.$selectionMarkers.splice(index, 1);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                };

                this.removeSelectionMarkers = function (ranges) {
                    var markerList = this.session.$selectionMarkers;
                    for (var i = ranges.length; i--;) {
                        var range = ranges[i];
                        if (!range.marker) continue;
                        this.session.removeMarker(range.marker);
                        var index = markerList.indexOf(range);
                        if (index != -1) markerList.splice(index, 1);
                    }
                    this.session.selectionMarkerCount = markerList.length;
                };

                this.$onAddRange = function (e) {
                    this.addSelectionMarker(e.range);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onRemoveRange = function (e) {
                    this.removeSelectionMarkers(e.ranges);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onMultiSelect = function (e) {
                    if (this.inMultiSelectMode) return;
                    this.inMultiSelectMode = true;

                    this.setStyle("ace_multiselect");
                    this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
                    this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onSingleSelect = function (e) {
                    if (this.session.multiSelect.inVirtualMode) return;
                    this.inMultiSelectMode = false;

                    this.unsetStyle("ace_multiselect");
                    this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

                    this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                    this._emit("changeSelection");
                };

                this.$onMultiSelectExec = function (e) {
                    var command = e.command;
                    var editor = e.editor;
                    if (!editor.multiSelect) return;
                    if (!command.multiSelectAction) {
                        var result = command.exec(editor, e.args || {});
                        editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                        editor.multiSelect.mergeOverlappingRanges();
                    } else if (command.multiSelectAction == "forEach") {
                        result = editor.forEachSelection(command, e.args);
                    } else if (command.multiSelectAction == "forEachLine") {
                        result = editor.forEachSelection(command, e.args, true);
                    } else if (command.multiSelectAction == "single") {
                        editor.exitMultiSelectMode();
                        result = command.exec(editor, e.args || {});
                    } else {
                        result = command.multiSelectAction(editor, e.args || {});
                    }
                    return result;
                };
                this.forEachSelection = function (cmd, args, options) {
                    if (this.inVirtualSelectionMode) return;
                    var keepOrder = options && options.keepOrder;
                    var $byLines = options == true || options && options.$byLines;
                    var session = this.session;
                    var selection = this.selection;
                    var rangeList = selection.rangeList;
                    var ranges = (keepOrder ? selection : rangeList).ranges;
                    var result;

                    if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

                    var reg = selection._eventRegistry;
                    selection._eventRegistry = {};

                    var tmpSel = new Selection(session);
                    this.inVirtualSelectionMode = true;
                    for (var i = ranges.length; i--;) {
                        if ($byLines) {
                            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row) i--;
                        }
                        tmpSel.fromOrientedRange(ranges[i]);
                        tmpSel.index = i;
                        this.selection = session.selection = tmpSel;
                        var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                        if (!result && cmdResult !== undefined) result = cmdResult;
                        tmpSel.toOrientedRange(ranges[i]);
                    }
                    tmpSel.detach();

                    this.selection = session.selection = selection;
                    this.inVirtualSelectionMode = false;
                    selection._eventRegistry = reg;
                    selection.mergeOverlappingRanges();

                    var anim = this.renderer.$scrollAnimation;
                    this.onCursorChange();
                    this.onSelectionChange();
                    if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);

                    return result;
                };
                this.exitMultiSelectMode = function () {
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
                    this.multiSelect.toSingleRange();
                };

                this.getSelectedText = function () {
                    var text = "";
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var ranges = this.multiSelect.rangeList.ranges;
                        var buf = [];
                        for (var i = 0; i < ranges.length; i++) {
                            buf.push(this.session.getTextRange(ranges[i]));
                        }
                        var nl = this.session.getDocument().getNewLineCharacter();
                        text = buf.join(nl);
                        if (text.length == (buf.length - 1) * nl.length) text = "";
                    } else if (!this.selection.isEmpty()) {
                        text = this.session.getTextRange(this.getSelectionRange());
                    }
                    return text;
                };

                this.$checkMultiselectChange = function (e, anchor) {
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var range = this.multiSelect.ranges[0];
                        if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
                        var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
                        if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                    }
                };
                this.findAll = function (needle, options, additive) {
                    options = options || {};
                    options.needle = needle || options.needle;
                    if (options.needle == undefined) {
                        var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                        options.needle = this.session.getTextRange(range);
                    }
                    this.$search.set(options);

                    var ranges = this.$search.findAll(this.session);
                    if (!ranges.length) return 0;

                    this.$blockScrolling += 1;
                    var selection = this.multiSelect;

                    if (!additive) selection.toSingleRange(ranges[0]);

                    for (var i = ranges.length; i--;) selection.addRange(ranges[i], true);
                    if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);

                    this.$blockScrolling -= 1;

                    return ranges.length;
                };
                this.selectMoreLines = function (dir, skip) {
                    var range = this.selection.toOrientedRange();
                    var isBackwards = range.cursor == range.end;

                    var screenLead = this.session.documentToScreenPosition(range.cursor);
                    if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;

                    var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

                    if (!range.isEmpty()) {
                        var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                        var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
                    } else {
                        var anchor = lead;
                    }

                    if (isBackwards) {
                        var newRange = Range.fromPoints(lead, anchor);
                        newRange.cursor = newRange.start;
                    } else {
                        var newRange = Range.fromPoints(anchor, lead);
                        newRange.cursor = newRange.end;
                    }

                    newRange.desiredColumn = screenLead.column;
                    if (!this.selection.inMultiSelectMode) {
                        this.selection.addRange(range);
                    } else {
                        if (skip) var toRemove = range.cursor;
                    }

                    this.selection.addRange(newRange);
                    if (toRemove) this.selection.substractPoint(toRemove);
                };
                this.transposeSelections = function (dir) {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var all = sel.ranges;

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        if (range.isEmpty()) {
                            var tmp = session.getWordRange(range.start.row, range.start.column);
                            range.start.row = tmp.start.row;
                            range.start.column = tmp.start.column;
                            range.end.row = tmp.end.row;
                            range.end.column = tmp.end.column;
                        }
                    }
                    sel.mergeOverlappingRanges();

                    var words = [];
                    for (var i = all.length; i--;) {
                        var range = all[i];
                        words.unshift(session.getTextRange(range));
                    }

                    if (dir < 0) words.unshift(words.pop());else words.push(words.shift());

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        var tmp = range.clone();
                        session.replace(range, words[i]);
                        range.start.row = tmp.start.row;
                        range.start.column = tmp.start.column;
                    }
                };
                this.selectMore = function (dir, skip, stopAtFirst) {
                    var session = this.session;
                    var sel = session.multiSelect;

                    var range = sel.toOrientedRange();
                    if (range.isEmpty()) {
                        range = session.getWordRange(range.start.row, range.start.column);
                        range.cursor = dir == -1 ? range.start : range.end;
                        this.multiSelect.addRange(range);
                        if (stopAtFirst) return;
                    }
                    var needle = session.getTextRange(range);

                    var newRange = find(session, needle, dir);
                    if (newRange) {
                        newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                        this.$blockScrolling += 1;
                        this.session.unfold(newRange);
                        this.multiSelect.addRange(newRange);
                        this.$blockScrolling -= 1;
                        this.renderer.scrollCursorIntoView(null, 0.5);
                    }
                    if (skip) this.multiSelect.substractPoint(range.cursor);
                };
                this.alignCursors = function () {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var ranges = sel.ranges;
                    var row = -1;
                    var sameRowRanges = ranges.filter(function (r) {
                        if (r.cursor.row == row) return true;
                        row = r.cursor.row;
                    });

                    if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                        var range = this.selection.getRange();
                        var fr = range.start.row,
                            lr = range.end.row;
                        var guessRange = fr == lr;
                        if (guessRange) {
                            var max = this.session.getLength();
                            var line;
                            do {
                                line = this.session.getLine(lr);
                            } while (/[=:]/.test(line) && ++lr < max);
                            do {
                                line = this.session.getLine(fr);
                            } while (/[=:]/.test(line) && --fr > 0);

                            if (fr < 0) fr = 0;
                            if (lr >= max) lr = max - 1;
                        }
                        var lines = this.session.removeFullLines(fr, lr);
                        lines = this.$reAlignText(lines, guessRange);
                        this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
                        if (!guessRange) {
                            range.start.column = 0;
                            range.end.column = lines[lines.length - 1].length;
                        }
                        this.selection.setRange(range);
                    } else {
                        sameRowRanges.forEach(function (r) {
                            sel.substractPoint(r.cursor);
                        });

                        var maxCol = 0;
                        var minSpace = Infinity;
                        var spaceOffsets = ranges.map(function (r) {
                            var p = r.cursor;
                            var line = session.getLine(p.row);
                            var spaceOffset = line.substr(p.column).search(/\S/g);
                            if (spaceOffset == -1) spaceOffset = 0;

                            if (p.column > maxCol) maxCol = p.column;
                            if (spaceOffset < minSpace) minSpace = spaceOffset;
                            return spaceOffset;
                        });
                        ranges.forEach(function (r, i) {
                            var p = r.cursor;
                            var l = maxCol - p.column;
                            var d = spaceOffsets[i] - minSpace;
                            if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                            r.start.column = r.end.column = maxCol;
                            r.start.row = r.end.row = p.row;
                            r.cursor = r.end;
                        });
                        sel.fromOrientedRange(ranges[0]);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    }
                };

                this.$reAlignText = function (lines, forceLeft) {
                    var isLeftAligned = true,
                        isRightAligned = true;
                    var startW, textW, endW;

                    return lines.map(function (line) {
                        var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                        if (!m) return [line];

                        if (startW == null) {
                            startW = m[1].length;
                            textW = m[2].length;
                            endW = m[3].length;
                            return m;
                        }

                        if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
                        if (startW != m[1].length) isLeftAligned = false;

                        if (startW > m[1].length) startW = m[1].length;
                        if (textW < m[2].length) textW = m[2].length;
                        if (endW > m[3].length) endW = m[3].length;

                        return m;
                    }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

                    function spaces(n) {
                        return lang.stringRepeat(" ", n);
                    }

                    function alignLeft(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function alignRight(m) {
                        return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function unAlign(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                };
            }).call(Editor.prototype);

            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }
            exports.onSessionChange = function (e) {
                var session = e.session;
                if (session && !session.multiSelect) {
                    session.$selectionMarkers = [];
                    session.selection.$initRangeList();
                    session.multiSelect = session.selection;
                }
                this.multiSelect = session && session.multiSelect;

                var oldSession = e.oldSession;
                if (oldSession) {
                    oldSession.multiSelect.off("addRange", this.$onAddRange);
                    oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
                    oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
                    oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
                    oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
                    oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
                }

                if (session) {
                    session.multiSelect.on("addRange", this.$onAddRange);
                    session.multiSelect.on("removeRange", this.$onRemoveRange);
                    session.multiSelect.on("multiSelect", this.$onMultiSelect);
                    session.multiSelect.on("singleSelect", this.$onSingleSelect);
                    session.multiSelect.lead.on("change", this.$checkMultiselectChange);
                    session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
                }

                if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
                    if (session.selection.inMultiSelectMode) this.$onMultiSelect();else this.$onSingleSelect();
                }
            };
            function MultiSelect(editor) {
                if (editor.$multiselectOnSessionChange) return;
                editor.$onAddRange = editor.$onAddRange.bind(editor);
                editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
                editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
                editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
                editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
                editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

                editor.$multiselectOnSessionChange(editor);
                editor.on("changeSession", editor.$multiselectOnSessionChange);

                editor.on("mousedown", onMouseDown);
                editor.commands.addCommands(commands.defaultCommands);

                addAltCursorListeners(editor);
            }

            function addAltCursorListeners(editor) {
                var el = editor.textInput.getElement();
                var altCursor = false;
                event.addListener(el, "keydown", function (e) {
                    var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
                    if (editor.$blockSelectEnabled && altDown) {
                        if (!altCursor) {
                            editor.renderer.setMouseCursor("crosshair");
                            altCursor = true;
                        }
                    } else if (altCursor) {
                        reset();
                    }
                });

                event.addListener(el, "keyup", reset);
                event.addListener(el, "blur", reset);
                function reset(e) {
                    if (altCursor) {
                        editor.renderer.setMouseCursor("");
                        altCursor = false;
                    }
                }
            }

            exports.MultiSelect = MultiSelect;

            require("./config").defineOptions(Editor.prototype, "editor", {
                enableMultiselect: {
                    set: function (val) {
                        MultiSelect(this);
                        if (val) {
                            this.on("changeSession", this.$multiselectOnSessionChange);
                            this.on("mousedown", onMouseDown);
                        } else {
                            this.off("changeSession", this.$multiselectOnSessionChange);
                            this.off("mousedown", onMouseDown);
                        }
                    },
                    value: true
                },
                enableBlockSelect: {
                    set: function (val) {
                        this.$blockSelectEnabled = val;
                    },
                    value: true
                }
            });
        });

        ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../../range").Range;

            var FoldMode = exports.FoldMode = function () {};

            (function () {

                this.foldingStartMarker = null;
                this.foldingStopMarker = null;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);
                    if (this.foldingStartMarker.test(line)) return "start";
                    if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
                    return "";
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    return null;
                };

                this.indentationBlock = function (session, row, column) {
                    var re = /\S/;
                    var line = session.getLine(row);
                    var startLevel = line.search(re);
                    if (startLevel == -1) return;

                    var startColumn = column || line.length;
                    var maxRow = session.getLength();
                    var startRow = row;
                    var endRow = row;

                    while (++row < maxRow) {
                        var level = session.getLine(row).search(re);

                        if (level == -1) continue;

                        if (level <= startLevel) break;

                        endRow = row;
                    }

                    if (endRow > startRow) {
                        var endColumn = session.getLine(endRow).length;
                        return new Range(startRow, startColumn, endRow, endColumn);
                    }
                };

                this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var start = { row: row, column: column + 1 };
                    var end = session.$findClosingBracket(bracket, start, typeRe);
                    if (!end) return;

                    var fw = session.foldWidgets[end.row];
                    if (fw == null) fw = session.getFoldWidget(end.row);

                    if (fw == "start" && end.row > start.row) {
                        end.row--;
                        end.column = session.getLine(end.row).length;
                    }
                    return Range.fromPoints(start, end);
                };

                this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var end = { row: row, column: column };
                    var start = session.$findOpeningBracket(bracket, end);

                    if (!start) return;

                    start.column++;
                    end.column--;

                    return Range.fromPoints(start, end);
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            exports.isDark = false;
            exports.cssClass = "ace-tm";
            exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

            var dom = require("../lib/dom");
            dom.importCssString(exports.cssText, exports.cssClass);
        });

        ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var Range = require("./range").Range;

            function LineWidgets(session) {
                this.session = session;
                this.session.widgetManager = this;
                this.session.getRowLength = this.getRowLength;
                this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
                this.updateOnChange = this.updateOnChange.bind(this);
                this.renderWidgets = this.renderWidgets.bind(this);
                this.measureWidgets = this.measureWidgets.bind(this);
                this.session._changedWidgets = [];
                this.$onChangeEditor = this.$onChangeEditor.bind(this);

                this.session.on("change", this.updateOnChange);
                this.session.on("changeFold", this.updateOnFold);
                this.session.on("changeEditor", this.$onChangeEditor);
            }

            (function () {
                this.getRowLength = function (row) {
                    var h;
                    if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };

                this.$getWidgetScreenLength = function () {
                    var screenRows = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
                    });
                    return screenRows;
                };

                this.$onChangeEditor = function (e) {
                    this.attach(e.editor);
                };

                this.attach = function (editor) {
                    if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();

                    if (this.editor == editor) return;

                    this.detach();
                    this.editor = editor;

                    if (editor) {
                        editor.widgetManager = this;
                        editor.renderer.on("beforeRender", this.measureWidgets);
                        editor.renderer.on("afterRender", this.renderWidgets);
                    }
                };
                this.detach = function (e) {
                    var editor = this.editor;
                    if (!editor) return;

                    this.editor = null;
                    editor.widgetManager = null;

                    editor.renderer.off("beforeRender", this.measureWidgets);
                    editor.renderer.off("afterRender", this.renderWidgets);
                    var lineWidgets = this.session.lineWidgets;
                    lineWidgets && lineWidgets.forEach(function (w) {
                        if (w && w.el && w.el.parentNode) {
                            w._inDocument = false;
                            w.el.parentNode.removeChild(w.el);
                        }
                    });
                };

                this.updateOnFold = function (e, session) {
                    var lineWidgets = session.lineWidgets;
                    if (!lineWidgets || !e.action) return;
                    var fold = e.data;
                    var start = fold.start.row;
                    var end = fold.end.row;
                    var hide = e.action == "add";
                    for (var i = start + 1; i < end; i++) {
                        if (lineWidgets[i]) lineWidgets[i].hidden = hide;
                    }
                    if (lineWidgets[end]) {
                        if (hide) {
                            if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];else lineWidgets[end].hidden = hide;
                        } else {
                            if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
                            lineWidgets[end].hidden = hide;
                        }
                    }
                };

                this.updateOnChange = function (delta) {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;

                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {} else if (delta.action == 'remove') {
                        var removed = lineWidgets.splice(startRow + 1, len);
                        removed.forEach(function (w) {
                            w && this.removeLineWidget(w);
                        }, this);
                        this.$updateRows();
                    } else {
                        var args = new Array(len);
                        args.unshift(startRow, 0);
                        lineWidgets.splice.apply(lineWidgets, args);
                        this.$updateRows();
                    }
                };

                this.$updateRows = function () {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var noWidgets = true;
                    lineWidgets.forEach(function (w, i) {
                        if (w) {
                            noWidgets = false;
                            w.row = i;
                            while (w.$oldWidget) {
                                w.$oldWidget.row = i;
                                w = w.$oldWidget;
                            }
                        }
                    });
                    if (noWidgets) this.session.lineWidgets = null;
                };

                this.addLineWidget = function (w) {
                    if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());

                    var old = this.session.lineWidgets[w.row];
                    if (old) {
                        w.$oldWidget = old;
                        if (old.el && old.el.parentNode) {
                            old.el.parentNode.removeChild(old.el);
                            old._inDocument = false;
                        }
                    }

                    this.session.lineWidgets[w.row] = w;

                    w.session = this.session;

                    var renderer = this.editor.renderer;
                    if (w.html && !w.el) {
                        w.el = dom.createElement("div");
                        w.el.innerHTML = w.html;
                    }
                    if (w.el) {
                        dom.addCssClass(w.el, "ace_lineWidgetContainer");
                        w.el.style.position = "absolute";
                        w.el.style.zIndex = 5;
                        renderer.container.appendChild(w.el);
                        w._inDocument = true;
                    }

                    if (!w.coverGutter) {
                        w.el.style.zIndex = 3;
                    }
                    if (w.pixelHeight == null) {
                        w.pixelHeight = w.el.offsetHeight;
                    }
                    if (w.rowCount == null) {
                        w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
                    }

                    var fold = this.session.getFoldAt(w.row, 0);
                    w.$fold = fold;
                    if (fold) {
                        var lineWidgets = this.session.lineWidgets;
                        if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;else w.hidden = true;
                    }

                    this.session._emit("changeFold", { data: { start: { row: w.row } } });

                    this.$updateRows();
                    this.renderWidgets(null, renderer);
                    this.onWidgetChanged(w);
                    return w;
                };

                this.removeLineWidget = function (w) {
                    w._inDocument = false;
                    w.session = null;
                    if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
                    if (w.editor && w.editor.destroy) try {
                        w.editor.destroy();
                    } catch (e) {}
                    if (this.session.lineWidgets) {
                        var w1 = this.session.lineWidgets[w.row];
                        if (w1 == w) {
                            this.session.lineWidgets[w.row] = w.$oldWidget;
                            if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
                        } else {
                            while (w1) {
                                if (w1.$oldWidget == w) {
                                    w1.$oldWidget = w.$oldWidget;
                                    break;
                                }
                                w1 = w1.$oldWidget;
                            }
                        }
                    }
                    this.session._emit("changeFold", { data: { start: { row: w.row } } });
                    this.$updateRows();
                };

                this.getWidgetsAtRow = function (row) {
                    var lineWidgets = this.session.lineWidgets;
                    var w = lineWidgets && lineWidgets[row];
                    var list = [];
                    while (w) {
                        list.push(w);
                        w = w.$oldWidget;
                    }
                    return list;
                };

                this.onWidgetChanged = function (w) {
                    this.session._changedWidgets.push(w);
                    this.editor && this.editor.renderer.updateFull();
                };

                this.measureWidgets = function (e, renderer) {
                    var changedWidgets = this.session._changedWidgets;
                    var config = renderer.layerConfig;

                    if (!changedWidgets || !changedWidgets.length) return;
                    var min = Infinity;
                    for (var i = 0; i < changedWidgets.length; i++) {
                        var w = changedWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.session != this.session) continue;
                        if (!w._inDocument) {
                            if (this.session.lineWidgets[w.row] != w) continue;
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }

                        w.h = w.el.offsetHeight;

                        if (!w.fixedWidth) {
                            w.w = w.el.offsetWidth;
                            w.screenWidth = Math.ceil(w.w / config.characterWidth);
                        }

                        var rowCount = w.h / config.lineHeight;
                        if (w.coverLine) {
                            rowCount -= this.session.getRowLineCount(w.row);
                            if (rowCount < 0) rowCount = 0;
                        }
                        if (w.rowCount != rowCount) {
                            w.rowCount = rowCount;
                            if (w.row < min) min = w.row;
                        }
                    }
                    if (min != Infinity) {
                        this.session._emit("changeFold", { data: { start: { row: min } } });
                        this.session.lineWidgetWidth = null;
                    }
                    this.session._changedWidgets = [];
                };

                this.renderWidgets = function (e, renderer) {
                    var config = renderer.layerConfig;
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var first = Math.min(this.firstRow, config.firstRow);
                    var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

                    while (first > 0 && !lineWidgets[first]) first--;

                    this.firstRow = config.firstRow;
                    this.lastRow = config.lastRow;

                    renderer.$cursorLayer.config = config;
                    for (var i = first; i <= last; i++) {
                        var w = lineWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.hidden) {
                            w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                            continue;
                        }
                        if (!w._inDocument) {
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }
                        var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
                        if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
                        w.el.style.top = top - config.offset + "px";

                        var left = w.coverGutter ? 0 : renderer.gutterWidth;
                        if (!w.fixedWidth) left -= renderer.scrollLeft;
                        w.el.style.left = left + "px";

                        if (w.fullWidth && w.screenWidth) {
                            w.el.style.minWidth = config.width + 2 * config.padding + "px";
                        }

                        if (w.fixedWidth) {
                            w.el.style.right = renderer.scrollBar.getWidth() + "px";
                        } else {
                            w.el.style.right = "";
                        }
                    }
                };
            }).call(LineWidgets.prototype);

            exports.LineWidgets = LineWidgets;
        });

        ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var LineWidgets = require("../line_widgets").LineWidgets;
            var dom = require("../lib/dom");
            var Range = require("../range").Range;

            function binarySearch(array, needle, comparator) {
                var first = 0;
                var last = array.length - 1;

                while (first <= last) {
                    var mid = first + last >> 1;
                    var c = comparator(needle, array[mid]);
                    if (c > 0) first = mid + 1;else if (c < 0) last = mid - 1;else return mid;
                }
                return -(first + 1);
            }

            function findAnnotations(session, row, dir) {
                var annotations = session.getAnnotations().sort(Range.comparePoints);
                if (!annotations.length) return;

                var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
                if (i < 0) i = -i - 1;

                if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;else if (i === 0 && dir < 0) i = annotations.length - 1;

                var annotation = annotations[i];
                if (!annotation || !dir) return;

                if (annotation.row === row) {
                    do {
                        annotation = annotations[i += dir];
                    } while (annotation && annotation.row === row);
                    if (!annotation) return annotations.slice();
                }

                var matched = [];
                row = annotation.row;
                do {
                    matched[dir < 0 ? "unshift" : "push"](annotation);
                    annotation = annotations[i += dir];
                } while (annotation && annotation.row == row);
                return matched.length && matched;
            }

            exports.showErrorMarker = function (editor, dir) {
                var session = editor.session;
                if (!session.widgetManager) {
                    session.widgetManager = new LineWidgets(session);
                    session.widgetManager.attach(editor);
                }

                var pos = editor.getCursorPosition();
                var row = pos.row;
                var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
                    return w.type == "errorMarker";
                })[0];
                if (oldWidget) {
                    oldWidget.destroy();
                } else {
                    row -= dir;
                }
                var annotations = findAnnotations(session, row, dir);
                var gutterAnno;
                if (annotations) {
                    var annotation = annotations[0];
                    pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
                    pos.row = annotation.row;
                    gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
                } else if (oldWidget) {
                    return;
                } else {
                    gutterAnno = {
                        text: ["Looks good!"],
                        className: "ace_ok"
                    };
                }
                editor.session.unfold(pos.row);
                editor.selection.moveToPosition(pos);

                var w = {
                    row: pos.row,
                    fixedWidth: true,
                    coverGutter: true,
                    el: dom.createElement("div"),
                    type: "errorMarker"
                };
                var el = w.el.appendChild(dom.createElement("div"));
                var arrow = w.el.appendChild(dom.createElement("div"));
                arrow.className = "error_widget_arrow " + gutterAnno.className;

                var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
                arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";

                w.el.className = "error_widget_wrapper";
                el.className = "error_widget " + gutterAnno.className;
                el.innerHTML = gutterAnno.text.join("<br>");

                el.appendChild(dom.createElement("div"));

                var kb = function (_, hashId, keyString) {
                    if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                        w.destroy();
                        return { command: "null" };
                    }
                };

                w.destroy = function () {
                    if (editor.$mouseHandler.isMousePressed) return;
                    editor.keyBinding.removeKeyboardHandler(kb);
                    session.widgetManager.removeLineWidget(w);
                    editor.off("changeSelection", w.destroy);
                    editor.off("changeSession", w.destroy);
                    editor.off("mouseup", w.destroy);
                    editor.off("change", w.destroy);
                };

                editor.keyBinding.addKeyboardHandler(kb);
                editor.on("changeSelection", w.destroy);
                editor.on("changeSession", w.destroy);
                editor.on("mouseup", w.destroy);
                editor.on("change", w.destroy);

                editor.session.widgetManager.addLineWidget(w);

                w.el.onmousedown = editor.focus.bind(editor);

                editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
            };

            dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
        });

        ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var dom = require("./lib/dom");
            var event = require("./lib/event");

            var Editor = require("./editor").Editor;
            var EditSession = require("./edit_session").EditSession;
            var UndoManager = require("./undomanager").UndoManager;
            var Renderer = require("./virtual_renderer").VirtualRenderer;
            require("./worker/worker_client");
            require("./keyboard/hash_handler");
            require("./placeholder");
            require("./multi_select");
            require("./mode/folding/fold_mode");
            require("./theme/textmate");
            require("./ext/error_marker");

            exports.config = require("./config");
            exports.require = require;

            if (typeof define === "function") exports.define = define;
            exports.edit = function (el) {
                if (typeof el == "string") {
                    var _id = el;
                    el = document.getElementById(_id);
                    if (!el) throw new Error("ace.edit can't find div #" + _id);
                }

                if (el && el.env && el.env.editor instanceof Editor) return el.env.editor;

                var value = "";
                if (el && /input|textarea/i.test(el.tagName)) {
                    var oldNode = el;
                    value = oldNode.value;
                    el = dom.createElement("pre");
                    oldNode.parentNode.replaceChild(el, oldNode);
                } else if (el) {
                    value = dom.getInnerText(el);
                    el.innerHTML = "";
                }

                var doc = exports.createEditSession(value);

                var editor = new Editor(new Renderer(el));
                editor.setSession(doc);

                var env = {
                    document: doc,
                    editor: editor,
                    onResize: editor.resize.bind(editor, null)
                };
                if (oldNode) env.textarea = oldNode;
                event.addListener(window, "resize", env.onResize);
                editor.on("destroy", function () {
                    event.removeListener(window, "resize", env.onResize);
                    env.editor.container.env = null; // prevent memory leak on old ie
                });
                editor.container.env = editor.env = env;
                return editor;
            };
            exports.createEditSession = function (text, mode) {
                var doc = new EditSession(text, mode);
                doc.setUndoManager(new UndoManager());
                return doc;
            };
            exports.EditSession = EditSession;
            exports.UndoManager = UndoManager;
            exports.version = "1.2.5";
        });
        (function () {
            ace.require(["ace/ace"], function (a) {
                if (a) {
                    a.config.init(true);
                    a.define = ace.define;
                }
                if (!window.ace) window.ace = a;
                for (var key in a) if (a.hasOwnProperty(key)) window.ace[key] = a[key];
            });
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("70", ["5b"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {

      exports.isDark = true;
      exports.cssClass = "ace-monokai";
      exports.cssText = ".ace-monokai .ace_gutter {\
background: #2F3129;\
color: #8F908A\
}\
.ace-monokai .ace_print-margin {\
width: 1px;\
background: #555651\
}\
.ace-monokai {\
background-color: #272822;\
color: #F8F8F2\
}\
.ace-monokai .ace_cursor {\
color: #F8F8F0\
}\
.ace-monokai .ace_marker-layer .ace_selection {\
background: #49483E\
}\
.ace-monokai.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #272822;\
}\
.ace-monokai .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-monokai .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #49483E\
}\
.ace-monokai .ace_marker-layer .ace_active-line {\
background: #202020\
}\
.ace-monokai .ace_gutter-active-line {\
background-color: #272727\
}\
.ace-monokai .ace_marker-layer .ace_selected-word {\
border: 1px solid #49483E\
}\
.ace-monokai .ace_invisible {\
color: #52524d\
}\
.ace-monokai .ace_entity.ace_name.ace_tag,\
.ace-monokai .ace_keyword,\
.ace-monokai .ace_meta.ace_tag,\
.ace-monokai .ace_storage {\
color: #F92672\
}\
.ace-monokai .ace_punctuation,\
.ace-monokai .ace_punctuation.ace_tag {\
color: #fff\
}\
.ace-monokai .ace_constant.ace_character,\
.ace-monokai .ace_constant.ace_language,\
.ace-monokai .ace_constant.ace_numeric,\
.ace-monokai .ace_constant.ace_other {\
color: #AE81FF\
}\
.ace-monokai .ace_invalid {\
color: #F8F8F0;\
background-color: #F92672\
}\
.ace-monokai .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #AE81FF\
}\
.ace-monokai .ace_support.ace_constant,\
.ace-monokai .ace_support.ace_function {\
color: #66D9EF\
}\
.ace-monokai .ace_fold {\
background-color: #A6E22E;\
border-color: #F8F8F2\
}\
.ace-monokai .ace_storage.ace_type,\
.ace-monokai .ace_support.ace_class,\
.ace-monokai .ace_support.ace_type {\
font-style: italic;\
color: #66D9EF\
}\
.ace-monokai .ace_entity.ace_name.ace_function,\
.ace-monokai .ace_entity.ace_other,\
.ace-monokai .ace_entity.ace_other.ace_attribute-name,\
.ace-monokai .ace_variable {\
color: #A6E22E\
}\
.ace-monokai .ace_variable.ace_parameter {\
font-style: italic;\
color: #FD971F\
}\
.ace-monokai .ace_string {\
color: #E6DB74\
}\
.ace-monokai .ace_comment {\
color: #75715E\
}\
.ace-monokai .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\
}";

      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("71", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.register('1',['3','4','7','11','15','39','41','46','51','58','59','60','61','62','63','66','67','68','69','70','71','72','73','74','75','76','77','78','d','5b','5a','5c','5d','5e','5f','6a','6d','6e','6f'],function(_export,_context){"use strict";var angular$1,firebase,ace,CryptoJS,camelCase,c3,noop,ace$1,tmpl,alert,tmpl$1,noop$1,navbar,tmpl$2,sign,components,list,setTmpl,pythonTmpl,angularjsTmpl,javascriptTmpl,javaTmpl,iconSet,langIcons,icons,_classCallCheck,_createClass,hex,random,pbkdf2,saltSize,keySize,iterations,prf,PasswordService,Service,crypto,defaults,routeServices,_defineProperty,gravatarBaseUrl,eventName,SpfCurrentUserService,datastore,invalidChar,services,spfShared,template,component,ACE_STATS_URL,ace$2,mcqTmpl,mcqEditTmpl,mcqStart,surveyTmpl,teamActivityCreateTmpl,teamIRATTmpl,teamTRATTmpl,teamFormationTmpl,TIMESTAMP,challenges,tmpl$3,component$1,classmentors,cohortTmpl,newCohortTmpl,cohortViewTmpl,cohortEditTmpl,cohortStatsPageTmpl,cohortRankingPageTmpl,noop$5,component$2,cohorts,editTmpl,eventTableParticipantsTmpl,eventTableRankTmpl,eventTableResultsTmpl,eventTaskFormTmpl,eventTmpl,listTmpl,newTmpl,pagerTmpl,passwordTmpl,linkTmpl,responseTmpl,editProfileTmpl,codeTmpl,mcqTmpl$1,schEngageScaleTmpl,motiStratLearnTmpl,eduDisLearnTmpl,noop$6,TIMESTAMP$1,events,editTmpl$1,showTmpl,noop$7,profiles,template$1,AdminCtrl,component$3,admin,formTemplate,template$2,noop$8,ServiceCardCtrl,component$4,GenericServiceFormCtrl,serviceForm,serviceCard,components$1,module$1;/**
 * Directive transforming a textarea to a ace editor.
 *
 * @usage
 * <spf-editor-container flex>
 *     <label>Tests</label>
 *     <textarea name="someTextAreaName"
 *         ng-model="$ctrl.someContent"
 *         columns="1"
 *         ng-required="true"
 *         ng-minlength="3"
 *         ng-maxlength="4096"
 *         spf-editor="{{$ctrl.someLanguage}}"
 *     ></textarea>
 *     <div ng-messages="someFormName.someTextAreaName.$error">
 *         <div ng-message="required">This is required.</div>
 *         <div ng-message="minlength">This has to be more than 3 characters long.</div>
 *         <div ng-message="maxlength">this has to be less than 4096 characters long.</div>
 *     </div>
 * </spf-editor-container>
 *
 * @param  {object} $log Angular logging service
 * @return {[type]}      [description]
 */function spfEditorDirectiveFactory($log){var editorIds=1;var languageToMode={angularjs:'html',python:'python',javascript:'javascript',java:'java'};return{restrict:'A',require:'ngModel',link:function spfAceLink(scope,elm,attrs,ngModel){var editorId='spf-editor-'+editorIds++;var editor,session;var render=ngModel.$render||noop;var container=elm.parent();var label=container.find('label');var watchers=[];// Setup DOM
elm.after('<div class="spf-ace-editor" id="'+editorId+'"/>');editor=ace.edit(elm.next()[0]);session=editor.getSession();elm.css('display','none');// Link editor and model
ngModel.$formatters.push(function(value){if(value==null){return'';}switch(typeof value){case'object':case'array':throw new Error('ui-ace cannot use an object or an array as a model');default:return value;}});ngModel.$render=function(){render();session.setValue(ngModel.$viewValue);};session.on('change',function(){ngModel.$setViewValue(session.getValue(),'change');render();});editor.on('focus',function(){container.addClass('has-focus');});editor.on('blur',function(){ngModel.$setViewValue(session.getValue(),'blur');render();container.removeClass('has-focus');container.addClass('had-focus');});// Make label behave like a label
label.on('click',clickHandler);function clickHandler(){editor.focus();}// Observed attributes
watchers.push(attrs.$observe('spfEditor',function(value){var mode;if(!value){return;}mode=languageToMode[value];if(!mode){$log.error('No mode for '+value);return;}session.setMode('ace/mode/'+mode);}));watchers.push(attrs.$observe('spfReadonly',function(value){var isReadOnly=scope.$eval(value);editor.setReadOnly(isReadOnly);}));// Other options
editor.setTheme('ace/theme/twilight');editor.setFontSize(14);editor.renderer.setShowGutter(true);editor.renderer.setShowInvisibles(true);session.setUseWrapMode(true);session.setUseSoftTabs(true);// Watch for resize
watchers.push(scope.$watch(function(){return[elm[0].offsetWidth,elm[0].offsetHeight];},function(){editor.resize();editor.renderer.updateFull();},true));// Decorate container with input state
['pristine','valid','invalid'].map(function(state){var attrName='$'+state;var className='is-'+state;watchers.push(scope.$watch(function(){return ngModel[attrName];},function(){if(ngModel[attrName]){container.addClass(className);}else{container.removeClass(className);}}));});watchers.push(scope.$watch(function(){return ngModel.$viewValue;},function(){if(ngModel.$viewValue.length===0){container.addClass('is-empty');}else{container.removeClass('is-empty');}}));// clean up
elm.on('$destroy',function(){editor.session.$stopWorker();editor.destroy();watchers.map(function(deregistrationFn){deregistrationFn();});label.off('click',clickHandler);});}};}function SpfAlertCtrl($mdToast,notifications,toastOptions){var self=this;this.notifications=notifications;this.prev=function(){if(self.notifications&&self.notifications.length>0){self.notifications.splice(0,1);$mdToast.show(toastOptions);}};this.close=function(){if(self.notifications&&self.notifications.length>0){self.notifications.splice(0);$mdToast.hide();}};}/**
 * Service to show notification m.
 *
 * It takes as arguments the type of notification and the content
 * of the nofication.
 *
 * The type is used as title of the notification and is user to set
 * the class of the notication block: for type set `info`,
 * the block class will be set `alert` and `alert-info` (always lowercase).
 *
 * `spfAlert.success`, `spfAlert.info`, `spfAlert.warning`, `spfAlert.error`
 * and `spfAlert.danger` are shortcut for the spfAlert function.
 *
 * @param  {function} $q       Angular Promise factory.
 * @param  {object}   $mdToast ngMaterial mdToast service.
 * @return {function}
 */function spfAlertFactory($q,$mdToast){var notifications=[];var options={hideDelay:5000,controller:SpfAlertCtrl,controllerAs:'ctrl',parent:'.main-view',position:'top left right',template:tmpl,locals:{notifications:notifications}};options.locals.toastOptions=options;function newNotification(nType,message){return{notificationType:nType||'success',message:message};}function spfAlert(nType,message){notifications.splice(0,0,newNotification(nType,message));$mdToast.show(options);}spfAlert.success=spfAlert.bind(null,'success');spfAlert.info=spfAlert.bind(null,'info');spfAlert.warning=spfAlert.bind(null,'warning');spfAlert.danger=spfAlert.bind(null,'danger');spfAlert.error=spfAlert.bind(null,'error');return spfAlert;}/**
 * Fill the template cache to the navbar template.
 *
 * @param  {object} $templateCache Angular template cache service.
 */function initNavBar($templateCache){$templateCache.put('shared/navbar-view.html',tmpl$1);}/**
 * NavBarService factory.
 *
 * Registery to set section name and menu items
 *
 * @return {function}
 */function spfNavBarServiceFactory(){return{title:'Singpath',section:undefined,parent:[],menuItems:[],update:function update(section,parents,menuItems){this.section=section;if(parents){this.parents=Array.isArray(parents)?parents:[parents];}else{this.parents=[];}this.menuItems=(menuItems||[]).map(function(item){item.onClick=item.onClick||noop$1;return item;});}};}/**
 * Controler for the header novigation bar.
 *
 * Set an auth property bound to spfAuth. Its user property can used
 * to display the state of the authentication and the user display name
 * when the user is logged in.
 *
 * The ctrl set a login and logout property to autenticate/unauthenticate
 * the current user.
 *
 * @param {function} $q               Angular promise factory service.
 * @param {function} $mdSidenav       ngMaterial side nav service.
 * @param {object}   spfAlert         singpath-core alert service.
 * @param {object}   spfAuth          singpath-core authentication service.
 * @param {object}   spfNavBarService singpath-core nav bar service.
 */function SpfSharedNavBarCtrl($q,$mdSidenav,spfAlert,spfAuth,spfNavBarService){this.auth=spfAuth;this.currentPage=spfNavBarService;this.login=function(){return spfAuth.login().catch(function(e){spfAlert.warning('You failed to authenticate with Google');return $q.reject(e);});};this.logout=function(){return spfAuth.logout();};this.openSideMenu=function(name){$mdSidenav(name).toggle();};}/**
 * Signin form controller.
 *
 * @param {object}   $scope        Angular schild scope of the form.
 * @param {array}    SPF_COUNTRIES List of country name and code.
 * @param {sunction} spfSchools    School list service.
 */function SpfSignFormCtrl($scope,SPF_COUNTRIES,spfSchools){var self=this;var year;spfSchools().then(function(schools){self.schools=Object.keys(schools).map(function(id){return schools[id];});// Make sure the items in the profile attribute are in the list
// of options; or ng-select will show empty select box
if($scope.currentUser.school){$scope.currentUser.school=schools[$scope.currentUser.school.id];}self.loaded=true;});this.loaded=false;this.publicIdIsReadOnly=Boolean($scope.currentUser.publicId);this.countries=SPF_COUNTRIES;this.schools=[];this.ageGroups=[];year=1990;while(year<=2011){this.ageGroups.push(year++);}// Make sure the items in the profile attribute are in the list
// of options; or ng-select will show empty select box
if($scope.currentUser.country){$scope.currentUser.country=this.countries.find(function(country){return country.code===$scope.currentUser.country.code;});}// Current year used to calculate age
$scope.currentYear=new Date().getFullYear();}/**
 * Signin form directive factory.
 *
 * @return {object}
 */function spfSignFormDirectiveFactory(){return{template:tmpl$2,restrict:'E',scope:{currentUser:'='},controller:SpfSignFormCtrl,controllerAs:'ctrl'};}/**
 * Form validator checking the the model value is an available public id.
 *
 * @param  {function} $q          Angular promise factory service.
 * @param  {object}   spfAuthData singpath-core current user data service.
 * @return {object}
 */function spfUniqPublicIdFactory($q,spfAuthData){return{restrict:'A',scope:false,require:'ngModel',link:function spfUniqPublicIdPostLink(s,e,a,model){model.$asyncValidators.spfUniqPublicId=function(modelValue,viewValue){if(!viewValue){return $q.when(true);}return spfAuthData.isPublicIdAvailable(viewValue).then(function(available){if(!available){return $q.reject(new Error(viewValue+' is already taken.'));}return true;});};}};}/**
 * Register the icon set and each language icon with ng-material' $mdIconProvider.
 *
 * @param  {object} $mdIconProvider $mdIcon provider.
 */function config($mdIconProvider){$mdIconProvider.defaultIconSet(iconSet.url,iconSet.vb);langIcons.forEach(function(i){return $mdIconProvider.icon(i.title,i.url,i.vb);});}/**
 * Populate template cache with each icon svg definition.
 *
 * @param  {object} $templateCache $templateCache service.
 */function run($templateCache){$templateCache.put(iconSet.url,iconSet.tmpl);langIcons.forEach(function(i){return $templateCache.put(i.url,i.tmpl);});}function urlForFactory(routes){var routeFns=Object.keys(routes).reduce(function(fns,name){var parts=routes[name].split('/');fns[name]=function(keys){keys=keys||{};return parts.map(function(part){return part[0]===':'?keys[part.slice(1)]:part;}).join('/');};return fns;},{});return function(name,params){var fn=routeFns[name]||routeFns.home;return fn(params);};}function urlForFilterFactory(urlFor){return function urlForFilter(name,params){var url=urlFor(name,params);return url;};}/**
 * Listen for routing error to alert the user of the error and
 * redirect to the default route if not is selected.
 *
 * No route will be selected if the user reload the page in an invalid state
 * for her/his last route. It that case the app should redirect the user
 * to the home route.
 *
 * @param  {object} $rootScope Angular root scope service.
 * @param  {object} $location  Angular location service.
 * @param  {object} routes     Route dictionary.
 * @param  {object} spfAlert   singpath-core alert service
 */function run$1($rootScope,$location,routes,spfAlert){$rootScope.$on('$routeChangeError',function(e,failedRoute,currentRoute,err){spfAlert.error(err.message||err.toString());if(!currentRoute){$location.path(routes.home);}});}/**
 * Returns an object with `user` (Firebase auth user data) property,
 * and login/logout methods.
 *
 * @param  {object}   $q               Angular loggin service.
 * @param  {object}   $route           Angular router service.
 * @param  {object}   $log             Angular logging service.
 * @param  {object}   $firebaseAuth    Angularfire autentication service.
 * @param  {object}   authFirebaseApp  Firebase firebase app holding the authentication data.
 * @param  {object}   authProvider     Firebase auth provider
 * @return {{user: object, login: function, logout: function, onAuth: function}}
 */function spfAuthFactory($q,$route,$log,$firebaseAuth,authFirebaseApp,authProvider){var auth=$firebaseAuth(authFirebaseApp.auth());var cbs=[];var loaded=false;var spfAuth={// The current user auth data (null is not authenticated).
user:undefined,/**
     * Waits for the current user status loads before resolving.
     *
     * @return {Promise<void>}
     */$loaded:function $loaded(){return $q(function(resolve){var cancel=void 0;if(spfAuth.user!==undefined){resolve(spfAuth);return;}cancel=spfAuth.onAuth(function(){resolve(spfAuth);cancel();});});},/**
     * Rejects is the user is logged off.
     *
     * It waits for the status to load before resolving/rejecting.
     *
     * @return {Promise<void,Error>}
     */requireLoggedIn:function requireLoggedIn(){return spfAuth.$loaded().then(function(){if(!spfAuth.user||!spfAuth.user.uid){return $q.reject(new Error('You are not logged in.'));}return spfAuth;});},/**
     * Get user info from current user provider data.
     *
     * @return {?{name: string, email: string}}
     */userInfo:function userInfo(){if(!spfAuth.user){return null;}if(!spfAuth.user.providerData){return{};}return spfAuth.user.providerData.reduce(function(merged,data){switch(data.providerId){case'google.com':merged.email=data.email;merged.name=data.displayName;break;case'custom':if(!merged.email){merged.email='custom@example.com';}if(!merged.name){merged.name='Custom User';}break;default:$log.error('Wrong provider: '+spfAuth.user.providerId);}return merged;},{});},/**
     * Start Oauth authentication dance against google oauth2 service.
     *
     * Updates spfAuth.user and return a promise resolving to the
     * current user auth data.
     *
     * @return {Promise<firebase.User, Error>}
     */login:function login(){return auth.$signInWithPopup(authProvider).then(function(userCredentials){spfAuth.user=userCredentials.user;return userCredentials.user;});},/**
     * Unauthenticate user and reset spfAuth.user.
     *
     * @return {Promise<void, Error>}
     */logout:function logout(){return auth.$signOut();},/**
     * Register a callback for the authentication event.
     *
     * @param  {function} fn  cb function for auth change events.
     * @param  {object}   ctx cb context.
     * @return {function} function to deregister handler
     */onAuth:function onAuth(fn,ctx){var handler={fn:fn,ctx:ctx};cbs.push(handler);if(loaded){handler.fn.call(handler.ctx,spfAuth.user);}return function(){var index=cbs.indexOf(handler);if(index>-1){cbs.splice(index,1);}};}};auth.$onAuthStateChanged(function(currentAuth){loaded=true;$log.debug('reloading');$route.reload();spfAuth.user=currentAuth||null;cbs.forEach(function(handler){try{handler.fn.call(handler.ctx,spfAuth.user);}catch(e){$log.error(e);}});});return spfAuth;}/**
 * Service to interact with '/auth/users' singpath firebase db entry
 *
 * @param  {function} $q              Angular promise factory service.
 * @param  {object}   $log            Angular logging service.
 * @param  {object}   $firebaseObject AngularFire synchronized objects service.
 * @param  {object}   authFirebaseApp Firebase app hosting authentication data.
 * @param  {object}   spfAuth         singpath-core authentication service.
 * @param  {object}   spfCrypto       singpath-core crypto helpers service.
 * @return {{user: function, register: function, publicId: function, isPublicIdAvailable: function}}
 */function spfAuthDataFactory($q,$log,$firebaseObject,authFirebaseApp,spfAuth,spfCrypto){var userDataPromise,spfAuthData;var db=authFirebaseApp.database();var UserFirebaseObject=$firebaseObject.$extend({$completed:function $completed(){return Boolean(this.publicId&&this.country&&(this.yearOfBirth||this.country.code!=='SG')&&(this.school||!this.yearOfBirth||this.yearOfBirth<1996||this.yearOfBirth>2004));}});UserFirebaseObject.create=function(ref){if(typeof ref.child!=='function'){throw new Error('A firebase Reference is required; received "'+ref+'".');}return new spfAuthData.UserFirebaseObject(ref);};spfAuth.onAuth(function(){userDataPromise=undefined;});spfAuthData={UserFirebaseObject:UserFirebaseObject,_user:function _user(){var ref=db.ref('auth/users/'+spfAuth.user.uid);var syncObj=UserFirebaseObject.create(ref);return syncObj.$loaded().then(function(){return syncObj;});},/**
     * Returns a promise resolving to an angularFire $firebaseObject
     * for the current user data.
     *
     * The promise will be rejected if the is not authenticated.
     *
     * @return {Promise<object, Error>}
     */user:function user(){if(userDataPromise){return userDataPromise;}userDataPromise=spfAuth.$loaded().then(function(){if(!spfAuth.user||!spfAuth.user.uid){return $q.reject(new Error('Your did not login or your session expired.'));}return spfAuthData._user();}).then(spfAuthData.register);return userDataPromise;},/**
     * Setup initial data for the current user.
     *
     * Should run if 'auth.user().$value is `null`.
     *
     * Returns a promise resolving to the user data when
     * they become available.
     *
     * @param  {object} userDataObj user data to register.
     * @return {Promise<object, Error>}
     */register:function register(userDataObj){var userInfo;if(userDataObj==null){return $q.reject(new Error('A user should be logged in to register'));}// $value will be undefined and not null when the userDataObj object
// is set.
if(userDataObj.$value!==null){return $q.resolve(userDataObj);}userInfo=spfAuth.userInfo();if(!userInfo||!userInfo.name||!userInfo.email){return $q.reject(new Error('Failed to retrieve user data from provider data: '+JSON.stringify(spfAuth.user.providerData)));}userDataObj.$value={id:spfAuth.user.uid,fullName:userInfo.name,displayName:userInfo.name,email:userInfo.email,gravatar:gravatarBaseUrl+spfCrypto.md5(userInfo.email),createdAt:{'.sv':'timestamp'}};return userDataObj.$save().then(function(){return userDataObj;});},/**
     * Set the user public id.
     *
     * @param  {object} userSync AngularFire object.
     * @return {Promise<void, Error>}
     */publicId:function publicId(userSync){var _data;if(!userSync||!userSync.publicId){return $q.reject(new Error('The user has not set a user public id.'));}if(!userSync.$id){return $q.reject(new Error('Expected an angularFire synchronized object.'));}var ref=db.ref('auth');var data=(_data={},_defineProperty(_data,'publicIds/'+userSync.publicId,userSync.$id),_defineProperty(_data,'usedPublicIds/'+userSync.publicId,true),_defineProperty(_data,'users/'+userSync.$id+'/publicId',userSync.publicId),_data);return ref.update(data).catch(function(err){$log.info(err);return $q.reject(new Error('Failed to save public id. It might have already being used by an other user.'));});},/**
     * Test if a public id is available.
     *
     * @param  {string}  publicId id to test
     * @return {Promise<boolean, Error>}
     */isPublicIdAvailable:function isPublicIdAvailable(publicId){var ref=db.ref('auth/usedPublicIds/'+publicId);return ref.once('value').then(function(snapshot){return!snapshot.val();});}};return spfAuthData;}/**
 * Create a function which when called return a promise resolving to the list of
 * Singapore schools.
 *
 * Load the list as soon as the the service is created. The service will return
 * the same promise over again as a way to cache the result.
 *
 * @param  {object}   $firebaseObject AngularFire synchronized objects service.
 * @param  {object}   firebaseApp     Firebase app hosting the app data.
 * @return {function}
 */function spfSchoolsFactory($firebaseObject,firebaseApp){var db=firebaseApp.database();var ref=db.ref('classMentors/schools');var syncObj=$firebaseObject(ref);var promise=syncObj.$loaded().then(function(){return syncObj;});/**
   * Resolve to the list of schools as an angularFire synchronized object.
   *
   * @return {Promise<object, Error>}
   */return function spfSchools(){return promise;};}function run$2($log,spfProfilesPath){if(!spfProfilesPath){throw new Error('spfProfilesPath constant is not set\n'+'(set it with e.g. '+'"myModule.constant(\`spfProfilesPath\`, \'classMentors/userProfiles\');"'+')');}$log.info('spfProfilesPath set to "'+spfProfilesPath+'".');}/**
 * singpath-core/services/firebase.js - helpers for firebase operation.
 *//**
 * Check the firebase app references are set.
 *
 * @param {object}                     $log            Angular logger service
 * @param {firebase.app.App}           firebaseApp     Main firebase app
 * @param {firebase.app.App}           authFirebaseApp Firebase app handling authentication.
 * @param {firebase.auth.AuthProvider} authProvider    Firebase app auth provider.
 */function run$3($log,firebaseApp,authFirebaseApp,authProvider){if(!firebaseApp||!authFirebaseApp){throw new Error('Firebase Apps (main and auth) are not set.');}if(!authProvider){throw new Error('Firebase auth provider is not set.');}$log.info('Auth Firebase app: '+authFirebaseApp.options.authDomain);$log.info('Main Firebase app: '+firebaseApp.options.authDomain);}/**
 * Remove invalid items from an object.
 *
 * Invalid items have a key with an invalid char:
 * '.', '#', '$', '/', '[' or ']'.
 *
 * @param  {any} obj value to cleanup.
 * @return {any}
 */function cleanObj(obj){if(obj===undefined){return null;}if(Array.isArray(obj)){return obj.map(function(x){return cleanObj(x);});}if(obj==null||!(obj instanceof Object)||typeof obj.getDate==='function'){return obj;}return Object.keys(obj).reduce(function(copy,key){for(var i=0;i<invalidChar.length;i++){if(key.indexOf(invalidChar[i])!==-1){return copy;}}copy[key]=cleanObj(obj[key]);return copy;},{});}/**
 * singpath-core/filters.js - spfShared filter factories.
 *//**
 * Create a filter checking a an object (including angularFire object) or an
 * arrayis empty.
 *
 * @return {function} [description]
 */function spfEmptyFilterFactory(){/**
   * Return true if the object is empty or falsy.
   *
   * @param  {any} obj value to test.
   * @return {boolean}
   */return function spfEmpty(obj){if(!obj){return true;}if(obj.hasOwnProperty('$value')){return obj.$value===null;}if(obj.length!==undefined){return obj.length===0;}return Object.keys(obj).length===0;};}/**
 * Create a filter checking for the length of an array or object.
 *
 * @return {function} [description]
 */function spfLengthFilterFactory(){/**
   * Return the number of elements (array element or object properties).
   *
   * Returns:
   * - 0 if the object is falsy;
   * - 0 if it's an angularfire object referencing null;
   * - the object element length if it's an array-like object;
   * - or the number of iterable properties otherwise.
   *
   * @param  {any}    obj Object to assess the length.
   * @return {number}
   */return function spfLength(obj){if(!obj){return 0;}if(obj.hasOwnProperty('$value')&&obj.$value===null){return 0;}if(obj.length!==undefined){return obj.length;}return Object.keys(obj).filter(function(k){return k&&k[0]!=='$';}).length;};}/**
 * Create filter extract the values of an object iterable properties.
 *
 * @return {function}
 */function spfToArrayFilterFactory(){/**
   * Return the object values.
   *
   * @param  {object} obj Object to convert.
   * @return {array}
   */return function spfToArrayFilter(obj){if(!(obj instanceof Object)){return obj;}return Object.keys(obj).reduce(function(arr,key){if(!key||key[0]==='$'){return arr;}var value=obj[key];if(!(obj instanceof Object)||value.$$hashkey){arr.push(value);return arr;}arr.push(Object.defineProperty(value,'$$hashKey',{__proto__:null,value:key}));return arr;},[]);};}/**
 * singpath-core/config.js
 *//**
 * Configure cfpLoadingBar options.
 *
 * spfShared.config(config.loadingBar);
 * spfShared.config(mdTheme);
 *
 * @param {object} cfpLoadingBarProvider loading bar service
 */function loadingBar(cfpLoadingBarProvider){cfpLoadingBarProvider.includeSpinner=false;}/**
 * Configure theme colours
 *
 * @param  {object} $mdThemingProvider ngMaterial theming provider.
 */function mdTheme($mdThemingProvider){$mdThemingProvider.theme('default').primaryPalette('brown').accentPalette('amber').warnPalette('deep-orange');}function loaded(syncObjOrArray){return syncObjOrArray.$loaded().then(function(){return syncObjOrArray;});}/**
 * Singleton third party services list factory.
 *
 * @example
 * module.run(['clmServices', function() {
 *   clmServices.register('codeCombat');
 * }]);
 * module.component('someComponent', {
 *   template: '...',
 *   controller: [
 *     '$firebaseObject',
 *     'clmServices',
 *     'spfCurrentUser',
 *     function($firebaseObject. clmServices, spfCurrentUser) {
 *       this.data = $firebaseObject(clmServices.codeCombat.dataRef(spfCurrentUser.publicId));
 *   }]
 * });
 *
 * @param  {object}   $firebaseObject AngularFire sync object service.
 * @param  {object}   $log            Angular logging service.
 * @param  {function} $q              Angular Promise factory service.
 * @param  {function} $timeout        Angular timeout service.
 * @param  {object}   firebaseApp     Class Mentors main firebase App
 * @return {object}
 */function clmServicesFactory($firebaseObject,$log,$q,$timeout,firebaseApp){var availableBadgesPromise={};var db=firebaseApp.database();/**
   * Basic third party service handler
   */var GenericService=function(){/**
     * GenericService constructor.
     * @param  {string} name        Service name.
     * @param  {string} [id]        Service id
     * @param  {string} [settingId] Id of the setting enabling this service.
     */function GenericService(name,id,settingId){_classCallCheck(this,GenericService);/**
       * The service name.
       * @type {string}
       */this.name=name;/**
       * The Service id.
       * @type {string}
       */this.serviceId=id||camelCase(name);/**
       * The setting enabling this service.
       * @type {string}
       */this.settingId=settingId||camelCase('enable '+name);}/* deprecated methods */_createClass(GenericService,[{key:'badges',value:function badges(){$log.warn(new Error('deprecated'));return{};}},{key:'fetchProfile',value:function fetchProfile(){$log.warn(new Error('deprecated'));return $q.resolve({});}},{key:'fetchBadges',value:function fetchBadges(){$log.warn(new Error('deprecated'));return $q.resolve([]);}},{key:'updateProfile',value:function updateProfile(){$log.warn(new Error('deprecated'));return $q.resolve();}/**
     * Return a promise resolving to all avalaible badges at
     * that service.
     *
     * @todo replaced by `availableAchievement`.
     * @return {FirebaseObject} the list of badge for a service.
     */},{key:'availableBadges',value:function availableBadges(){if(availableBadgesPromise[this.serviceId]){return availableBadgesPromise[this.serviceId];}var ref=db.ref('classMentors/badges/'+this.serviceId);var badges=$firebaseObject(ref);availableBadgesPromise[this.serviceId]=loaded(badges);return availableBadgesPromise[this.serviceId];}/**
     * Return a firebase Reference to the user service data (for that service).
     *
     * @param  {string} publicId The user publicId
     * @return {firebase.database.Reference}
     */},{key:'dataRef',value:function dataRef(publicId){return db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId);}/**
     * Return the user data for that service.
     *
     * It will return undefined if the details are for that service are
     * not set or if the user id is missing.
     *
     * @param {firebaseObj} profile Class Mentor profile of a user
     * @return {?{details: object, lastUpdate: number, lastUpdateRequest: number}}
     */},{key:'data',value:function data(profile){if(profile&&profile.services&&profile.services[this.serviceId]&&profile.services[this.serviceId].details&&profile.services[this.serviceId].details.id){return profile.services[this.serviceId];}return undefined;}/**
     * Return the user details for that service.
     *
     * It will return undefined if the details are for that service are
     * not set or if the user id is missing.
     *
     * @param {FirebaseObject} profile Class Mentor profile of a user.
     * @return {?{id: string, name: string, registeredBefore: number}}
     */},{key:'details',value:function details(profile){var data=this.data(profile);return data&&data.details;}/**
     * It should create the user details for that service and request an update.
     *
     * @param  {string}                     publicId User's publiId.
     * @param  {{id: string, name: string}} details  Holds the user id and user name for that service
     * @return {Promise<void,Error>}
     */},{key:'saveDetails',value:function saveDetails(publicId,details){var _this=this;if(!publicId){return $q.reject(new Error('No public id provided..'));}if(!details||!details.id){return $q.reject(new Error('The user details for '+this.serviceId+' should include an id.'));}var ref=db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId+'/details');return ref.set(Object.assign({registeredBefore:{'.sv':'timestamp'}},cleanObj(details))).then(function(){return _this.requestUpdate(publicId).catch(function(err){return $log.error(err);});});}/**
     * Remove the service data.
     *
     * @param  {string}  publicId User's publiId.
     * @return {Promise<void,Error>}
     */},{key:'removeDetails',value:function removeDetails(publicId){if(!publicId){return $q.reject(new Error('No public id provided.'));}var ref=db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId);return ref.remove();}/**
     * Request the profile for that service to be updated.
     *
     * @param  {string} publicId The user public id.
     * @return {Promise<void,Error>}
     */},{key:'requestUpdate',value:function requestUpdate(publicId){var _rootRef$update;if(!publicId){return $q.reject(new Error('No public id provided.'));}var rootRef=db.ref('/');var taskKey=db.ref('queue/tasks').push().key;var servicePath='classMentors/userProfiles/'+publicId+'/services/'+this.serviceId;return rootRef.update((_rootRef$update={},_defineProperty(_rootRef$update,'queue/tasks/'+taskKey,{id:publicId,service:this.serviceId}),_defineProperty(_rootRef$update,servicePath+'/lastUpdateRequest',{'.sv':'timestamp'}),_rootRef$update));}}]);return GenericService;}();/**
   * List of third party services providing user achiements.
   */var Services=function(){/**
     * Service list contructor.
     *
     * Iteration other the Services object should only return service id.
     */function Services(){_classCallCheck(this,Services);/**
       * List of enabled services.
       * @type {Array}
       */Object.defineProperty(this,'$enabledServices',{value:[],writable:true});/**
       * List of settings
       * @type {Object}
       */Object.defineProperty(this,'$settings',{value:{},writable:true});}/**
     * Register a new third party service.
     *
     * Adds the service as clmServices propertty (using the serviceId as the key).
     *
     * @param  {string} serviceName Service name.
     * @param  {string} [serviceId] Service id - default to the service name in camel case.
     * @param  {string} [settingId] Id of the setting enabling the service.
     * @return {GenericService}
     */_createClass(Services,[{key:'register',value:function register(serviceName,serviceId,settingId){var service=new GenericService(serviceName,serviceId,settingId);this[service.serviceId]=service;this.doEnableServices();return service;}/**
     * Handler for setting changes.
     *
     * Should update the list of enabled services.
     *
     * @param  {object} settings List of Class Mentors settings.
     * @private
     */},{key:'enableServices',value:function enableServices(settings){this.$settings=settings||{};this.doEnableServices();}/**
     * Update the list enabled services.
     *
     * @private
     */},{key:'doEnableServices',value:function doEnableServices(){var _this2=this;var ids=Object.keys(this);this.$enabledServices=ids.filter(function(serviceId){var settingId=_this2[serviceId].settingId;return _this2.$settings[settingId]&&_this2.$settings[settingId].value;});}/**
     * List available services.
     *
     * @return {object}
     */},{key:'available',value:function available(){var _this3=this;return this.$enabledServices.map(function(serviceId){return _this3[serviceId];});}/**
     * List available and setup services for a profile.
     *
     * @param  {object} profile AngularFire sync object representing a user object.
     * @return {object}
     */},{key:'registeredWith',value:function registeredWith(profile){return this.available().filter(function(service){var details=service.details(profile);return details!==undefined;});}/**
     * Refresh profile service details.
     *
     * Service refreshed too recently will be skipped.
     *
     * @param  {object} profile AngularFire sync object representing a user object.
     * @return {Promise<void,Error>}
     */},{key:'refresh',value:function refresh(profile){var requests=this.registeredWith(profile).map(function(service){return service.requestUpdate(profile.$id);});return $q.all(requests);}/**
     * Return a database reference to the user service data.
     *
     * @param  {string} publicId [description]
     * @return {firebase.database.Reference}
     */},{key:'ref',value:function ref(publicId){if(!publicId){throw new Error('Note public id provided.');}return db.ref('classMentors/userProfiles/'+publicId+'/services');}}]);return Services;}();var services=new Services();var settingsRef=db.ref('classMentors/settings');// watch for setting update enabling/disabling service.
settingsRef.on('value',function(snapshot){return services.enableServices(snapshot.val());},function(err){$log.error(err);services.enableServices();});return services;}/**
 * Service to interact with singpath firebase db
 *
 */function clmDataStoreFactory($window,$location,$q,$log,$http,$timeout,firebaseApp,$firebaseObject,$firebaseArray,spfSchools,routes,spfAuth,spfAuthData,spfCrypto,clmServices,clmServicesUrl){var clmDataStore;var db=firebaseApp.database();var ProfileFirebaseObject=$firebaseObject.$extend({canView:function canView(obj){var kind=obj&&obj.$ref&&obj.$ref().parent.path.toString();// if (this.user && this.user.isAdmin) {
//   return true;
// }
if(obj.owner&&obj.owner.publicId&&this.$id===obj.owner.publicId){return true;}if(obj.assistants&&obj.assistants[this.$id]){// $log.info(obj.assistants );
return true;}if(kind==='/classMentors/events'&&obj.$id&&this.joinedEvents&&this.joinedEvents[obj.$id]){return true;}return false;}});ProfileFirebaseObject.create=function(publicId){var ref=db.ref('classMentors/userProfiles/'+publicId);return new ProfileFirebaseObject(ref);};var ParticipantsFirebaseArray=$firebaseArray.$extend({$schools:function $schools(){return this.$list.reduce(function(schools,participant){if(!participant.user||!participant.user.school||!participant.user.school.name){return schools;}schools[participant.user.school.name]=participant.user.school;return schools;},{});}});ParticipantsFirebaseArray.create=function(eventId){var ref=db.ref('classMentors/eventParticipants/'+eventId);return new ParticipantsFirebaseArray(ref);};clmDataStore={ProfileFirebaseObject:ProfileFirebaseObject,/**
     * Return a promise resolving to $firebaseObj pointing to
     * the current user profile for Classmemtors.
     *
     * If the user has a classmemtor profile and its user data are outdated.
     * they will get updated.
     *
     */currentUserProfile:function currentUserProfile(){var currentUserPromise=spfAuthData.user();var profilePromise=spfAuthData.user().then(function(currentUser){if(!currentUser.publicId){return undefined;}return clmDataStore.profile(currentUser.publicId);});return $q.all({currentUser:currentUserPromise,profile:profilePromise}).then(function(resp){var userData=resp.profile&&resp.profile.user;if(!userData){return resp.profile;}var userCountry=userData.country&&userData.country.code;var profileCountry=resp.currentUser.country&&resp.currentUser.country.code;if(userData.displayName===resp.currentUser.displayName&&userData.gravatar===resp.currentUser.gravatar&&userCountry===profileCountry&&userData.yearOfBirth===resp.currentUser.yearOfBirth){return resp.profile;}return clmDataStore.updateProfile(resp.currentUser);});},logging:{inputLog:function inputLog(actionObj){var ref=db.ref('classMentors/userActions');return ref.push(actionObj);}},profile:function profile(publicId){return $q.resolve(publicId).then(function(id){return loaded(clmDataStore.ProfileFirebaseObject.create(id));});},getProfileData:function getProfileData(publicId){var ref=db.ref('classMentors/userProfiles/'+publicId+'/user');return loaded($firebaseObject(ref));},updateProfile:function updateProfile(userData){var ref=db.ref('classMentors/userProfiles/'+userData.publicId+'/user');return ref.update({displayName:userData.displayName,gravatar:userData.gravatar,// cleanup optional values
country:cleanObj(userData.country),yearOfBirth:cleanObj(userData.yearOfBirth),school:cleanObj(userData.school)}).then(function(){return clmDataStore.profile(userData.publicId);});},getSchools:function getSchools(){return spfSchools();},initProfile:function initProfile(){return spfAuthData.user().then(function(currentUser){if(!currentUser||!currentUser.publicId){return $q.reject(new Error('The user has not set a user public id.'));}return clmDataStore.updateProfile(currentUser);});},cohorts:{errNoPublicId:new Error('You should have a public id to join a cohort'),create:function create(cohort){var rootRef=db.ref('classMentors/cohorts');var publicId=cohort.owner.publicId;var ref=rootRef.push(cohort);return ref.then(function(){return ref.once('value');}).then(function(snapshot){var val=snapshot.val();var profileRef=db.ref('classMentors/userProfiles/'+publicId+'/createdCohorts/'+snapshot.key);return profileRef.set({createdAt:val.createdAt,title:val.title,featured:val.featured||false});}).then(function(){return ref.key;});},updateCohort:function updateCohort(cohort){if(!cohort||!cohort.$id||!cohort.$save){return $q.reject(new Error('Cohort is not a firebase object'));}return cohort.$save().then(function(){var cohortId=cohort.$id;}).catch(function(err){$log.error(err);return err;});},get:function get(cohortId){var ref=db.ref('classMentors/cohorts/'+cohortId);return loaded($firebaseObject(ref));},listAllCohorts:function listAllCohorts(){var ref=db.ref('classMentors/cohorts');var query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));},listFeaturedCohorts:function listFeaturedCohorts(){var ref=db.ref('classMentors/cohorts');var query=ref.orderByChild('featured').equalTo(true).limitToLast(50);return loaded($firebaseArray(query));},listCreatedCohorts:function listCreatedCohorts(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/createdCohorts');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list created cohorts: '+err);return[];});},addEvent:function addEvent(cohortId,eventId,eventNum){var ref=db.ref('classMentors/cohorts/'+cohortId+'/events/'+eventNum);return ref.set(eventId);},removeEvent:function removeEvent(cohortId,newEventArray){var ref=db.ref('classMentors/cohorts/'+cohortId+'/events');$log.error(new Error('TODO: fix race condition by removing event child instead of replacing the list.'));return ref.set(newEventArray);},addAnnouncement:function addAnnouncement(cohortId,madeBy,announcement,isArchived){var rootRef=db.ref('classMentors/cohortAnnouncements/'+cohortId);var ref=rootRef.push();var priority=announcement.priority;var promise;announcement.madeAt={'.sv':'timestamp'};announcement.madeBy=madeBy.publicId;promise=priority?ref.setWithPriority(announcement,priority):ref.set(announcement);return promise.then(function(){return ref;});},getAnnouncements:function getAnnouncements(cohortId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId);var query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));},featureAnnouncement:function featureAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/featured');return ref.set(true);},unfeatureAnnouncement:function unfeatureAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/featured');return ref.set(false);},showAnnouncement:function showAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/visible');return ref.set(true);},hideAnnouncement:function hideAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/visible');return ref.set(false);}},events:{addTaskWithAns:function addTaskWithAns(eventId,task,isOpen,answers){var rootRef=db.ref('classMentors/eventTasks/'+eventId);var ref=rootRef.push();var priority=task.priority;var promise;$log.info('Eventid is ? ',eventId);$log.info('task is : ',task);if(isOpen){task.openedAt={'.sv':'timestamp'};task.closedAt=null;}else{task.closedAt={'.sv':'timestamp'};task.openedAt=null;}promise=priority?ref.setWithPriority(task,priority):ref.set(task);return promise.then(function(){var taskId=ref.key;var answerRef=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);return answerRef.set(answers);});},getTaskAnswers:function getTaskAnswers(eventId,taskId){var ref=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},addTeamFormation:function addTeamFormation(eventId,task,priority){return spfFirebase.push(['classMentors/eventTasks',eventId],task).then(function(ref){ref.setPriority(priority);return ref;});},addTrat:function addTrat(eventId,task,priority){return spfFirebase.push(['classMentors/eventTasks',eventId],task).then(function(ref){ref.setPriority(priority);var taskId=ref.key();return ref;});},updateTaskWithAns:function updateTaskWithAns(eventId,taskId,task,answers){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var ansRef=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);var priority=task.priority;return ref.setWithPriority(task,priority).then(function(){return ansRef.set(answers);});},addTaskAnswers:function addTaskAnswers(eventId,answers){var ref=db.ref('classMentors/eventAnswers/'+eventId);return ref.push(answers);},errNoPublicId:new Error('You should have a public id to join an event'),list:function list(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('featured').equalTo(true).limitToLast(50);return loaded($firebaseArray(query));},listAll:function listAll(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('createdAt');return loaded($firebaseObject(query));},listAllArr:function listAllArr(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('createdAt');return loaded($firebaseArray(query));},listCreatedEvents:function listCreatedEvents(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/createdEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list created events: '+err);return[];});},listJoinedEvents:function listJoinedEvents(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/joinedEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list joined events: '+err);return[];});},listJoinedEventsObj:function listJoinedEventsObj(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/joinedEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseObject(query));}).catch(function(err){$log.error('Failed to list joined events: '+err);return[];});},create:function create(event,password){var eventRef=db.ref('classMentors/events').push(event);var eventId=eventRef.key;var passwordRef=db.ref('classMentors/eventPasswords/'+eventId);var ownerId=event.owner.publicId;var profileRef=db.ref('classMentors/userProfiles/'+ownerId+'/createdEvents/'+eventId);return eventRef.then(function(){var hash=spfCrypto.password.newHash(password);var opts={hash:hash.value,options:hash.options};return passwordRef.set(opts);}).then(function(){return eventRef.once('value');}).then(function(snapshot){var val=snapshot.val();return profileRef.set({createdAt:val.createdAt,title:val.title,featured:val.featured||false});}).then(function(){return eventId;});},updateEvent:function updateEvent(event,password){var eventId=event&&event.$id;var ownerId=event&&event.owner&&event.owner.publicId;var passwordRef,profileRef;if(!eventId||!ownerId){return $q.reject(new Error('Event is not a firebase object'));}passwordRef=db.ref('classMentors/eventPasswords/'+eventId);profileRef=db.ref('classMentors/userProfiles/'+ownerId+'/createdEvents/'+eventId);return event.$save().then(function(){var hash,opts;if(!password){return null;}hash=spfCrypto.password.newHash(password);opts={hash:hash.value,options:hash.options};return passwordRef.set(opts);}).then(function(){return profileRef.update({title:event.title,featured:event.featured||false});}).catch(function(err){$log.error(err);return err;});},get:function get(eventId){var ref=db.ref('classMentors/events/'+eventId);return loaded($firebaseObject(ref));},getRanking:function getRanking(eventId){var ref=db.ref('classMentors/eventRankings/'+eventId);return loaded($firebaseObject(ref)).then(function(ranking){setRankInSchool();ranking.$watch(setRankInSchool);return ranking;function setRankInSchool(){// 1. sort participant by school
var schoolRankings=Object.keys(ranking).filter(function(publicId){return publicId.length>0&&ranking[publicId]&&ranking[publicId].user;}).reduce(function(all,publicId){var participant=ranking[publicId];var schoolId;if(participant.user.school==null||!participant.user.school.name||!participant.user.school.type){return all;}schoolId=participant.user.school.type+'/'+participant.user.school.name;if(!all[schoolId]){all[schoolId]=[];}all[schoolId].push(participant);return all;},{});Object.keys(schoolRankings).map(function(schoolId){// 2. Sort each school participants in their school
schoolRankings[schoolId].sort(function(a,b){//  sort on total by desc. order.
if(a.total!==b.total){return b.total-a.total;}if(!a.user||a.user.displayName){return-1;}if(!b.user||b.user.displayName){return 1;}// sort by display name if total is equal (asc. order)
return a.user.displayName.localeCompare(b.user.displayName);});return schoolRankings[schoolId];}).forEach(function(sortedParticipants){// 3. add `$rankInSchool` property
sortedParticipants.forEach(function(p,index){p.$rankInSchool=index+1;});});}});},getProgress:function getProgress(eventId){var ref=db.ref('classMentors/eventProgress/'+eventId);return loaded($firebaseObject(ref));},getTeam:function getTeam(eventId,taskId,teamId){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+teamId);return loaded($firebaseObject(ref)).then(function(result){console.log("result sissssss:",Object.keys(result));return Object.keys(result);});},getUserProgress:function getUserProgress(eventId,publicId){var ref=db.ref('classMentors/eventProgress/'+eventId+'/'+publicId);return loaded($firebaseObject(ref));},getSolutions:function getSolutions(eventId){var ref=db.ref('classMentors/eventSolutions/'+eventId);return loaded($firebaseObject(ref));},getScores:function getScores(eventId){var ref=db.ref('classMentors/eventScores/'+eventId);return loaded($firebaseObject(ref));},getUserSolutions:function getUserSolutions(eventId,publicId){var ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+publicId);return loaded($firebaseObject(ref));},getTasks:function getTasks(eventId){var ref=db.ref('classMentors/eventTasks/'+eventId);var query=ref.orderByPriority();return loaded($firebaseArray(query));},getTask:function getTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},addTask:function addTask(eventId,task,isOpen){var ref=db.ref('classMentors/eventTasks/'+eventId).push();var priority=task.priority;var promise;if(isOpen){task.openedAt={'.sv':'timestamp'};task.closedAt=null;}else{task.closedAt={'.sv':'timestamp'};task.openedAt=null;}$log.info('Adding task (id: "'+ref.key+'") to event id "'+eventId+'"');$log.info('Task: '+JSON.stringify(task));promise=priority?ref.setWithPriority(task,priority):ref.set(task);return promise.then(function(){return ref;});},updateTask:function updateTask(eventId,taskId,task){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var priority=task.priority;return ref.setWithPriority(task,priority);},openTask:function openTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var abort;return ref.transaction(function(task){if(!task.closedAt){return abort;}task.history=task.history||{};task.history[task.closedAt]='closed';task.openedAt={'.sv':'timestamp'};task.closedAt=null;return task;});},closeTask:function closeTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var abort;return ref.transaction(function(task){if(!task.openedAt){return abort;}task.history=task.history||{};task.history[task.openedAt]='opened';task.closedAt={'.sv':'timestamp'};task.openedAt=null;return task;});},showTask:function showTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/hidden');return ref.set(false);},hideTask:function hideTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/hidden');return ref.set(true);},archiveTask:function archiveTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/archived');return ref.set(true);},ParticipantsFirebaseArray:ParticipantsFirebaseArray,participants:function participants(eventId){return loaded(clmDataStore.events.ParticipantsFirebaseArray.create(eventId));},join:function join(event,pw){var refs,authData,eventId;if(!event||!event.$id){return $q.reject('Event was not provided');}eventId=event.$id;return spfAuthData.user().then(function(_authData){var uid=spfAuth.user&&spfAuth.user.uid;var publicId=_authData&&_authData.publicId;authData=_authData;if(!publicId){return $q.reject(clmDataStore.events.errNoPublicId);}refs={hashOptions:db.ref('classMentors/eventPasswords/'+eventId+'/options'),application:db.ref('classMentors/eventApplications/'+eventId+'/'+uid),participation:db.ref('classMentors/eventParticipants/'+eventId+'/'+publicId),profile:db.ref('classMentors/userProfiles/'+publicId+'/joinedEvents/'+eventId)};return refs;}).then(function(){return refs.hashOptions.once('value');}).then(function(snapshot){var options=snapshot.val();var hash=spfCrypto.password.fromSalt(pw,options.salt,options);return refs.application.set(hash);}).then(function(){return refs.participation.set({user:{displayName:authData.displayName,gravatar:authData.gravatar,school:cleanObj(authData.school)||null},joinedAt:{'.sv':'timestamp'}});}).then(function(){return refs.profile.set({createdAt:event.createdAt,featured:event.featured||false,owner:event.owner,title:event.title});});},leave:function leave(eventId){return spfAuthData.user().then(function(authData){return clmDataStore.events.removeParticpants(eventId,authData.publicId);});},removeParticpants:function removeParticpants(eventId,publicId){var profileRef=db.ref('classMentors/userProfiles/'+publicId+'/joinedEvents/'+eventId);var particpantRef=db.ref('classMentors/eventParticipants/'+eventId+'/'+publicId);var rankingRef=db.ref('classMentors/eventRankings/'+eventId+'/'+publicId);return profileRef.remove().then(function(){return $q.all([particpantRef.remove(),rankingRef.remove()]);}).catch(function(err){$log.error(err);return err;});},// to be true the task only need registration.
_hasRegistered:function _hasRegistered(task,clmProfile,spfProfile){var serviceId=task.serviceId;if(!task.serviceId||task.badge||task.singPathProblem){return false;}if(serviceId==='singPath'){return Boolean(spfProfile);}return clmProfile.services&&clmProfile.services[serviceId]&&clmProfile.services[serviceId].details&&clmProfile.services[serviceId].details.id;},_hasBadge:function _hasBadge(task,badges){if(!task.badge||!task.badge.id){return false;}var serviceId=task.serviceId;return task.badge&&task.badge.id&&badges[serviceId]&&badges[serviceId][task.badge.id];},_hasSolvedSingpathProblem:function _hasSolvedSingpathProblem(task,profile){if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return false;}var queueId='default';return clmDataStore.singPath.hasSolved(profile,task.singPathProblem.path.id,task.singPathProblem.level.id,task.singPathProblem.problem.id,queueId);},_isSolutionLinkValid:function _isSolutionLinkValid(task,solutions){return task.linkPattern&&solutions&&solutions[task.$id]&&solutions[task.$id].match&&solutions[task.$id].match(task.linkPattern);},_isResponseValid:function _isResponseValid(task,solutions){return task.textResponse&&solutions&&solutions[task.$id];},_hasDoneSurvey:function _hasDoneSurvey(task,solutions){return task.survey&&solutions&&solutions[task.$id];},_hasDoneMcq:function _hasDoneMcq(task,solutions){return task.mcqQuestions&&solutions&&solutions[task.$id];},_hasFormTeam:function _hasFormTeam(task,solutions){return task.formationPattern&&solutions&&solutions[task.$id];},_solvedProblems:function _solvedProblems(singPathProfile){var queueId='default';return clmDataStore.singPath.countSolvedSolution(singPathProfile,queueId);},_getProgress:function _getProgress(tasks,data){// Transform array of badges to a collection of badges.
var badges=Object.keys(data.badges).reduce(function(serviceBadges,serviceId){serviceBadges[serviceId]=data.badges[serviceId].reduce(function(results,badge){results[badge.id]=badge;return results;},{});return serviceBadges;},{});return tasks.reduce(function(progress,task){// We never recheck archived task completeness
if(task.archived){if(data.progress&&data.progress[task.$id]){progress[task.$id]=data.progress[task.$id];}return progress;}// We recheck solved closed tasks in case requirements changed.
if(task.closedAt&&!(data.progress&&data.progress[task.$id]&&data.progress[task.$id].completed)){return progress;}var solved=clmDataStore.events._isSolutionLinkValid(task,data.solutions)||clmDataStore.events._isResponseValid(task,data.solutions)||clmDataStore.events._hasRegistered(task,data.classMentors,data.singPath)||clmDataStore.events._hasBadge(task,badges)||clmDataStore.events._hasSolvedSingpathProblem(task,data.singPath)||clmDataStore.events._hasDoneSurvey(task,data.solutions)||clmDataStore.events._hasDoneMcq(task,data.solutions)||clmDataStore.events._hasFormTeam(task,data.solutions);if(solved){progress[task.$id]={completed:true};}return progress;},{});},_getRanking:function _getRanking(data){var ranking={singPath:clmDataStore.events._solvedProblems(data.singPath),codeCombat:data.badges.codeCombat.length,codeSchool:data.badges.codeSchool.length};ranking.total=Object.keys(ranking).reduce(function(sum,key){return sum+ranking[key];},0);ranking.user=data.classMentors.user;return ranking;},monitorEvent:function monitorEvent(event,tasks,participants,solutions,progress){var tid;var delay=300;var unWatchSolution=solutions.$watch(debouncedUpdate);var unWatchParticipants=participants.$watch(debouncedUpdate);function update(){return participants.map(function(participant){return clmDataStore.events.updateProgress(event,tasks,solutions,participant.$id,progress[participant.$id]);});}function debouncedUpdate(){if(tid){$timeout.cancel(tid);}tid=$timeout(update,delay,false);}debouncedUpdate();return{update:debouncedUpdate,unwatch:function stopMonitorEvent(){unWatchParticipants();unWatchSolution();}};},updateProgress:function updateProgress(event,tasks,solutions,publicId,userProgress){if(!publicId){return $q.reject('User public id is missing missing.');}if(!solutions||!solutions.$id||solutions.$id!==event.$id){return $q.reject('User solutions are missing');}var cmProfilePromise=clmDataStore.profile(publicId);var badgesPromise=cmProfilePromise.then(function(profile){return $q.all({// codeCombat: clmDataStore.services.codeCombat.fetchBadges(profile),
// codeSchool: clmDataStore.services.codeSchool.fetchBadges(profile)
});});// 1. load profile, badges and current progress
return $q.all({singPath:clmDataStore.singPath.profile(publicId),classMentors:cmProfilePromise,badges:badgesPromise,solutions:solutions[publicId]||{},progress:userProgress}).then(function(data){var rankingRef=db.ref('classMentors/eventRankings/'+event.$id+'/'+data.classMentors.$id);// var detailsRef = db.ref(`classMentors/eventParticipants/${event.$id}/${data.classMentors.$id}/user`);
// 4. save data
return $q.all([// 2. check completness and update progress if needed.
$q.resolve(clmDataStore.events._getProgress(tasks,data)).then(function(progress){var ref=db.ref('classMentors/eventProgress/'+event.$id+'/'+data.classMentors.$id);var updated=Object.keys(progress).some(function(taskId){var wasCompleted=data.progress&&data.progress[taskId]&&data.progress[taskId].completed;var isCompleted=progress&&progress[taskId]&&progress[taskId].completed;return isCompleted!==wasCompleted;});if(updated){return ref.set(progress);}return null;}),// 3. get ranking - if we get the ranking we could check it needs an update
rankingRef.set(clmDataStore.events._getRanking(data))// This was causing the endless loop of failed updates when viewing the ranking.
// 5. update participants data
// TODO: only update it if necessary.
// detailsRef.set({
//   displayName: data.classMentors.user.displayName,
//   gravatar: data.classMentors.user.gravatar,
//   school: data.classMentors.user.school || null
// })
]);}).catch(function(err){$log.error('Failed to update progress of '+publicId+': '+err.toString());});},/**
             * Only update the the current user profile and his/her event badge/problem solution.
             *
             * Only admin and event onwer can save the progress and ranking.
             *
             */updateCurrentUserProfile:function updateCurrentUserProfile(event,tasks,userSolutions,profile){if(!event||!event.$id||!userSolutions||!userSolutions.$id||!profile||!profile.$id){return $q.reject(new Error('Event, userSolutions or profile are not valid firebase object'));}function solvedTask(task,solutions){return Boolean(solutions[task.$id]);}return $q.all({// 1. Update user profile
codeCombat:clmDataStore.services.codeCombat.updateProfile(profile),codeSchool:clmDataStore.services.codeSchool.updateProfile(profile),singPath:clmDataStore.singPath.profile(profile.$id)}).then(function(data){return $q.all({singPath:data.singPath,badges:{codeCombat:clmDataStore.services.codeCombat.badges(profile),codeSchool:clmDataStore.services.codeSchool.badges(profile)}});}).then(function(data){var updatedTasks=tasks.filter(function(task){if(solvedTask(task,userSolutions)){return false;}return clmDataStore.events._hasRegistered(task,profile,data.singPath)||clmDataStore.events._hasSolvedSingpathProblem(task,data.singPath)||clmDataStore.events._hasBadge(task,data.badges);}).map(function(task){userSolutions[task.$id]=true;return task;});if(updatedTasks.length>0){userSolutions.$save();}return updatedTasks;}).catch(function(err){$log.error('Failed to update profile and soltuions of '+profile.$id+': '+err.toString());});},// newly added codes by ky
saveSurveyResponse:function saveSurveyResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyTask){var ref;if(!surveyResp){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+questionNumber);return ref.set(surveyResp);},saveSurveyResponseOnSubmit:function saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,motiResp){var ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyType+'/'+userId);return ref.set(motiResp);},saveSurveyEduDisResponse:function saveSurveyEduDisResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyTask,qnTitle){var ref;if(!surveyResp){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}if(!surveyTask){return $q.reject(new Error('No survey task provided'));}if(!qnTitle){return $q.reject(new Error('No question title provided'));}$log.info('qntitle isss',qnTitle);ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+qnTitle+'/'+questionNumber);return ref.set(surveyResp);},saveSurveyEduDisMultiResponse:function saveSurveyEduDisMultiResponse(responses,questionNumber,taskId,eventId,userId,surveyTask,qnTitle){var ref;if(!responses){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}if(!surveyTask){return $q.reject(new Error('No survey task provided'));}if(!qnTitle){return $q.reject(new Error('No question title provided'));}ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+qnTitle+'/'+questionNumber);return ref.set(responses);},submitSolution:function submitSolution(eventId,taskId,publicId,link){var ref;if(!eventId){return $q.reject(new Error('No event id provided'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!publicId){return $q.reject(new Error('No public id provided'));}ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+publicId+'/'+taskId);return ref.set(link);},setProgress:function setProgress(eventId,taskId,publicId,progress){var ref=db.ref('classMentors/eventProgress/'+eventId+'/'+publicId+'/'+taskId);return ref.set(progress[publicId][taskId]);},saveScore:function saveScore(eventId,publicId,taskId,score){var ref;if(!eventId){return $q.reject(new Error('No event id provided'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!publicId){return $q.reject(new Error('No public id provided'));}ref=db.ref('classMentors/eventScores/'+eventId+'/'+publicId+'/'+taskId);return ref.set(score);},addAssistant:function addAssistant(eventId,assistantId,assistant){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId);return ref.set(assistant);},getAssistants:function getAssistants(eventId){var ref=db.ref('classMentors/events/'+eventId+'/assistants');return loaded($firebaseArray(ref));},getAsstObj:function getAsstObj(eventId){var ref=db.ref('classMentors/events/'+eventId+'/assistants');return loaded($firebaseObject(ref));},enableAssistantEditing:function enableAssistantEditing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canEdit');return ref.set(true);},disableAssistantEditing:function disableAssistantEditing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canEdit');return ref.set(false);},enableAssistantReviewing:function enableAssistantReviewing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canReview');return ref.set(true);},disableAssistantReviewing:function disableAssistantReviewing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canReview');return ref.set(false);},removeAssistant:function removeAssistant(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId);return ref.remove();},questions:{/**
         * Return query to all event questions sorted by upvote.
         *
         * @param  {string}   eventId The event id to query question for.
         * @return {firebase.database.Reference}
         */allRef:function allRef(){},/**
         * Create a question on behave of the current user.
         *
         * @param  {string}   eventId The event id to submit the question for.
         * @param  {{title: string, body: string}} details Question details
         * @return {Promise<firebase.database.Reference,Error>}
         */create:function create(){},/**
         * Upvote a question.
         *
         * @param  {string}   eventId    The event id of the question.
         * @param  {string}   questionId The question id to upvote.
         * @return {Promise<void,Error>}
         */upVote:function upVote(){},answers:{/**
           * Return query to all the answer of a question sorted by upvote.
           *
           * @param  {string}   eventId    The event id of the question.
           * @param  {string}   questionId The question id to query comments for.
           * @return {firebase.database.Reference}
           */allRef:function allRef(){},/**
           * Create an answer on behave of the current user.
           *
           * @param  {string} eventId    The event id to submit the answer for.
           * @param  {string} questionId The question id to submit the answer for.
           * @param  {string} body       The answer body.
           * @return {Promise<firebase.database.Reference,Error>}
           */create:function create(){},/**
           * Mark an answer as the accepted answer to the question.
           *
           * @param  {string} eventId    The event id to mark the answer for.
           * @param  {string} questionId The question id to mark the answer for.
           * @param  {string} answerId   The answer id to mark as accepted.
           * @return {Promise<void,Error>}
           */accept:function accept(){},/**
           * Upvote a comment.
           *
           * @param  {string}   eventId    The event id of the question.
           * @param  {string}   questionId The question id of the answer.
           * @param  {string}   answerId   The answer id to upvote.
           * @return {Promise<void,Error>}
           */upVote:function upVote(){},/**
           * Add a comment to a question.
           *
           * @param  {string} eventId    The event id to add comment for.
           * @param  {string} questionId The question id to add comment for.
           * @param  {string} answerId   The answer id to add comment for.
           * @param  {string} body       The comment body.
           * @return {Promise<void,Error>}
           */comment:function comment(){}}}},services:clmServices,settings:{/**
       * Return Classmentors settings as a firebase synchronized array.
       *
       * Note that the array might not be loaded yet.
       *
       * @return {array}
       */get:function get(){return $firebaseArray(db.ref('classMentors/settings'));},/**
       * Return Classmentors settings as a firebase synchronized array.
       *
       * Note that the array might not be loaded yet.
       *
       * @return {object}
       */getObj:function getObj(){return $firebaseObject(db.ref('classMentors/settings'));}},singPath:{/**
       * Return user's singpath profile
       *
       */profile:function profile(publicId){return $q.resolve(publicId).then(function(id){var ref=db.ref('singpath/userProfiles/'+id);return loaded($firebaseObject(ref));});},queuedSolutions:function queuedSolutions(publicId){return $q.resolve(publicId).then(function(id){var ref=db.ref('singpath/userProfiles/'+id+'/queuedSolutions');return loaded($firebaseObject(ref));});},hasSolved:function hasSolved(profile,pathId,levelId,problemId,queueId){return profile&&profile.queuedSolutions&&profile.queuedSolutions[pathId]&&profile.queuedSolutions[pathId][levelId]&&profile.queuedSolutions[pathId][levelId][problemId]&&profile.queuedSolutions[pathId][levelId][problemId][queueId]&&profile.queuedSolutions[pathId][levelId][problemId][queueId].solved;},countSolvedSolution:function countSolvedSolution(profile,queueId){var solutions=profile&&profile.queuedSolutions;if(!solutions){return 0;}queueId=queueId||'default';return Object.keys(solutions).map(function(pathId){return Object.keys(solutions[pathId]).map(function(levelId){return Object.keys(solutions[pathId][levelId]).filter(function(problemId){return solutions[pathId][levelId][problemId][queueId]&&solutions[pathId][levelId][problemId][queueId].solved===true;}).length;}).reduce(function(sum,count){return sum+count;},0);}).reduce(function(sum,count){return sum+count;},0);},countSolvedSolutionPerLanguage:function countSolvedSolutionPerLanguage(profile,queueId){var paths=profile.queuedSolutions||{};queueId=queueId||'default';return Object.keys(paths).reduce(function(result,pathKey){var levels=paths[pathKey]||{};Object.keys(levels).forEach(function(levelKey){var problems=levels[levelKey]||{};Object.keys(problems).forEach(function(problemKey){var language=problems[problemKey][queueId].language;if(problems[problemKey][queueId]&&problems[problemKey][queueId].solved){result[language]=(result[language]||0)+1;}});});return result;},{});},/**
       * Return a map of available paths at SingPath
       *
       */paths:function paths(){var ref=db.ref('singpath/paths');return ref.once('value').then(function(snapshot){var paths=snapshot.val();return Object.keys(paths).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:paths[id].title,url:clmServicesUrl.singPath+'/#paths/'+id+'/levels'};return all;},{});});},/**
       * Return a map of available levels at SingPath for a specific path
       *
       */levels:function levels(pathId){var ref=db.ref('singpath/levels/'+pathId);return ref.once('value').then(function(snapshot){var levels=snapshot.val();return Object.keys(levels).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:levels[id].title,url:clmServicesUrl.singPath+'/#paths/'+pathId+'/levels/'+id+'/problems'};return all;},{});});},/**
       * Return a map of available problems at SingPath for a specific level
       *
       */problems:function problems(pathId,levelId){var ref=db.ref('singpath/problems/'+pathId+'/'+levelId);return ref.once('value').then(function(snapshot){var problems=snapshot.val();return Object.keys(problems).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:problems[id].title,url:clmServicesUrl.singPath+'/#paths/'+pathId+'/levels/'+levelId+'/problems/'+id+'/play'};return all;},{});});},/**
       * Return a promise resolving to all problems as as simple object
       * (Not a firebase object).
       *
       * @return {Promise}
       */allProblems:function allProblems(){var ref=db.ref('singpath/problems');return ref.once('value').then(function(snapshot){return snapshot.val();});},countProblems:function countProblems(paths){return Object.keys(paths||{}).reduce(function(result,pathKey){var levels=paths[pathKey]||{};Object.keys(levels).forEach(function(levelKey){var problems=levels[levelKey]||{};Object.keys(problems).forEach(function(problemKey){var language=problems[problemKey].language;result[language]=(result[language]||0)+1;});});return result;},{});}}};// TODO: rename.
clmDataStore.badges={all:function all(){return $q.all(Object.keys(clmDataStore.services).reduce(function(all,serviceId){all[serviceId]=clmDataStore.services[serviceId].availableBadges();return all;},{}));}};return clmDataStore;}/**
 * classmentors/filters - shared filter factories.
 */function cmTruncateFilterFactory(){return function cmTruncate(s,limit){if(!s||!s.length||!limit){return'';}if(s.length<=limit){return s;}return s.slice(0,limit)+'...';};}function cmTruncateFilterBooleanFactory(){return function cmTruncateBoolean(s,limit){if(!s||!s.length||!limit){return{content:'',truncated:false};}if(s.length<=limit){return{content:s,truncated:false};}return{content:s.slice(0,limit)+'...',truncated:true};};}function showSchoolFilterFactory(){return function showSchool(s){var obj=JSON.parse(s);return obj.school.name+'...';};}function showTeamMembersFilterFactory(){return function(team){var output=Object.keys(team);function filterUserID(id){if(id!="currentSize"&&id!="maxSize"&&id!="$id"&&id!="$priority"&&id!="$$hashKey"){return id;}}return output.filter(filterUserID);};}// export function reverseArray (){
//   return function(items) {
//     return items.slice().reverse();
//   };
// };
/**
 * classmentors/directives.js - shared directive factories / components options.
 *//**
 * Validate that an input value contains a pattern.
 *
 * TODO: replace with ngPattern?
 */function cmContainsFactory(){return{restrict:'A',scope:false,require:'ngModel',link:function cmContainsPostLink(scope,e,attr,model){var pattern=scope.$eval(attr.cmContains);scope.$watch(attr.cmContains,function(value){pattern=value;});model.$validators.cmContains=function(modelValue,viewValue){var patt=new RegExp(pattern);if(modelValue.indexOf("http:")>-1&&viewValue.indexOf("http:")>-1){return true;}else{return patt.test(modelValue)&&patt.test(viewValue);}//return viewValue && viewValue.indexOf(pattern) !== -1;
};}};}/**
 * Update navBar with a title and no action.
 * @param {spfNavBarService} spfNavBarService
 */function AceController(spfNavBarService){spfNavBarService.update('Ace of Coders');}/**
 * Route resolver helper.
 *
 * This is not a service; this is not generating a singleton. If used in a route
 * configuration "resolve" map, the function will be run on each resolution of
 * that route.
 *
 * @param  {Object}  $http       $http service.
 * @param  {string}  aceStatsUrl URL to fetch stats from
 * @return {Promise}
 */function getStats($http,aceStatsUrl){return $http.get(aceStatsUrl).then(function(response){return response.data;});}/**
 * Config route for ace of coders views.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         classmentors route map.
 */function configRoute($routeProvider,routes){$routeProvider.when(routes.aceOfCoders,{template:'<ace stats="$resolve.stats"></ace>',resolve:{stats:getStats}}).otherwise(routes.home);}function editMcqController(initialData,challengeService,$filter,$mdDialog,urlFor,$location){var self=this;// Checks if all questions have at least one answer
self.task=initialData.data.task;// console.log("the initial edit data is........", initialData);
var questions=angular.fromJson(self.task.mcqQuestions);var savedAnswers=angular.fromJson(initialData.savedAnswers.$value);self.questions=builtMCQ(questions,savedAnswers);function builtMCQ(questions,savedAnswers){for(var i=0;i<questions.length;i++){questions[i].answers=savedAnswers[i];}return questions;}self.isMcqValid=checkMCQValid();// Save mcq question to database.
//todo: clean up the form before submitting. e.g. when toggled, vid entered, but toggled off
self.save=function(questions){var setAnswers=[];for(var i=0;i<questions.length;i++){var answers=questions[i].answers;setAnswers.push(answers);delete questions[i].answers;}// Check does questions contain answers?
// console.log(questions);
// Check answer list
// console.log(setAnswers);
// Change questions into JSON text
var answersJsonText=angular.toJson(questions);// console.log(answersJsonText);
// Save function defined in challenges.js
// Parameters: event, taskid, task, taskType, isOpen
var event=initialData.data.event;var task=self.task;var taskId=task.$id;var taskType=initialData.data.taskType;var isOpen=initialData.data.isOpen;task.mcqQuestions=answersJsonText;task.answers=angular.toJson(setAnswers);// console.log(task);
challengeService.update(event,taskId,task,taskType,isOpen);};// Add question when add question button is clicked
self.addQuestion=function(){var question={text:"",answers:[],options:[{text:""}]};// Push new question object into questions list
self.questions.push(question);checkMCQValid();};function checkMCQValid(){for(var i=0;i<self.questions.length;i++){if(self.questions[i].answers.length==0){self.isMcqValid=false;return;}}self.isMcqValid=true;}self.removeQuestion=function(ev,itemIndex){var confirm=$mdDialog.confirm().title('Would you like to delete this question?').textContent('This question and its option(s) will be deleted. Do you wish to proceed?').ariaLabel('Question deletion').targetEvent(ev).ok('Delete').cancel('Do not delete');$mdDialog.show(confirm).then(function(){if(itemIndex>-1){var removed=self.questions.splice(itemIndex,1);console.log('Removed : ',removed);console.log(self.questions);checkMCQValid();}});};// Functionality for toggleOption between single answer and multi ans functionality
// Needs further review though..
// Is it better to set the answers as default multiple and the users will just set 1..n answers?
self.toggleOption=function(question,itemIndex){console.log('Index being deleted...',itemIndex);var idx=question.answers.indexOf(itemIndex);if(idx>-1){var removed=question.answers.splice(idx,1);console.log(removed);}else{question.answers.push(itemIndex);}console.log(question.answers);checkMCQValid();};// Add new option to question
self.addOption=function(question){// Get options
question.options.push({text:""});checkMCQValid();};// Delete options
self.removeOption=function(question,itemIndex){question.options.splice(itemIndex,1);var idxOfAns=question.answers.indexOf(itemIndex);if(idxOfAns>-1){var removedAns=question.answers.splice(idxOfAns,1);console.log('Removed an answer: ',removedAns);}for(var i=0;i<question.answers.length;i++){var ans=question.answers[i];if(ans>itemIndex){question.answers[i]=ans-1;}}console.log(question.options);checkMCQValid();};//todo:add back button controls here
self.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('Would you like to discard your changes?').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Cancel Editing').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
//todo: link back to previous page
//$location.path(urlFor('editEventTask', {eventId: initialData.event.$id},{taskId: task.$id}));
$location.path(urlFor('oneEvent',{eventId:initialData.event.$id}));});};}function startMcqController(initialData,challengeService,clmDataStore,$location,$mdDialog,urlFor,spfAlert,$scope){var self=this;var mcqInvalid=true;$scope.$on("$routeChangeStart",function(event,next,current){if(mcqInvalid){if(!confirm("You have not finished this survey. Are you sure you want to continue? All data will be lost")){event.preventDefault();}}});var data=initialData;var eventId=data.eventId;var taskId=data.taskId;var participant=data.currentUser;var userId=data.currentUser.publicId;var correctAnswers=angular.fromJson(data.correctAnswers.$value);console.log('correctans:',correctAnswers);self.task=data.task;var quesFromJson=angular.fromJson(self.task.mcqQuestions);self.questions=quesFromJson;self.multipleAns=initMultipleAns(correctAnswers);self.isMcqValid=false;// what is dah output?
//console.log(self.multipleAns);
function initMultipleAns(correctAnswers){var multipleAnsList=[];for(var i=0;i<correctAnswers.length;i++){if(correctAnswers[i].length>1){multipleAnsList.push(true);self.questions[i].answers=[];}else{multipleAnsList.push(false);}}return multipleAnsList;}self.toggle=function(list,item){console.log(list);var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}};function arraysEqual(arr1,arr2){if(arr1.length!==arr2.length)return 0;for(var i=arr1.length;i--;){if(arr1[i]!==arr2[i])return 0;}return 1;}function markQuestions(submittedAnswers){console.log('Correct Answers...',correctAnswers);console.log('Submitted Answers...',submittedAnswers);var score=0;for(var i=0;i<submittedAnswers.length;i++){score+=arraysEqual(submittedAnswers[i],correctAnswers[i]);}return score;}self.submit=function(){mcqInvalid=false;var submission={};var userAnswers=[];for(var i=0;i<self.questions.length;i++){var ans=self.questions[i].answers;if(typeof ans=='string'){ans=angular.fromJson('['+ans+']');}userAnswers.push(ans);}submission.userAnswers=userAnswers;var score=markQuestions(userAnswers);var answerString=angular.toJson(submission);clmDataStore.events.submitSolution(eventId,taskId,participant.publicId,answerString).then(clmDataStore.events.saveScore(eventId,participant.publicId,taskId,score),spfAlert.success('Your Mcq responses are saved.'),//todo:set progress to true, and save the progress into firebase
initialData.progress[userId]={taskId:taskId},initialData.progress[userId][taskId]={completed:true},// clmDataStore.events.setProgress(eventId, taskId, userId, initialData.progress),
$location.path(urlFor('oneEvent',{eventId:eventId}))).catch(function(err){$log.error(err);spfAlert.error('Failed to save the mcq responses.');return err;});};self.cancel=function(){$mdDialog.hide();};self.discardChanges=function(ev){mcqInvalid=false;var confirm=$mdDialog.confirm().title('Would you like to discard your answers?').textContent('All of your answers will be discarded. Are you sure you want to continue?').ariaLabel('Discard answers').targetEvent(ev).ok('Cancel Answering').cancel('Continue Answering');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
//todo: link back to previous page
$location.path(urlFor('oneEvent',{eventId:eventId}));});};}function newMcqController(initialData,challengeService,$filter,$mdDialog,urlFor,$location){var self=this;// Checks if all questions have at least one answer
self.isMcqValid=false;self.task=initialData.task;self.questions=[{text:"",answers:[],options:[{text:""}]}];// Save mcq question to database.
//todo: clean up the form before submitting. e.g. when toggled, vid entered, but toggled off
self.save=function(questions){var setAnswers=[];for(var i=0;i<questions.length;i++){var answers=questions[i].answers;setAnswers.push(answers);delete questions[i].answers;}// Check does questions contain answers?
console.log(questions);// Check answer list
console.log(setAnswers);// Change questions into JSON text
var answersJsonText=angular.toJson(questions);console.log(answersJsonText);// Save function defined in challenges.js
// Parameters: event, taskid, task, taskType, isOpen
var event=initialData.event;var task=initialData.task;var taskId=initialData.taskId;var taskType=initialData.taskType;var isOpen=initialData.isOpen;task.mcqQuestions=answersJsonText;task.answers=angular.toJson(setAnswers);challengeService.save(event,taskId,task,taskType,isOpen);};// Add question when add question button is clicked
self.addQuestion=function(){var question={text:"",answers:[],options:[{text:""}]};// Push new question object into questions list
self.questions.push(question);checkMCQValid();};function checkMCQValid(){for(var i=0;i<self.questions.length;i++){if(self.questions[i].answers.length==0){self.isMcqValid=false;return;}}self.isMcqValid=true;}self.removeQuestion=function(ev,itemIndex){var confirm=$mdDialog.confirm().title('Would you like to delete this question?').textContent('This question and its option(s) will be deleted. Do you wish to proceed?').ariaLabel('Question deletion').targetEvent(ev).ok('Delete').cancel('Do not delete');$mdDialog.show(confirm).then(function(){if(itemIndex>-1){var removed=self.questions.splice(itemIndex,1);console.log('Removed : ',removed);console.log(self.questions);checkMCQValid();}});};// Functionality for toggleOption between single answer and multi ans functionality
// Needs further review though..
// Is it better to set the answers as default multiple and the users will just set 1..n answers?
self.toggleOption=function(question,itemIndex){console.log('Index being deleted...',itemIndex);var idx=question.answers.indexOf(itemIndex);if(idx>-1){var removed=question.answers.splice(idx,1);console.log(removed);}else{question.answers.push(itemIndex);}console.log(question.answers);checkMCQValid();};// Add new option to question
self.addOption=function(question){// Get options
question.options.push({text:""});checkMCQValid();};// Delete options
self.removeOption=function(question,itemIndex){question.options.splice(itemIndex,1);var idxOfAns=question.answers.indexOf(itemIndex);if(idxOfAns>-1){var removedAns=question.answers.splice(idxOfAns,1);console.log('Removed an answer: ',removedAns);}for(var i=0;i<question.answers.length;i++){var ans=question.answers[i];if(ans>itemIndex){question.answers[i]=ans-1;}}console.log(question.options);checkMCQValid();};//todo:back button add here
self.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('Would you like to discard your changes?').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Cancel Editing').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
//todo: link back to previous page
//$location.path(urlFor('addEventTask', {eventId: initialData.event.$id}));
$location.path(urlFor('oneEvent',{eventId:initialData.event.$id}));});};}function starMcqTmpl(){return mcqStart;}//this export function return the template when creating a new mcq challenge
function newMcqTmpl(){return mcqTmpl;}function editMcqTmpl(){return mcqEditTmpl;}function showSurveyTmpl(){return surveyTmpl;}function createTeamActivityInitialData($q,eventService,clmDataStore){var data=eventService.get();console.log("team data is:",data);return clmDataStore.events.participants(data.event.$id).then(function(result){return{data:data,participants:result};});}function createTeamActivityController($q,initialData,clmDataStore,$location,urlFor,eventService){var self=this;console.log("initialdata are",initialData);// event variable consist of event id,timecreated,owner and event title
self.event=initialData.data.event;//task variable consist of description,title of task, showProgress, priority, archived(t/f)
self.task=initialData.data.task;self.taskType=initialData.data.taskType;self.participants=initialData.participants;self.teamsMaximumStudents=0;self.taskType=initialData.data.taskType;self.activityType=null;self.newExistingTeams=null;self.teamFormationMethod=null;self.teamFormationParameter=null;self.submit=function(){self.task.activityType=self.activityType;self.task.newExistingTeams=self.newExistingTeams;self.task.teamFormationMethod=self.teamFormationMethod;self.task.teamFormationParameter=self.teamFormationParameter;self.task.startIRAT=true;self.event.teams=formTeams(self.teamFormationMethod,self.teamFormationParameter,self.participants.length);eventService.set({taskType:self.taskType,event:self.event,task:self.task,isOpen:initialData.data.isOpen});$location.path(urlFor('viewMcq'));};function formTeams(method,methodParameter,participants){var teams=[];var teamStructure=[];console.log('Total participants :',participants);if(method=='noOfTeams'){//initialze teamStructure with team size of 0 each
for(var i=0;i<methodParameter;i++){teamStructure.push(0);}console.log('Line reaches here');console.log('teamStructure :',teamStructure);//add 1 to each team until there are no more participants left
for(var i=0;i<participants;i++){teamStructure[i%methodParameter]+=1;}}else{//else by teamSize
while(participants>methodParameter){teamStructure.push(methodParameter);participants-=methodParameter;}// split up remaining participants
for(var i=0;i<participants;i++){teamStructure[i%teamStructure.length]+=1;}}//Create 'teams'
for(var i=0;i<teamStructure.length;i++){// teams[i] = populateTeam(teamStructure[i]);
teams.push({maxSize:teamStructure[i],currentSize:0});}console.log('Teams is: ',teams);return teams;}function populateTeam(members){var team={};console.log(members);for(var i=0;i<members;i++){team[i]="";}console.log(angular.toJson(team));return team;}// if number of teams, "Each team will have a maximum enrollment of # students"; #= roundup (totalParticipants / # of teams)
// if max number of student, "You will have # teams"; #= round up (totalParticipants / # stud per team)
self.calculateTeamMaximumStudent=function(noTeamsOrStudents){// var noTeamsOrStudents = self.teamFormationInput;
var totalParticipants=self.participants.length;console.log("number is ",noTeamsOrStudents);console.log("cal",Math.ceil(totalParticipants/noTeamsOrStudents));self.teamsMaximumStudents=Math.ceil(totalParticipants/noTeamsOrStudents)?Math.ceil(totalParticipants/noTeamsOrStudents):0;};self.calculationResult=function(){return self.teamsMaximumStudents;};}function startTRATInitialData($q,spfAuthData,eventService,clmDataStore,firebaseApp,$firebaseObject,$firebaseArray,$route){/*
     TODO:
     1. Load Teams
     2. Load Team Log
     3. Load Answers [done]
     */var data=eventService.get();var db=firebaseApp.database();console.log("my data is:",data);var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;// var teamLogPromise = null;
var tratId=taskId;var userTeamId=null;var userPublicId=data.participant.$id;console.log("userpublicid iss:",data.participant);var teamFormationRefKey=data.task.teamFormationRef;var eventTeamRef=db.ref('classMentors/eventTeams/'+eventId+'/'+teamFormationRefKey);// Get user's teamId
// $firebaseArray(eventTeamRef).$loaded()
//     .then(function(teams){
//         // Sanity check that teams are retrieved
//         console.log(teams);
//         for(var i = 0; i < teams.length; i ++){
//             var team = teams[i];
//             if(team[userPublicId]){
//                 userTeamId = team.$id
//             }
//         }})
//     .then(getTeamLog(userTeamId));
// function getTeamLog(teamId){
//     var eventTeamsLogRef = db.ref(`classMentors/eventTeamsLog/${eventId}/${teamId}`);
//     teamLogPromise = $firebaseObject(eventTeamsLogRef).$loaded();
// }
return $q.all({currentUser:spfAuthData.user(),correctAnswers:clmDataStore.events.getTaskAnswers(data.eventId,data.task.taskFrom).then(function(data){return data.$value;}),progress:clmDataStore.events.getProgress(data.eventId).then(function(data){return data;}),teamRefId:teamFormationRefKey,questions:angular.fromJson(data.task.mcqQuestions),tratId:tratId,teamAndteamId:$firebaseArray(eventTeamRef).$loaded().then(function(teams){console.log("teams in resolve:",spfAuthData.user());// Sanity check that teams are retrieved
for(var i=0;i<teams.length;i++){var team=teams[i];if(team[userPublicId]){return team.$id;}}}).then(function(teamId){var teamRef=db.ref('classMentors/eventTeams/'+eventId+'/'+teamFormationRefKey+'/'+teamId);return{team:$firebaseArray(teamRef).$loaded(function(team){var outputTeam=[];for(var i=0;i<team.length;i++){var idAtIdx=team[i].$id;if(idAtIdx!='currentSize'&&idAtIdx!='maxSize'){outputTeam.push(team[i]);}}return outputTeam;}).then(function(result){return result;}),// .then(function (team) {
//     var outputTeam = [];
//     for (var i = 0; i < team.length; i++) {
//         var idAtIdx = team[i].$id;
//         if (idAtIdx != 'currentSize' && idAtIdx != 'maxSize') {
//             outputTeam.push(team[i]);
//         }
//     }
//     return outputTeam;
// }),
teamId:teamId};}),eventId:eventId,teamFormId:teamFormationRefKey});// return $q.all ({
//     currentUser: spfAuthData.user(),
//     correctAnswers: clmDataStore.events.getTaskAnswers(data.eventId, data.task.taskFrom),
//     progress: clmDataStore.events.getProgress(data.eventId),
//     questions: null,
//     teamLog: null,
//     tratId: null,
//     teamId: null,
// }).then (function (result){
//     return {
//         data: data,
//         correctAnswers: result.answers,
//         currentUser: result.currentUser,
//         progress: result.getProgress
//     }
// });
}function startTRATController($q,initialData,clmDataStore,$location,urlFor,firebaseApp,$firebaseObject,$firebaseArray,spfAlert){// Sanity check
console.log('Initial data contains: ',initialData);var self=this;var db=firebaseApp.database();self.index=0;// Inititalize Question and Question's option(s)
self.questions=initialData.questions;self.question=self.questions[self.index];self.options=self.question.options;var userPublicId=initialData.currentUser.publicId;console.log(initialData.currentUser);self.eventId=initialData.eventId;var teamAndteamId=initialData.teamAndteamId;console.log(initialData.teamAndteamId);self.teamId=teamAndteamId.teamId;self.team=null;teamAndteamId.team.then(function(result){self.team=result;var teamleader=self.team[self.index%self.team.length];if(userPublicId==teamleader.$id){self.teamleader="You are the team leader";}else{self.teamleader=teamleader.displayName+" is the team leader";}});self.tratId=initialData.tratId;self.teamFormId=initialData.teamFormId;var userAnswers=[];self.multiAns=[];self.correctAnswers=angular.fromJson(initialData.correctAnswers);var teamLogRef=db.ref('classMentors/eventTeamsLog/'+self.teamFormId+'/'+self.teamId);self.multipleAns=function(){var multipleAnsArray=[];for(var i=0;i<self.correctAnswers.length;i++){var ans=self.correctAnswers[i];if(ans.length>1){multipleAnsArray.push(true);}else{multipleAnsArray.push(false);}}console.log('Sanity check: ',multipleAnsArray);return multipleAnsArray;}();console.log(self.multipleAns);// Will this overwrite the reference when called by other clients?
var teamAnsRef=db.ref('classMentors/eventSolutions/'+self.eventId+'/'+self.teamId+'/'+self.tratId);// teamAnsRef.set('init');
//Init team log
self.teamLog=null;function refreshLog(){$firebaseArray(teamLogRef.orderByKey()).$loaded(function(data){self.teamLog=data;});}refreshLog();// $firebaseArray(teamLogRef)
//     .$loaded(function(data){
//         console.log(data);
//     });
// test this later
var updateLog=function updateLog(msg){teamLogRef.push().set(msg).then(function(){console.log('Msg has been pushed');refreshLog();});};self.submitTrat=function(){$location.path(urlFor('oneEvent'));};self.onChange=function(){var msg={user:userPublicId,text:self.options[self.selected].text,selected:self.selected,timestamp:TIMESTAMP};updateLog(msg);};function teamAns(answer){// Check which user`s answer is used for submission.
// console.log(self.team);
var userIdx=self.index%self.team.length;console.log("userIdx iss:",userIdx);console.log("team length is:",self.team.length);var selectedUserPubId=self.team[userIdx].$id;// Check if current user is selected.
if(selectedUserPubId==userPublicId){var submission={submitBy:userPublicId,answer:angular.toJson(answer)};teamAnsRef.push(submission);}// Submit answer
// Optional: Add to log; The next user who`s answer will be submited next.
}self.nextQuestion=function(){// Check if all members have submit
// Check if user's answers is the answer that will be saved under team record.
// 
if(self.selected!=null){var tempArray=[];tempArray.push(self.selected);userAnswers.push(tempArray);teamAns(tempArray);self.selected=null;}else{// Multi-ans questions
userAnswers.push(self.multiAns);teamAns(self.multiAns);self.multiAns=[];}if(self.index+1<self.questions.length){self.index+=1;self.question=self.questions[self.index];self.options=self.question.options;}else{console.log(userAnswers);// Mark indiv
// Mark team
// If current user is the last user to submit
// var indivScore = markQuestions(answers);
var userIdx=self.index%self.team.length;console.log(userIdx);console.log(self.team);var selectedUserPubId=self.team[userIdx].$id;if(selectedUserPubId==userPublicId){$firebaseArray(teamAnsRef).$loaded(function(teamAnswers){var answers=[];var score=null;for(var i=0;i<teamAnswers.length;i++){var teamAnswer=teamAnswers[i];if(teamAnswer.answer){answers.push(angular.fromJson(teamAnswer.answer));}}return markQuestions(answers);}).then(function(score){//   saveScore: function(eventId, publicId, taskId, score)
for(var i=0;i<self.team.length;i++){var publicId=self.team[i].$id;clmDataStore.events.saveScore(self.eventId,publicId,self.tratId,score);}}).then(function(){console.log('Sucess!');var indivSolutionRef=db.ref('classMentors/eventSolutions/'+self.eventId+'/'+userPublicId+'/'+self.tratId);return indivSolutionRef.set(angular.toJson(userAnswers));}).then(function(){clmDataStore.events.submitSolution(self.eventId,self.tratId,initialData.currentUser.publicId,"Completed");spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));});}else{var indivSolutionRef=db.ref('classMentors/eventSolutions/'+self.eventId+'/'+userPublicId+'/'+self.tratId);indivSolutionRef.set(angular.toJson(userAnswers)).then(function(){clmDataStore.events.submitSolution(self.eventId,self.tratId,initialData.currentUser.publicId,"Completed");spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));});}// $location.path(urlFor('oneEvent', {eventId: event.$id}));
}};function arraysEqual(arr1,arr2){if(arr1.length!==arr2.length)return 0;if(arr1.length>1&&arr2.length>1&&arr1.length==arr2.length){for(var i=arr1.length;i--;){if(arr2.indexOf(arr1[i])<0)return 0;}}else{for(var i=arr1.length;i--;){if(arr1[i]!==arr2[i])return 0;}}return 1;}self.toggle=function(list,item){console.log(list);var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}var selected=[];for(var i=0;i<list.length;i++){var text=self.options[list[i]].text;selected.push(text);}var msg={user:userPublicId,text:selected,selected:list,timestamp:TIMESTAMP};updateLog(msg);};function markQuestions(submittedAnswers){console.log('Correct Answers...',self.correctAnswers);console.log('Submitted Answers...',submittedAnswers);var score=0;for(var i=0;i<self.correctAnswers.length;i++){score+=arraysEqual(submittedAnswers[i],self.correctAnswers[i]);}return score;}}// TODO: Put out of use.
function tratQuestionFactory($q,spfAuthData,eventService,clmDataStore){var self=this;self.data=eventService.get();console.log("my data is:",self.data);// var question = $q.all ({
//     questions: angular.fromJson(data.task.mcqQuestions)
// }).then (function (result){
//     console.log("testing questions:", result);
//     return result;
//
// });
// return $q.all({
//     getQuestion: function(id){
//         var question = angular.fromJson(self.data.task.mcqQuestions);
//         if(id < question.length){
//             return question[id];
//         }else{
//             return false;
//         }
//     } 
// });
// Weird bugs often happen here. Could be bcoz of promise objects not resolved.
return{getQuestion:function getQuestion(id){var question=angular.fromJson(self.data.task.mcqQuestions);if(id<question.length){return question[id];}else{return false;}}};}//TODO: Add config for routing to various challenges
function configRoute$1($routeProvider,routes){$routeProvider.when(routes.viewMcq,{template:newMcqTmpl,controller:newMcqController,controllerAs:'ctrl',resolve:{initialData:createMCQInitialData}}).when(routes.editMcq,{template:editMcqTmpl,controller:editMcqController,controllerAs:'ctrl',resolve:{initialData:editMCQInitialData}}).when(routes.viewSurvey,{template:showSurveyTmpl,controller:surveyFormEvent,controllerAs:'ctrl',resolve:{initialData:getTaskSurveyValues}}).when(routes.startMcq,{template:starMcqTmpl,controller:startMcqController,controllerAs:'ctrl',resolve:{initialData:startMCQInitialData}}).when(routes.createTeamActivity,{template:teamActivityCreateTmpl,controller:createTeamActivityController,controllerAs:'ctrl',resolve:{initialData:createTeamActivityInitialData}}).when(routes.viewIRAT,{template:teamIRATTmpl,controller:undefined,controllerAs:'ctrl',resolve:{initialData:createTeamActivityInitialData}}).when(routes.viewTRAT,{// Start TRAT.
template:teamTRATTmpl,controller:startTRATController,controllerAs:'ctrl',resolve:{initialData:startTRATInitialData}});}function editMCQInitialData($q,eventService,clmDataStore){var data=eventService.get();console.log(data);return clmDataStore.events.getTaskAnswers(data.event.$id,data.task.$id).then(function(result){return{data:data,savedAnswers:result};},function(error){console.log(error);});}// Initial data for starting an MCQ
//todo: tidy up the codes; should be using promises to access some objects as well as validation
function startMCQInitialData($q,spfAuthData,eventService,clmDataStore,$route,firebaseApp,$firebaseObject){//promise object
// var currentUser = spfAuthData.user().catch(noop);
var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;//retrieve mcq questions
var db=firebaseApp.database();return $q.all({currentUser:spfAuthData.user(),answers:clmDataStore.events.getTaskAnswers(eventId,taskId),getProgress:clmDataStore.events.getProgress(eventId),task:clmDataStore.events.getTask(eventId,taskId)}).then(function(result){console.log("result isss:",result);return{eventId:eventId,taskId:taskId,task:result.task,correctAnswers:result.answers,currentUser:result.currentUser,progress:result.getProgress};});// return clmDataStore.events.getTaskAnswers(data.eventId, data.taskId).then(
//       function(result){
//         return {
//           data: data,
//           correctAnswers: result,
//             currentUser: currentUser
//         }
//       }, function(error){
//         console.log(error);
//       }
//   );
}// Initial data for creating MCQ
function createMCQInitialData($q,eventService){var data=eventService.get();return data;}function scrollBottom(){return{scope:{schrollBottom:"="},link:function link(scope,element){scope.$watchCollection('schrollBottom',function(newValue){if(newValue){$(element).scrollTop($(element)[0].scrollHeight);}});}};}//TODO: Generic save function
function challengeServiceFactory($q,$route,spfAuthData,clmDataStore,$log,spfAlert,$location,urlFor,firebaseApp,$firebaseArray,$firebaseObject){return{save:function save(event,taskId,task,taskType,isOpen){// Get firebase database object.
var db=firebaseApp.database();var copy=cleanObj(task);var answers=copy.answers;console.log('COPY IS ... ',copy);console.log('COPY IS!! ',copy);self.creatingTask=true;if(taskType==='multipleChoice'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;var ref=clmDataStore.events.addTaskWithAns(event.$id,copy,isOpen,answers);ref.then(function(){spfAlert.success('Task created');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to created new task');}).finally(function(){self.creatingTask=false;});}else if(taskType==='teamActivity'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;if(copy.link==""){delete copy.link;}console.log(copy);/*TODO:
                 1. Modify 'addTaskWithAns' to return firebase reference too? hmm.
                 2. Refactor once (1) is agreed upon.
                 */// Get firebase task reference.
var taskRef=db.ref('classMentors/eventTasks/'+event.$id);// Get root reference; Returns thenable reference
var ref=taskRef.push();var taskAnsRef=db.ref('classMentors/eventAnswers/'+event.$id+'/'+ref.key);var teamFormationTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var tratTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();console.log('Team Formation key: ',taskAnsRef.key);var eventTeamsRef=db.ref('classMentors/eventTeams/'+event.$id+'/'+teamFormationTaskRef.key);console.log(event.$id);// Check If key
console.log(teamFormationTaskRef.key);var priority=copy.priority;// Set openedAt, closedAt timestamp.
if(isOpen){copy.openedAt={'.sv':'timestamp'};copy.closedAt=null;}else{copy.closedAt={'.sv':'timestamp'};copy.openedAt=null;}// Save IRAT.
var promise=priority?ref.setWithPriority(copy,priority):ref.set(copy);promise.then(function(){// Save answers.
console.log('Task answers set.');console.log(taskAnsRef);return taskAnsRef.set(answers);}).then(function(){// Define 'teamFormationTask'.
var teamFormationTask={taskFrom:ref.key,title:copy.title,description:"Click Below To Join Team",formationPattern:true,closedAt:{'.sv':'timestamp'},showProgress:copy.showProgress,archived:false,teamFormationMethod:copy.teamFormationMethod};// Create 'teams' in 'eventTeams'.
for(var i=0;i<event.teams.length;i++){var team=event.teams[i];// console.log('Team here is: ', team);
console.log('Team is: ',team);eventTeamsRef.push(team).then(function(thenableRef){console.log('Team reccorded at: ',thenableRef.key);// var teamLog = {
//     init: {'.sv': 'timestamp'}
// }
var eventTeamsLogRef=db.ref('classMentors/eventTeamsLog/'+teamFormationTaskRef.key+'/'+thenableRef.key);eventTeamsLogRef.set(teamLog);});}console.log('Team answers set.');return priority?teamFormationTaskRef.setWithPriority(teamFormationTask,priority):teamFormationTaskRef.set(teamFormationTask);}).then(function(){console.log('TeamFormationTask set.');var tratTask={taskFrom:ref.key,teamFormationRef:teamFormationTaskRef.key,title:copy.title,description:"Click Below to Start TRAT",startTRAT:true,closedAt:{'.sv':'timestamp'},showProgress:copy.showProgress,archived:false,teamFormationMethod:copy.teamFormationMethod,mcqQuestions:copy.mcqQuestions};return priority?tratTaskRef.setWithPriority(tratTask,priority):tratTaskRef.set(tratTask);}).then(function(){console.log('TRAT set.');console.log('Events Created');spfAlert.success('Task saved');$location.path(urlFor('editEvent',{eventId:event.$id}));});}},update:function update(event,taskId,task,taskType,isOpen){var copy=cleanObj(task);var answers=copy.answers;if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else if(taskType==='multipleChoice'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;var ref=clmDataStore.events.updateTaskWithAns(event.$id,taskId,copy,answers);ref.then(function(){if(isOpen&&task.openedAt||!isOpen&&task.closedAt){return;}else if(isOpen){return clmDataStore.events.openTask(event.$id,taskId);}return clmDataStore.events.closeTask(event.$id,taskId);}).then(function(){spfAlert.success('Task saved');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(){spfAlert.error('Failed to save the task.');}).finally(function(){self.savingTask=false;});;}};}// export const component = {
//
// }
function surveyFormEvent($scope,clmSurvey,clmDataStore,$log,spfAlert,$location,urlFor){this.surveys=[{id:1,name:'Education vs Dissatisfaction with learning'},{id:2,name:'Motivated strategies for learning'},{id:3,name:'School engagement scale'}];//TODO: retrieve selected value, add task into firebase
var sharedData=clmSurvey.get();//console.log("surveyFormEvent eventId : " + sharedData.taskType);
var getTask=sharedData.task;var self=this;this.saveSurveyTask=function(surveyType){var copy=cleanObj(getTask);console.log('my copy is ',copy);if(sharedData.taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(getTask.singPathProblem.path);copy.singPathProblem.level=cleanObj(getTask.singPathProblem.level);copy.singPathProblem.problem=cleanObj(getTask.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(getTask.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;console.log("survey type is "+surveyType);copy.survey=surveyType;clmDataStore.events.addTask(sharedData.eventId,copy,sharedData.isOpen).then(function(){spfAlert.success('Challenge created');$location.path(urlFor('editEvent',{eventId:sharedData.eventId}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to create new challenge.');}).finally(function(){self.creatingTask=false;});};}function getTaskSurveyValues(clmSurvey,$q,$route,spfAuthData,clmDataStore){var sharedData=clmSurvey.get();var data=baseEditCtrlInitialData(sharedData,$q,$route,spfAuthData,clmDataStore,clmSurvey);if(data!=null){console.log("Data is not null!!!");}else{console.log("DATA IS NULLLL!!");}data.badges=clmDataStore.badges.all();data.singPath=$q.all({paths:clmDataStore.singPath.paths(),levels:[],problems:[]});return $q.all(data);}function baseEditCtrlInitialData(sharedData,$q,$route,spfAuthData,clmDataStore,clmSurvey){var sharedData=clmSurvey.get();var errNoEvent=new Error('Event not found');var errNotAuthaurized=new Error('You cannot edit this event');var eventId=$route.current.params.eventId;var eventPromise=clmDataStore.events.get(sharedData.eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var data={currentUser:spfAuthData.user(),event:eventPromise};console.log("current user id: "+data.currentUser);data.canEdit=$q.all({currentUser:spfAuthData.user(),event:eventPromise}).then(function(result){if(!result.currentUser.publicId||!result.event.owner||!result.event.owner.publicId||result.event.owner.publicId!==result.currentUser.publicId){return $q.reject(errNotAuthaurized);}return result;});return data;}function configRoute$2($routeProvider,routes){$routeProvider.when(routes.cohorts,{template:cohortTmpl,controller:ClmListCohorts,controllerAs:'ctrl',resolve:{initialData:classMentorsCohortResolver}}).when(routes.newCohort,{template:newCohortTmpl,controller:NewCohortCtrl,controllerAs:'ctrl',resolve:{initialData:newCohortCtrlInitialData}}).when(routes.viewCohort,{template:cohortViewTmpl,controller:ViewCohortCtrl,controllerAs:'ctrl',resolve:{initialData:viewCohortCtrlInitialData}}).when(routes.editCohort,{template:cohortEditTmpl,controller:EditCohortCtrl,controllerAs:'ctrl',resolve:{initialData:editCohortCtrlInitialData}});}function ClmListCohorts(initialData,spfNavBarService,urlFor,spfAuthData){var title='Cohorts';var parentPages=[];var menuItems=[];this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.allCohorts=initialData.allCohorts;this.featuredCohorts=initialData.featuredCohorts;this.createdCohorts=initialData.createdCohorts;this.joinedEvents=initialData.joinedEvents;this.auth=initialData.auth;// *** Populate joined cohorts out-of-DB
this.joinedCohorts=[];for(var i=0;i<this.allCohorts.length;i++){var cohort=this.allCohorts[i];var cohortEvents=cohort.events;for(var j=0;j<this.joinedEvents.length;j++){var eventId=this.joinedEvents[j].$id;if(cohortEvents.indexOf(eventId)>-1){this.joinedCohorts.push(cohort);break;}}}// ***
if(this.profile&&this.profile.user&&this.profile.user.isPremium){menuItems.push({title:'New Cohort',url:'#'+urlFor('newCohort'),icon:'add'});}spfNavBarService.update('Cohorts',undefined,menuItems);}function classMentorsCohortResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({featuredCohorts:clmDataStore.cohorts.listFeaturedCohorts(),auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(){return;}),profile:clmDataStore.currentUserProfile(),createdCohorts:clmDataStore.cohorts.listCreatedCohorts(),joinedEvents:clmDataStore.events.listJoinedEvents(),allCohorts:clmDataStore.cohorts.listAllCohorts()});}/**
 * NewCohortCtrl
 *
 */function NewCohortCtrl($q,$location,initialData,urlFor,spfAuthData,spfAlert,spfNavBarService,clmDataStore){var self=this;this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.events=initialData.events;this.createdEvents=initialData.createdEvents;this.joinedEvents=initialData.joinedEvents;this.selectedEvents=[];this.selectedEventsNames=[];this.featured=false;this.includeCreated=false;this.includeJoined=false;this.creatingEvent=false;this.profileNeedsUpdate=!this.currentUser.$completed();spfNavBarService.update('New Cohorts',{title:'Cohorts',url:'#'+urlFor('cohorts')},[]);this.toggle=function(item,item2,list,list2){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);list2.push(item2);}};this.exists=function(item,list){return list.indexOf(item)>-1;};function cleanProfile(){self.currentUser.country=cleanObj(self.currentUser.country);self.currentUser.school=cleanObj(self.currentUser.school);}function updateProfile(profile){spfAlert.success('Profile setup.');self.profile=profile;self.profileNeedsUpdate=!self.currentUser.$completed();}this.save=function(currentUser,newCohort,events,featured){var next;self.creatingCohort=true;if(!self.profile){cleanProfile();next=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved');return clmDataStore.initProfile();}).then(updateProfile);}else if(self.profileNeedsUpdate){cleanProfile();next=self.currentUser.$save().then(function(){return clmDataStore.currentUserProfile();}).then(updateProfile);}else{next=$q.when();}next.then(function(){var data=Object.assign({owner:{publicId:currentUser.publicId,displayName:currentUser.displayName,gravatar:currentUser.gravatar},createdAt:{'.sv':'timestamp'},events:events,featured:featured},newCohort);return clmDataStore.cohorts.create(data);}).then(function(){spfAlert.success('New cohort created.');$location.path(urlFor('cohorts'));}).catch(function(e){spfAlert.error(e.toString());}).finally(function(){self.creatingCohort=false;});};this.reset=function(cohortForm){this.newCohort={data:{}};if(cohortForm&&cohortForm.$setPristine){cohortForm.$setPristine();}};this.reset();}function newCohortCtrlInitialData($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('The user should be logged in to create an event.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;}).then(function(profile){if(!profile||!profile.user||!profile.user.isPremium){return $q.reject(new Error('Only premium users can create events.'));}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise,events:clmDataStore.events.list(),createdEvents:clmDataStore.events.listCreatedEvents(),joinedEvents:clmDataStore.events.listJoinedEvents()});}/**
 * Used to resolve `initialData` of `ViewEventCtrl`.
 *
 */function viewCohortCtrlInitialData($q,$route,spfAuth,spfAuthData,clmDataStore){var errNoCohort=new Error('Cohort not found');var cohortId=$route.current.params.cohortId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$5);var cohortPromise=clmDataStore.cohorts.get(cohortId).then(function(cohort){if(cohort.$value===null){return $q.reject(errNoCohort);}return cohort;});var canviewPromise=$q.all({cohort:cohortPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.cohort));});return $q.all({currentUser:spfAuthData.user().catch(noop$5),profile:profilePromise,cohort:cohortPromise,canView:canviewPromise,announcements:clmDataStore.cohorts.getAnnouncements(cohortId),events:clmDataStore.events.listAll(),joinedEvents:clmDataStore.events.listJoinedEventsObj(),createdEvents:clmDataStore.events.listCreatedEvents()});}function ViewCohortCtrl($log,$scope,initialData,$document,$mdDialog,$route,$firebaseObject,spfAlert,urlFor,firebaseApp,spfAuthData,spfNavBarService,clmDataStore){var self=this;var db=firebaseApp.database();var monitorHandler;this.currentUser=initialData.currentUser;this.cohort=initialData.cohort;this.participants=initialData.participants;this.profile=initialData.profile;this.announcements=initialData.announcements;this.events=initialData.events;this.isOwner=false;this.joinedEvents=initialData.joinedEvents;this.createdEvents=initialData.createdEvents;this.selectedEvent=null;this.eventChallenges=null;this.selectedAction=null;if(self.cohort&&self.cohort.owner&&self.cohort.owner.publicId&&self.currentUser&&self.cohort.owner.publicId===self.currentUser.publicId){this.isOwner=true;}updateNavbar();function updateNavbar(){spfNavBarService.update(self.cohort.title,{title:'Cohorts',url:'#'+urlFor('cohorts')},getOptions());}function getOptions(){var options=[];if(!self.currentUser||!self.currentUser.publicId){return options;}// Add edit button
if(self.cohort.owner.publicId===self.currentUser.publicId){options.push({title:'Edit',url:'#'+urlFor('editCohort',{cohortId:self.cohort.$id}),icon:'create'});}return options;}this.loadEventChallenges=function(){var ref=db.ref('classMentors/eventTasks/'+self.selectedEvent);var obj=$firebaseObject(ref);obj.$loaded().then(function(){self.eventChallenges=obj;}).catch(function(err){$log.error(err);});};this.duplicateChallenges=function(){self.selectedChallenge.archived=false;delete self.selectedChallenge.$$mdSelectId;var eventIndex=0;insertChallenge();function insertChallenge(){if(eventIndex<self.selectedEvents.length){var eventId=self.selectedEvents[eventIndex];clmDataStore.events.addTask(eventId,self.selectedChallenge,true).then(function(){console.log(self.selectedChallenge.title+" inserted into "+eventId);eventIndex++;}).then(function(){insertChallenge();}).catch(function(err){$log.error(err);return err;});}else{spfAlert.success(self.selectedChallenge.title+" inserted into selected events");self.selectedEvent=null;self.selectedChallenge=null;self.selectedEvents=null;}}};this.viewFullAnnouncement=function(content,title){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:'<md-dialog aria-label="Announcement dialog" class="announcement-dialog">'+'  <md-dialog-content class="sticky-container">'+'<md-subheader class="md-sticky-no-effect">{{ctrl.title}}</md-subheader>'+'    <div style="white-space: pre-wrap;">{{ctrl.content}}</div>'+'  </md-dialog-content>'+'  <md-dialog-actions>'+'    <md-button ng-click="ctrl.closeDialog()" class="md-primary">'+'      Close'+'    </md-button>'+'  </md-dialog-actions>'+'</md-dialog>',controller:viewAnnouncementController,controllerAs:'ctrl'});function viewAnnouncementController(){this.content=content;this.title=title;this.closeDialog=function(){$mdDialog.hide();};}};//
// function promptPassword() {
//     if (
//         self.event.schoolEvent && (
//             !self.profile ||
//             !self.profile.user ||
//             !self.profile.user.school
//         )
//     ) {
//         spfAlert.warning(
//             'Only Students from Singapore can join this event. ' +
//             'Maybe you profile needs to be updated.');
//         return;
//     }
//     $mdDialog.show({
//         parent: $document.body,
//         template: passwordTmpl,
//         controller: DialogController,
//         controllerAs: 'ctrl'
//     });
//
//     function DialogController() {
//         this.pw = '';
//
//         this.join = function(pw) {
//             clmDataStore.events.join(self.event, pw).then(function() {
//                 spfAlert.success('You joined this event');
//                 $mdDialog.hide();
//                 $route.reload();
//             }).catch(function(err) {
//                 spfAlert.error(`Failed to add you: ${err}`);
//             });
//         };
//
//         this.closeDialog = function() {
//             $mdDialog.hide();
//         };
//     }
// }
//
// function cleanProfile(currentUser) {
//     currentUser.country = cleanObj(currentUser.country);
//     currentUser.school = cleanObj(currentUser.school);
// }
//
// this.register = function(currentUser) {
//     cleanProfile(currentUser);
//     spfAuthData.publicId(currentUser).then(function() {
//         spfAlert.success('Public id and display name saved');
//         return clmDataStore.initProfile();
//     }).then(function() {
//         $route.reload();
//     }).catch(function(err) {
//         spfAlert.error('Failed to save public id');
//         return err;
//     });
// };
//
// this.removeParticipant = function(e, event, participant) {
//     var confirm = $mdDialog.confirm()
//         .parent($document.body)
//         .title(`Would you like to remove ${participant.user.displayName}?`)
//         .content('The participant progress will be kept but he/she will not show as participant')
//         .ariaLabel('Remove participant')
//         .ok('Remove')
//         .cancel('Cancel')
//         .targetEvent(e);
//
//     $mdDialog.show(confirm).then(function() {
//         clmDataStore.events.removeParticpants(event.$id, participant.$id);
//     });
// };
}/**
 * Used to resolve `initialData` for `EditCtrl`
 *
 */function editCohortCtrlInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$1($q,$route,spfAuthData,clmDataStore);return $q.all(data);}function EditCohortCtrl(initialData,spfNavBarService,urlFor,spfAlert,clmDataStore){var self=this;this.currentUser=initialData.currentUser;this.eventsArr=initialData.eventsArr;this.events=initialData.events;this.cohort=initialData.cohort;this.announcements=initialData.announcements;this.savingCohort=false;this.creatingNewAnnouncement=false;this.newAnnouncement={};this.showingEvents=false;this.showingAnnouncements=false;this.addingEvent=false;// For searching events
this.mappedEvents=mapAllEvents();this.selectedEvent=null;this.searchEvent=null;this.querySearch=querySearch;function querySearch(query){return query?self.mappedEvents.filter(createFilterFor(query)):self.mappedEvents;}function mapAllEvents(){return self.eventsArr.map(function(event){return{id:event.$id,value:event.title.toLowerCase(),title:event.title};});}function createFilterFor(query){var lowercaseQuery=angular.lowercase(query);return function filterFn(event){// to filter results based on query and ensure that user cannot select events already in the cohort
return event.value.indexOf(lowercaseQuery)>=0&&self.cohort.events.indexOf(event.id)<0;};}spfNavBarService.update('Edit',[{title:'Cohorts',url:'#'+urlFor('cohorts')},{title:this.cohort.title,url:'#'+urlFor('viewCohort',{cohortId:this.cohort.$id})}]);this.removeCohortEvent=function(eventId,eventIndex){var newEventArray=self.cohort.events;newEventArray.splice(eventIndex,1);clmDataStore.cohorts.removeEvent(self.cohort.$id,newEventArray).then(function(){spfAlert.success('Removed event');}).catch(function(err){spfAlert.error('Failed to remove event');});};this.saveAddedEvent=function(){clmDataStore.cohorts.addEvent(self.cohort.$id,self.selectedEvent.id,self.cohort.events.length).then(function(){spfAlert.success(self.selectedEvent.title+' has been added to the cohort!');self.selectedEvent=null;}).catch(function(err){spfAlert.error('Failed to add '+self.selectedEvent.title+' to the cohort!');self.selectedEvent=null;}).finally(function(){self.addingEvent=false;});};this.addEvent=function(){self.addingEvent=true;};this.closeAddingEvent=function(){self.addingEvent=false;};this.toggleEvents=function(){if(self.showingEvents){self.showingEvents=false;}else{self.showingEvents=true;}};this.toggleAnnouncements=function(){if(self.showingAnnouncements){self.showingAnnouncements=false;}else{self.showingAnnouncements=true;}};this.createNewAnnouncement=function(){self.creatingNewAnnouncement=true;self.newAnnouncement.featured=false;self.newAnnouncement.visible=true;};this.closeNewAnnouncement=function(){self.creatingNewAnnouncement=false;};this.save=function(currentUser,cohort,editCohortForm){self.savingCohort=true;cohort.owner.publicId=currentUser.publicId;cohort.owner.displayName=currentUser.displayName;cohort.owner.gravatar=currentUser.gravatar;return clmDataStore.cohorts.updateCohort(cohort).then(function(){spfAlert.success('Cohort saved.');editCohortForm.$setPristine(true);}).catch(function(){spfAlert.error('Failed to save cohort.');}).finally(function(){self.savingCohort=false;});};this.saveAnnouncement=function(cohortId){clmDataStore.cohorts.addAnnouncement(cohortId,this.currentUser,this.newAnnouncement,false).then(function(){spfAlert.success('Announcement created');}).catch(function(){spfAlert.error('Failed to create announcement');}).finally(function(){self.creatingNewAnnouncement=false;self.newAnnouncement={};});};this.featureAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.featureAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement featured.');}).catch(function(){spfAlert.error('Failed to feature announcement');});};this.unfeatureAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.unfeatureAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement un-featured.');}).catch(function(){spfAlert.error('Failed to un-feature announcement');});};this.showAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.showAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement is now visible.');}).catch(function(){spfAlert.error('Failed to make announcement visible');});};this.hideAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.hideAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement is now hidden.');}).catch(function(){spfAlert.error('Failed to hide announcement');});};}function baseEditCtrlInitialData$1($q,$route,spfAuthData,clmDataStore){var errNoCohort=new Error('Cohort not found');var errNotAuthorized=new Error('You cannot edit this cohort');var cohortId=$route.current.params.cohortId;var cohortPromise=clmDataStore.cohorts.get(cohortId).then(function(cohort){if(cohort.$value===null){return $q.reject(errNoCohort);}return cohort;});var data={currentUser:spfAuthData.user(),announcements:clmDataStore.cohorts.getAnnouncements(cohortId),eventsArr:clmDataStore.events.listAllArr(),events:clmDataStore.events.listAll(),cohort:cohortPromise};data.canEdit=$q.all({currentUser:spfAuthData.user(),announcements:clmDataStore.cohorts.getAnnouncements(cohortId),cohort:cohortPromise}).then(function(result){if(!result.currentUser.publicId||!result.cohort.owner||!result.cohort.owner.publicId||result.cohort.owner.publicId!==result.currentUser.publicId){return $q.reject(errNotAuthorized);}return result;});return data;}function clmCohortsStatsPageFactory(){return{template:cohortStatsPageTmpl,restrict:'E',bindToController:true,scope:{cohort:'=',profile:'='},controller:ClmCohortStatsPageCtrl,controllerAs:'ctrl'};}function ClmCohortStatsPageCtrl($scope,$q,$log,$mdDialog,$document,$firebaseArray,urlFor,spfAlert,firebaseApp,clmServicesUrl,clmDataStore){var self=this;var db=firebaseApp.database();this.selectedStatistic=null;this.renderDashboard=function(){if(self.selectedStatistic){if(self.selectedStatistic=='Submission time series'){// How formatted data should look like
var dataObj={};var dataArr=[];//Axis data object
var axisParam={};//Initialise dataObj
for(var e=0;e<self.cohort.events.length;e++){dataObj[self.cohort.events[e]+"_x"]=[];dataObj[self.cohort.events[e]]=[];axisParam[self.cohort.events[e]]=self.cohort.events[e]+"_x";}var actionsRef=db.ref('classMentors/userActions');var actionObj=$firebaseArray(actionsRef);actionObj.$loaded().then(function(){self.submissionLogs=actionObj;}).then(function(){for(var actionIndex=0;actionIndex<self.submissionLogs.length;actionIndex++){var logHolder=self.submissionLogs[actionIndex];if(self.cohort.events.indexOf(logHolder.eventId)>=0){dataObj[logHolder.eventId+"_x"].push(logHolder.timestamp);dataObj[logHolder.eventId].push(new Date(logHolder.timestamp).getMinutes());}}}).then(function(){for(var obj in dataObj){var newArr=[obj];dataArr.push(newArr.concat(dataObj[obj]));}var chart=c3.generate({bindto:"#chart",data:{xs:axisParam,columns:dataArr,type:'scatter'},axis:{x:{label:'timestamp',tick:{fit:false}},y:{label:'Date of Action'}}});}).catch(function(err){$log.error(err);});}}};}function clmCohortRankPageFactory(){return{template:cohortRankingPageTmpl,restrict:'E',bindToController:true,scope:{cohort:'=',profile:'='},controller:ClmCohortRankPageCtrl,controllerAs:'ctrl'};}function ClmCohortRankPageCtrl($q,$scope,$log,firebaseApp,$firebaseObject,$firebaseArray,clmDataStore,clmPagerOption){var self=this;var db=firebaseApp.database();var unwatchers=[];this.cohortEventData=[];this.cohortTotalParticipants=[];// *************************** Re-write code here ***************************
var iter=0;loadInitialData();function loadInitialData(){var oneEventData={};var eventId=self.cohort.events[iter];if(iter<self.cohort.events.length){var eventObj=$firebaseObject(db.ref('classMentors/events/'+eventId));eventObj.$loaded().then(function(){return oneEventData.title=eventObj.title;},function(err){oneEventData.participants=[];$log.error(err);}).then(function(){oneEventData.id=eventId;oneEventData.participants=[];oneEventData.qualifiedParticipants=[];self.cohortEventData.push(oneEventData);fetchParticipantInfo(eventId);iter++;loadInitialData();});}}function fetchParticipantInfo(eventId){var participantsArray=$firebaseArray(db.ref('classMentors/eventParticipants/'+eventId));participantsArray.$loaded().then(function(){return self.cohortEventData.find(function(e){return e.id==eventId;}).participants=participantsArray;}).then(function(){self.cohortTotalParticipants=self.cohortTotalParticipants.concat(participantsArray);var _loop=function _loop(participantIndex){// console.log("User " + participantsArray[participantIndex].$id + " from event " + eventId);
$firebaseObject(db.ref('classMentors/userProfiles/'+participantsArray[participantIndex].$id+'/services')).$loaded().then(function(result){if(result.freeCodeCamp&&result.freeCodeCamp.totalAchievements>=1){self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.push({displayName:participantsArray[participantIndex].user.displayName,userId:participantsArray[participantIndex].$id,score:result.freeCodeCamp.totalAchievements});self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.sort(function(a,b){return b.score-a.score;});}});};for(var participantIndex=0;participantIndex<participantsArray.length;participantIndex++){_loop(participantIndex);}});}// *************************** END ***************************
// getAllEventData();
// this.cohortTotalParticipants = 0;
// this.showFilteredRanking = false;
//
// function getAllEventData() {
//     var iter = 0;
//     loopDBEvents();
//     function loopDBEvents() {
//         var oneEventData = {};
//         var eventId = self.cohort.events[iter];
//
//         if(iter < self.cohort.events.length) {
//             var participantsRef = db.ref(`classMentors/eventParticipants/${eventId}`);
//             var participantsQuery = participantsRef;
//             var participantsArray = $firebaseArray(participantsQuery);
//
//             participantsArray.$loaded().then(
//                 () => (oneEventData.participants = participantsArray),
//                 err => {
//                     oneEventData.participants = [];
//                     $log.error(err);
//                 }
//             ).then(function () {
//                 var eventRef = db.ref(`classMentors/events/${eventId}`);
//                 var eventObj = $firebaseObject(eventRef);
//
//                 eventObj.$loaded().then(function() {
//                     var result = eventObj;
//                     oneEventData.title = result.title;
//                     self.cohortTotalParticipants += oneEventData.participants.length;
//                     oneEventData.id = result.$id;
//                     oneEventData.userRanks = [];
//                     var userIndex = 0;
//                     loadUserAchievements();
//                     function loadUserAchievements() {
//                         if(userIndex < oneEventData.participants.length) {
//                             var participantRankingRef = db.ref(`classMentors/userProfiles/${oneEventData.participants[userIndex].$id}`);
//                             var participantRankingObj = $firebaseObject(participantRankingRef);
//                             participantRankingObj.$loaded().then(function () {
//                                 var rankingResult = participantRankingObj;
//                                 if(rankingResult.services && rankingResult.services.freeCodeCamp) {
//                                     oneEventData.userRanks.push({"user": rankingResult.user, "total": parseInt(rankingResult.services.freeCodeCamp.totalAchievements)});
//                                 } else {
//                                     oneEventData.userRanks.push({"user": rankingResult.user, "total": 0});
//                                 }
//                                 userIndex++;
//                                 loadUserAchievements();
//                             });
//                         } else {
//                             self.cohortEventData.push(oneEventData);
//                             iter++;
//                             loopDBEvents();
//                         }
//                     }
//                 });
//             });
//         }
//     }
// }
//
// this.fourEntryThreshold = 2;
// this.twoEntryThreshold = 12;
//
// this.filterRanking = function() {
//     if(self.showFilteredRanking) {
//         for(let eventId in self.cohortEventData) {
//             let event = self.cohortEventData[eventId];
//             let totalEventScore = 0;
//             for(let user in event.userRanks) {
//                 let rankObj = event.userRanks[user];
//                 if(rankObj.total) {
//                     totalEventScore += rankObj.total;
//                 }
//             }
//             self.cohortEventData[eventId].totalScore = totalEventScore;
//         }
//         self.cohortEventData.sort(function(a,b) {
//             return b.totalScore - a.totalScore;
//         });
//         for(let placing = 0; placing < self.fourEntryThreshold; placing++) {
//             let event = self.cohortEventData[placing];
//             if(event) {
//                 event.userRanks.sort(function (a,b) {
//                     return b.total - a.total;
//                 });
//                 if(event.userRanks[0]) {
//                     self.cohortEventData[placing].first = {"name": event.userRanks[0].user.displayName, "total": event.userRanks[0].total};
//                 }
//                 if(event.userRanks[1]) {
//                     self.cohortEventData[placing].second = {"name": event.userRanks[1].user.displayName, "total": event.userRanks[1].total};
//                 }
//                 if(event.userRanks[2]) {
//                     self.cohortEventData[placing].third = {"name": event.userRanks[2].user.displayName, "total": event.userRanks[2].total};
//                 }
//                 if(event.userRanks[3]) {
//                     self.cohortEventData[placing].fourth = {"name": event.userRanks[3].user.displayName, "total": event.userRanks[3].total};
//                 }
//             }
//         }
//         for(let placing = self.fourEntryThreshold; placing < self.twoEntryThreshold; placing ++) {
//             let event = self.cohortEventData[placing];
//             if(event) {
//                 event.userRanks.sort(function (a,b) {
//                     return b.total - a.total;
//                 });
//                 if(event.userRanks[0]) {
//                     self.cohortEventData[placing].first = {"name": event.userRanks[0].user.displayName, "total": event.userRanks[0].total};
//                 }
//                 if(event.userRanks[1]) {
//                     self.cohortEventData[placing].second = {"name": event.userRanks[1].user.displayName, "total": event.userRanks[1].total};
//                 }
//             }
//         }
//     } else {
//         self.cohortEventData.sort(function(a,b) {
//             return b.participants.length - a.participants.length;
//         });
//     }
// }
}function configRoute$3($routeProvider,routes){$routeProvider.when(routes.events,{template:listTmpl,controller:ClmListEvent,controllerAs:'ctrl',resolve:{initialData:classMentorsEventResolver}}).when(routes.newEvent,{template:newTmpl,controller:NewEventCtrl,controllerAs:'ctrl',resolve:{initialData:newEventCtrlInitialData}}).when(routes.oneEvent,{template:eventTmpl,controller:ViewEventCtrl,controllerAs:'ctrl',resolve:{initialData:viewEventCtrlInitialData}}).when(routes.editEvent,{template:editTmpl,controller:EditEventCtrl,controllerAs:'ctrl',resolve:{initialData:editEventCtrllInitialData}}).when(routes.addEventTask,{template:eventTaskFormTmpl,controller:AddEventTaskCtrl,controllerAs:'ctrl',resolve:{initialData:addEventTaskCtrlInitialData}}).when(routes.editEventTask,{template:eventTaskFormTmpl,controller:EditEventTaskCtrl,controllerAs:'ctrl',resolve:{initialData:editEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey1/:surveyTask',{template:schEngageScaleTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey2/:surveyTask',{template:motiStratLearnTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey3/:surveyTask',{template:eduDisLearnTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}});}//Create eventServiceFactory
//TODO: Edit
function eventServiceFactory($q,$route,spfAuthData,clmDataStore,$log,spfAlert){var self=this;var savedData={};var eventService={set:function set(data){savedData=data;console.log(savedData);},get:function get(){return savedData;},save:function save(event,_,task,taskType,isOpen){var copy=cleanObj(task);console.log('Copy is.. : ',copy);if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;clmDataStore.events.addTask(event.$id,copy,isOpen);// .then(function() {
// spfAlert.success('Challenge created');
// $location.path(urlFor('editEvent', {eventId: self.event.$id}));
// }).catch(function(err) {
//     $log.error(err);
//     spfAlert.error('Failed to created new challenge');
// }).finally(function() {
//     self.creatingTask = false;
// });
}};return eventService;}/**
 * Used to resolve `initialData` of `ClmListEvent`.
 *
 */function classMentorsEventResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({events:clmDataStore.events.list(),auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(){return;}),profile:clmDataStore.currentUserProfile(),createdEvents:clmDataStore.events.listCreatedEvents(),joinedEvents:clmDataStore.events.listJoinedEvents()});}/**
 * ClmListEvent
 *
 */function ClmListEvent(initialData,spfNavBarService,urlFor){var opts=[];this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.events=initialData.events;this.createdEvents=initialData.createdEvents;this.joinedEvents=initialData.joinedEvents;this.auth=initialData.auth;if(this.profile&&this.profile.user&&this.profile.user.isPremium){opts.push({title:'New event',url:'#'+urlFor('newEvent'),icon:'add'});}spfNavBarService.update('Events',undefined,opts);}/**
 * Used to resolve `initialData` of `NewEventCtrl`.
 *
 */function newEventCtrlInitialData($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('The user should be logged in to create an event.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;}).then(function(profile){if(!profile||!profile.user||!profile.user.isPremium){return $q.reject(new Error('Only premium users can create events.'));}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise});}/**
 * NewEventCtrl
 *
 */function NewEventCtrl($q,$location,initialData,urlFor,spfAuthData,spfAlert,spfNavBarService,clmDataStore){var self=this;this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.creatingEvent=false;this.profileNeedsUpdate=!this.currentUser.$completed();spfNavBarService.update('New Events',{title:'Events',url:'#'+urlFor('events')},[]);function cleanProfile(){self.currentUser.country=cleanObj(self.currentUser.country);self.currentUser.school=cleanObj(self.currentUser.school);}function updateProfile(profile){spfAlert.success('Profile setup.');self.profile=profile;self.profileNeedsUpdate=!self.currentUser.$completed();}this.save=function(currentUser,newEvent,password){var next;self.creatingEvent=true;if(!self.profile){cleanProfile();next=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved.');return clmDataStore.initProfile();}).then(updateProfile);}else if(self.profileNeedsUpdate){cleanProfile();next=self.currentUser.$save().then(function(){return clmDataStore.currentUserProfile();}).then(updateProfile);}else{next=$q.when();}next.then(function(){var data=Object.assign({owner:{publicId:currentUser.publicId,displayName:currentUser.displayName,gravatar:currentUser.gravatar},createdAt:{'.sv':'timestamp'}},newEvent);return clmDataStore.events.create(data,password);}).then(function(){spfAlert.success('New event created.');$location.path(urlFor('events'));}).catch(function(e){spfAlert.error(e.toString());}).finally(function(){self.creatingEvent=false;});};this.reset=function(eventForm){this.newEvent={data:{},password:''};if(eventForm&&eventForm.$setPristine){eventForm.$setPristine();}};this.reset();}/**
 * Used to resolve `initialData` of `ViewEventCtrl`.
 *
 */function viewEventCtrlInitialData($q,$route,spfAuth,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-1');var eventId=$route.current.params.eventId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$6);var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var canviewPromise=$q.all({event:eventPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.event));});return $q.all({currentUser:spfAuthData.user().catch(noop$6),profile:profilePromise,event:eventPromise,canView:canviewPromise,tasks:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getTasks(eventId);}}),participants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.participants(eventId);}}),progress:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getProgress(eventId);}}),solutions:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getSolutions(eventId);}}),scores:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getScores(eventId);}}),assistants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getAssistants(eventId);}}),assistantObj:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getAsstObj(eventId);}})});}/**
 * ViewEventCtrl
 *
 */function ViewEventCtrl($scope,initialData,$document,$mdDialog,$route,spfAlert,urlFor,spfAuthData,spfNavBarService,clmDataStore){var self=this;var monitorHandler;this.currentUser=initialData.currentUser;this.event=initialData.event;this.participants=initialData.participants;this.profile=initialData.profile;this.tasks=initialData.tasks;this.progress=initialData.progress;this.solutions=initialData.solutions;this.scores=initialData.scores;this.canView=initialData.canView;this.viewArchived=false;this.selected=null;this.isOwner=false;this.assistants=initialData.assistants;this.assistantObj=initialData.assistantObj;this.asstArr=[];this.isReviewSuperUser=false;for(var _asst in self.assistants){if(self.assistants[_asst].$id){self.asstArr.push(self.assistants[_asst].$id);}}if(self.event&&self.event.owner&&self.event.owner.publicId&&self.currentUser&&self.event.owner.publicId===self.currentUser.publicId){monitorHandler=clmDataStore.events.monitorEvent(this.event,this.tasks,this.participants,this.solutions,this.progress);this.isOwner=true;}else{monitorHandler={update:noop$6,unwatch:noop$6};}if(self.event&&self.currentUser&&self.asstArr.indexOf(self.currentUser.publicId)>=0){var asst=self.assistantObj[self.currentUser.publicId];if(asst.canReview){this.isReviewAssistant=true;}if(asst.canEdit){this.isEditAssistant=true;}}if(self.isReviewAssistant||self.isOwner){self.isReviewSuperUser=true;}$scope.$on('$destroy',function(){/* eslint no-unused-expressions: 0 */monitorHandler.unwatch();self.event&&self.event.$destroy&&self.event.$destroy();self.participants&&self.participants.$destroy&&self.participants.$destroy();self.profile&&self.profile.$destroy&&self.profile.$destroy();self.progress&&self.progress.$destroy&&self.progress.$destroy();self.solutions&&self.solutions.$destroy&&self.solutions.$destroy();});updateNavbar();function updateNavbar(){spfNavBarService.update(self.event.title,{title:'Events',url:'#'+urlFor('events')},getOptions());}function getOptions(){var options=[];if(!self.currentUser||!self.currentUser.publicId){return options;}// add join/leave button
if(self.participants&&self.participants.$indexFor(self.currentUser.publicId)>-1){options.push({title:'Leave',onClick:function onClick(){clmDataStore.events.leave(self.event.$id).then(function(){$route.reload();});},icon:'clear'});}else{options.push({title:'Join',onClick:promptPassword,icon:'add'});}// Add edit and update button
//self.event.owner.publicId === self.currentUser.publicId
if(self.isOwner||self.isEditAssistant){options.push({title:'Edit',url:'#'+urlFor('editEvent',{eventId:self.event.$id}),icon:'create'});options.push({title:'Update',onClick:function onClick(){monitorHandler.update();},icon:'loop'});}return options;}function promptPassword(){if(self.event.schoolEvent&&(!self.profile||!self.profile.user||!self.profile.user.school)){spfAlert.warning('Only Students from Singapore can join this event. '+'Maybe your profile needs to be updated.');return;}$mdDialog.show({parent:$document.body,template:passwordTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.pw='';this.join=function(pw){clmDataStore.events.join(self.event,pw).then(function(){spfAlert.success('You joined this event.');$mdDialog.hide();$route.reload();}).catch(function(err){spfAlert.error('Failed to join event. Please ensure that your password is valid and try again.');console.log('Failed to add you: '+err);// spfAlert.error(`Failed to add you: ${err}`);
});};this.closeDialog=function(){$mdDialog.hide();};}}function cleanProfile(currentUser){currentUser.country=cleanObj(currentUser.country);currentUser.school=cleanObj(currentUser.school);}this.register=function(currentUser){cleanProfile(currentUser);spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved.');return clmDataStore.initProfile();}).then(function(){$route.reload();}).catch(function(err){spfAlert.error('Failed to save public id.');return err;});};this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};}/**
 * Minimal resolver for `EditCtrl` and `AddEventTaskCtrl`.
 *
 * Load the event data and the current user data.
 *
 * The promise will resolved to an error if the the current user
 * is not the owner of the event.
 *
 */function baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-2');var errNotAuthaurized=new Error('You cannot edit this event');var eventId=$route.current.params.eventId;var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var data={currentUser:spfAuthData.user(),event:eventPromise,participants:clmDataStore.events.participants(eventId)};data.canEdit=$q.all({currentUser:spfAuthData.user(),event:eventPromise,assistants:clmDataStore.events.getAsstObj(eventId)}).then(function(result){if(!result.currentUser.publicId||!result.event.owner||!result.event.owner.publicId||result.event.owner.publicId!==result.currentUser.publicId){if(result.assistants[result.currentUser.publicId]){if(!result.assistants[result.currentUser.publicId].canEdit){return $q.reject(errNotAuthaurized);}}else{return $q.reject(errNotAuthaurized);}}return result;});return data;}/**
 * Used to resolve `initialData` for `EditCtrl`
 *
 */function editEventCtrllInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore);data.tasks=data.event.then(function(event){return clmDataStore.events.getTasks(event.$id);});data.assistants=data.event.then(function(event){return clmDataStore.events.getAssistants(event.$id);});return $q.all(data);}/**
 * EditEventCtrl
 *
 */function EditEventCtrl(initialData,spfNavBarService,urlFor,spfAlert,clmDataStore){var self=this;this.currentUser=initialData.currentUser;this.participants=initialData.participants;this.event=initialData.event;this.tasks=initialData.tasks;this.showingAssistants=false;this.showingTasks=true;this.assistants=initialData.assistants;this.newPassword='';this.isOwner=false;this.savingEvent=false;if(self.event&&self.event.owner&&self.event.owner.publicId&&self.currentUser&&self.event.owner.publicId===self.currentUser.publicId){this.isOwner=true;}this.addingNewAssistant=false;this.newAssistant={canEdit:false,canReview:true};// Search form variables
this.users=mapAllUsers();this.selectedUser=null;this.searchUser=null;this.querySearch=querySearch;this.assistantArr=[];for(var asst in self.assistants){if(self.assistants[asst].$id){self.assistantArr.push(self.assistants[asst].$id);}}function querySearch(query){return query?self.users.filter(createFilterFor(query)):self.users;}function mapAllUsers(){return self.participants.map(function(user){return{id:user.$id,value:user.user.displayName.toLowerCase(),displayName:user.user.displayName};});}function createFilterFor(query){query=query||'';var lowercaseQuery=query.toLowerCase();return function filterFn(user){//Filter results in auto complete. Ensure that users who are already assistants may not be selected again
return user.value.indexOf(lowercaseQuery)>=0&&self.assistantArr.indexOf(user.id)<0;};}spfNavBarService.update('Edit',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})}],[{title:'New Challenge',url:'#'+urlFor('addEventTask',{eventId:this.event.$id}),icon:'create'}]);this.toggleAssistants=function(){if(self.showingAssistants){self.showingAssistants=false;}else{if(self.isOwner){self.showingAssistants=true;}else{spfAlert.error('Only the event owner may manage assistants.');}}};this.toggleTaskEditView=function(){if(self.showingTasks){self.showingTasks=false;}else{self.showingTasks=true;}};this.addAssistant=function(){self.addingNewAssistant=true;};this.enableReview=function(eventId,assistantId,assistantName){clmDataStore.events.enableAssistantReviewing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can now review event challenge submissions.');}).catch(function(){spfAlert.error('Failed to change assistant rights');});};this.disableReview=function(eventId,assistantId,assistantName){clmDataStore.events.disableAssistantReviewing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can no longer review event challenge submissions.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.enableEdit=function(eventId,assistantId,assistantName){clmDataStore.events.enableAssistantEditing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can now edit the event.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.disableEdit=function(eventId,assistantId,assistantName){clmDataStore.events.disableAssistantEditing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can no longer edit the event.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.removeAssistant=function(eventId,assistantId,assistantName){clmDataStore.events.removeAssistant(eventId,assistantId).then(function(){spfAlert.success(assistantName+' removed as event assistant.');if(self.assistantArr.indexOf(assistantId)>=0){self.assistantArr.splice(assistantId,1);}}).catch(function(){spfAlert.error('Failed to remove assistant.');});};this.saveNewAssistant=function(eventId){self.newAssistant.name=self.selectedUser.displayName;clmDataStore.events.addAssistant(eventId,self.selectedUser.id,self.newAssistant);self.addingNewAssistant=false;self.selectedUser=null;};this.closeNewAssistant=function(){self.addingNewAssistant=false;};this.save=function(currentUser,event,newPassword,editEventForm){self.savingEvent=true;event.owner.publicId=currentUser.publicId;event.owner.displayName=currentUser.displayName;event.owner.gravatar=currentUser.gravatar;return clmDataStore.events.updateEvent(event,newPassword).then(function(){spfAlert.success('Event saved.');self.newPassword='';editEventForm.$setPristine(true);}).catch(function(err){spfAlert.error('Failed to save event.');}).finally(function(){self.savingEvent=false;});};this.openTask=function(eventId,taskId){clmDataStore.events.openTask(eventId,taskId).then(function(){spfAlert.success('Challenge opened.');}).catch(function(){spfAlert.error('Failed to open challenge.');});};this.closeTask=function(eventId,taskId){clmDataStore.events.closeTask(eventId,taskId).then(function(){spfAlert.success('Challenge closed.');}).catch(function(){spfAlert.error('Failed to close challenge.');});};this.showTask=function(eventId,taskId){clmDataStore.events.showTask(eventId,taskId).then(function(){spfAlert.success('Challenge visible.');}).catch(function(){spfAlert.error('Failed to make challenge visible.');});};this.hideTask=function(eventId,taskId){clmDataStore.events.hideTask(eventId,taskId).then(function(){spfAlert.success('Challenge hidden.');}).catch(function(){spfAlert.error('Failed to make challenge hidden.');});};this.archiveTask=function(eventId,taskId){clmDataStore.events.archiveTask(eventId,taskId).then(function(){spfAlert.success('Challenge archived.');}).catch(function(){spfAlert.error('Failed to archive challenge.');});};}/**
 * AddEventTaskCtrl initial data
 *
 */function addEventTaskCtrlInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore);data.badges=clmDataStore.badges.all();data.singPath=$q.all({paths:clmDataStore.singPath.paths(),levels:[],problems:[]});return $q.all(data);}/**
 * AddEventTaskCtrl
 *
 */function AddEventTaskCtrl(initialData,$location,$log,spfAlert,urlFor,spfNavBarService,clmDataStore,$mdDialog,$scope,eventService,clmSurvey){var self=this;this.event=initialData.event;this.badges=initialData.badges;this.isOpen=true;this.singPath=initialData.singPath;this.savingTask=false;this.task={archived:false,showProgress:true};this.enableBeta=true;var location;this.selectedMetaData=[];spfNavBarService.update('New Challenge',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}};this.exists=function(item,list){return list.indexOf(item)>-1;};this.loadLevels=function(selected){return clmDataStore.singPath.levels(selected.path.id).then(function(levels){self.singPath.levels=levels;});};this.loadProblems=function(selected){return clmDataStore.singPath.problems(selected.path.id,selected.level.id).then(function(problems){self.singPath.problems=problems;});};this.challengeRouteProvider=function(tasktype,task,isOpen){if(tasktype=='service'){console.log('service is clicked');return'Save';}else if(tasktype=='singPath'){console.log('singpath is clicked');return'Save';}else if(tasktype=='linkPattern'){console.log('linkPattern is clicked');return'Save';}else if(tasktype=='textResponse'){console.log('textResponse is clicked');return'Save';}else if(tasktype=='multipleChoice'){console.log('multipleChoice is clicked');location='/challenges/mcq';return'Continue';}else if(tasktype=='code'){console.log('code is clicked');return'Save';}else if(tasktype=='video'){console.log('video is clicked');return'Continue';}else if(tasktype=='teamActivity'){console.log('teamActivity is clicked');location='/challenges/team-activity/create';return'Continue';}else if(tasktype=='journalling'){console.log('journalling is clicked');return'Continue';}else if(tasktype=='survey'){// console.log("clicked clmdataa: ", initialData.event);
clmSurvey.set(initialData.event.$id,initialData.event,task,tasktype,isOpen);var obj=clmSurvey.get();location='/challenges/survey';return'Continue';}else if(tasktype==='profileEdit'){return'Save';}else{return'Save';// by default should show 'save'
}};//this function double checks with user if he wishes to go back and discard all changes thus far
this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not saved your input information').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard all').targetEvent(ev).ok('Discard All').cancel('Continue editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:self.event.$id}));});};this.saveTask=function(event,taskId,task,taskType,isOpen){if(taskType==='profileEdit'){task.toEdit=self.selectedMetaData;task.textResponse="Placeholder";}var copy=cleanObj(task);//check if user keys in http inside Link Pattern
var checkLinkPattern=copy.linkPattern;if(checkLinkPattern!=null){if(checkLinkPattern.indexOf("http:")>-1){checkLinkPattern=checkLinkPattern.replace("http:","https:");}copy.linkPattern=checkLinkPattern;}var data={taskType:taskType,isOpen:isOpen,event:event,task:task};if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;if(taskType==='multipleChoice'||taskType==='journalling'||taskType==='video'||taskType==='survey'||taskType==='teamActivity'){var data={taskType:taskType,isOpen:isOpen,event:event,task:task};console.log('Data shows... ',data);spfNavBarService.update('Challenge Details',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);eventService.set(data);$location.path(location);}else{clmDataStore.events.addTask(event.$id,copy,isOpen).then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:self.event.$id}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to created new challenge.');}).finally(function(){self.creatingTask=false;});}};}//////////////////////////////implemented survey challenge//////////////////////////////////////
function clmSurveyTaskFactory(){var sharedData={};//console.log("it comes in here");
function set(eventId,event,task,tasktype,isOpen){sharedData.eventId=eventId;sharedData.event=event;sharedData.task=task;sharedData.taskType=tasktype;sharedData.isOpen=isOpen;//sharedData.currentUser = spfAuthData.user();
}function get(){return sharedData;}return{set:set,get:get};}/**
 * Used to resolve `initialData` of `EditEventTaskCtrl`.
 *
 */function editEventTaskCtrlInitialData($q,$route,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-3');var errNoTask=new Error('Event not found-4');var errNotAuthaurized=new Error('You cannot edit this event');var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var taskPromise=eventPromise.then(function(){return clmDataStore.events.getTask(eventId,taskId).then(function(task){if(!task||task.$value===null){return $q.reject(errNoTask);}return task;});});return $q.all({currentUser:spfAuthData.user(),event:eventPromise,badges:clmDataStore.badges.all(),taskId:taskId,task:taskPromise,assistants:clmDataStore.events.getAsstObj(eventId)}).then(function(data){if(!data.currentUser.publicId||!data.event.owner||!data.event.owner.publicId||data.event.owner.publicId!==data.currentUser.publicId&&data.currentUser.publicId){if(data.assistants[data.currentUser.publicId]){if(!data.assistants[data.currentUser.publicId].canEdit){return $q.reject(errNotAuthaurized);}}else{return $q.reject(errNotAuthaurized);}}return data;});}/**
 * EditEventTaskCtrl
 *
 *//**Todo: enable edit to multiple choice, index card, etc. **/function EditEventTaskCtrl(initialData,spfAlert,urlFor,spfNavBarService,clmDataStore,eventService,$mdDialog,$location){var self=this;this.event=initialData.event;this.badges=initialData.badges;this.taskId=initialData.taskId;this.task=initialData.task;this.isOpen=Boolean(this.task.openedAt);this.savingTask=false;this.enableBeta=true;var location;this.taskType=null;/**todo: append tasktype here **/if(this.task.serviceId){this.taskType='service';}else if(this.task.linkPattern){this.taskType='linkPattern';}else if(this.task.lang){this.taskType='code';}else if(this.task.textResponse){this.taskType='textResponse';}else if(this.task.mcqQuestions){this.taskType='multipleChoice';}// else if (this.task.profileEdit) {
//     return 'Save';
// }
// md-select badge list and the the ng-model are compared
// by reference.
if(this.task.badge&&this.task.badge.id&&this.badges[this.task.serviceId]&&this.badges[this.task.serviceId][this.task.badge.id]){this.task.badge=this.badges[this.task.serviceId][this.task.badge.id];}spfNavBarService.update(this.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);this.challengeRouteProvider=function(){//console.log("task type passed in is",tasktype);
//console.log("this task type passed in is", this.taskType);
if(this.taskType=='service'){console.log('service is clicked');return'Save';}else if(this.taskType=='singPath'){console.log('singpath is clicked');return'Save';}else if(this.taskType=='linkPattern'){console.log('linkPattern is clicked');return'Save';}else if(this.taskType=='textResponse'){console.log('textResponse is clicked');return'Save';}else if(this.taskType=='multipleChoice'){console.log('multipleChoice is clicked');// console.log("this event url", urlFor('oneEvent', {eventId: this.event.$id}));
location="/challenges/mcq/edit";return'Continue';}else if(this.taskType=='code'){console.log('code is clicked');return'Save';}else if(this.taskType=='video'){console.log('video is clicked');return'Continue';}else if(this.taskType=='journalling'){console.log('journalling is clicked');return'Continue';}else if(this.tasktype=='teamActivity'){console.log('teamActivity is clicked');location='/challenges/team-activity/edit';return'Continue';}else if(this.tasktype==='profileEdit'){return'Save';}else{return'Save';}};//this function double checks with user if he wishes to go back and discard all changes thus far
this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not saved your changes').textContent('All of your changes will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard my changes').cancel('Continue editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:self.event.$id}));});};this.saveTask=function(event,taskId,task,taskType,isOpen){var copy=cleanObj(task);//check if user keys in http inside Link Pattern
var checkLinkPattern=copy.linkPattern;if(checkLinkPattern!=null){if(checkLinkPattern.indexOf("http:")>-1){checkLinkPattern=checkLinkPattern.replace("http:","https:");}copy.linkPattern=checkLinkPattern;}var data={taskType:taskType,isOpen:isOpen,event:event,task:task};if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;if(taskType==='multipleChoice'||taskType==='journalling'||taskType==='video'||taskType==='survey'){var data={taskType:taskType,isOpen:isOpen,event:event,task:task};spfNavBarService.update('New Challenge Details',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);eventService.set(data);$location.path(location);}else{self.savingTask=true;clmDataStore.events.updateTask(event.$id,taskId,copy).then(function(){if(isOpen&&task.openedAt||!isOpen&&task.closedAt){return;}else if(isOpen){return clmDataStore.events.openTask(event.$id,taskId);}return clmDataStore.events.closeTask(event.$id,taskId);}).then(function(){spfAlert.success('Challenge saved.');}).catch(function(){spfAlert.error('Failed to save the challenge.');}).then(function(){self.savingTask=false;});}};}/**
 * Show event tasks and participants progress in a paged table.
 *
 */function clmEventTableFactory(){return{template:eventTableParticipantsTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',participants:'=',tasks:'=',progress:'=',solutions:'='},controller:ClmEventTableCtrl,controllerAs:'ctrl'};}function ClmEventTableCtrl($scope,$q,$log,$mdDialog,$document,urlFor,spfAlert,clmServicesUrl,clmDataStore,clmPagerOption,eventService,$location,routes,$route,spfAuthData,authFirebaseApp,firebaseApp,$firebaseArray,$firebaseObject){var authDb=authFirebaseApp.database();var self=this;var unwatchers=[];this.currentUserParticipant=undefined;this.participantsView=[];this.visibleTasks=[];this.taskCompletion={};this.orderOptions={key:undefined,reversed:false};//Find superReviewUser rights
// console.log(self.profile);
this.isReviewSuperUser=false;if(self.event.owner.publicId==self.profile.$id){self.isReviewSuperUser=true;}if(self.event.assistants){if(self.event.assistants[self.profile.$id]){if(self.event.assistants[self.profile.$id].canReview){self.isReviewSuperUser=true;}}}this.pagerOptions=clmPagerOption();unwatchers.push(self.pagerOptions.$destroy.bind(self.pagerOptions));/**
     * Get current user participant row
     */function currentUserParticipant(){if(!self.participants||!self.participants.$getRecord||!self.profile||!self.profile.$id){self.currentUserParticipant=undefined;}self.currentUserParticipant=self.participants.$getRecord(self.profile.$id);}/**
     * Set list of visible tasks and the % completion.
     *
     */function visibleTasks(){if(!self.tasks||!self.tasks.filter){self.visibleTasks=[];return;}self.visibleTasks=self.tasks.filter(function(t){return!t.hidden&&!t.archived;});taskCompletion();}/**
     * Calculate all visible tasks completion rate.
     *
     */function taskCompletion(){self.taskCompletion=self.visibleTasks.reduce(function(all,task){all[task.$id]=_taskCompletion(task.$id);return all;},{});}/**
     * Return the completion rate of a task.
     *
     */function _taskCompletion(taskId){var participantCount,participantsIds;if(!self.participants||!self.progress){return 0;}participantCount=self.participants.length;participantsIds=self.participants.reduce(function(all,participant){if(participant.$id){all[participant.$id]=true;}return all;},{});if(participantCount<1){return 0;}return Object.keys(self.progress).filter(function(publicId){return participantsIds[publicId]&&// Make sure user is still participating
// (user progress is kept when they leave)
self.progress[publicId]&&self.progress[publicId][taskId]&&self.progress[publicId][taskId].completed;}).length/participantCount*100;}function _completionComparer(options){var taskId=options.key;return function(a,b){var aP=self.progress&&self.progress[a.$id]&&self.progress[a.$id][taskId]&&self.progress[a.$id][taskId].completed;var bP=self.progress&&self.progress[b.$id]&&self.progress[b.$id][taskId]&&self.progress[b.$id][taskId].completed;if(aP===bP){return 0;}else if(aP){return 1;}return-1;};}function _solutionComparer(options){var taskId=options.key;var task=self.tasks.$getRecord(taskId);if(!task||!task.textResponse&&!task.linkPattern){return noop$6;}return function(a,b){var aS=self.solutions&&self.solutions[a.$id]&&self.solutions[a.$id][taskId]||'';var bS=self.solutions&&self.solutions[b.$id]&&self.solutions[b.$id][taskId]||'';return aS.localeCompare(bS);};}function _compareName(a,b){var aN=a.user&&a.user.displayName||'';var bN=b.user&&b.user.displayName||'';return aN.localeCompare(bN);}function sortedParticipants(participants,options){var rows=participants.filter(function(p){return p.$id!==self.profile.$id;});var comparer;if(options.key){comparer=chainComparer([_completionComparer(options),_solutionComparer(options),_compareName]);}else{comparer=_compareName;}rows.sort(reverseComparer(options.reversed,comparer));return rows;}// Update the pager rowCount
// (the pager should trigger a range update which will call participantsView)
function updateParticipantRowCount(){currentUserParticipant();if(self.currentUserParticipant){self.pagerOptions.setRowCount(self.participants.length-1);}else{self.pagerOptions.setRowCount(self.participants.length);}}/**
     * Set the slice of participant to show.
     *
     */function participantsView(){var rows=sortedParticipants(self.participants,self.orderOptions);self.participantsView=rows.slice(self.pagerOptions.range.start,self.pagerOptions.range.end);}/**
     * Switch ordering key or ordering direction.
     *
     * If the ordering key is changing, the ordering direction should be
     * ascendent.
     *
     * If the order key is not changing, the direction should be switched.
     *
     */this.orderBy=function(taskId){self.orderOptions.reversed=!self.orderOptions.reversed&&self.orderOptions.key===taskId;self.orderOptions.key=taskId;participantsView();};function defaultLinker(task,serviceProfile){if(!serviceProfile||!serviceProfile.details||!serviceProfile.details.id||!task||!task.badge||!task.badge.url){return'#'+urlFor('editProfile');}return task.badge.url;}var linkers={codeSchool:defaultLinker,codeCombat:defaultLinker,singPath:function singPath(task){if(!task||task.serviceId!=='singPath'){return'';}if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return clmServicesUrl.singPath;}return(clmServicesUrl.singPath+'/#'+'/paths/'+task.singPathProblem.path.id+'/levels/'+task.singPathProblem.level.id+'/problems/'+task.singPathProblem.problem.id+'/play').replace(/\/+/,'/');}};this.startLink=function(task,profile){var serviceProfile;if(!task||!task.serviceId||!linkers[task.serviceId]){return'';}serviceProfile=profile&&profile.services&&profile.services[task.serviceId];return linkers[task.serviceId](task,serviceProfile);};var trackedServices={codeSchool:true,codeCombat:true};this.startMCQ=function(eventId,taskId,task,participant,userSolution){// Assign eventTable variables to data
// var data = {
//     eventId: eventId,
//     taskId: taskId,
//     task: task,
//     participant: participant,
//     userSolution: userSolution
// }
// // Store data in eventService
// eventService.set(data);
console.log("participant isss:",participant);$location.path('/events/'+eventId+'/challenges/'+taskId+'/mcq/start');};this.startTRAT=function(eventId,taskId,task,participant){var data={eventId:eventId,taskId:taskId,task:task,participant:participant};// Store data in eventService
eventService.set(data);$location.path('/events/'+eventId+'/challenges/'+taskId+'/TRAT/start');};this.mustRegister=function(task,profile){return Boolean(task&&task.serviceId&&trackedServices[task.serviceId]&&(!profile||!profile.services||!profile.services[task.serviceId]||!profile.services[task.serviceId].details||!profile.services[task.serviceId].details.id));};this.editProfileInfo=function(eventId,taskId,task,participant){console.log(task);$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:editProfileTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){var self=this;this.task=task;this.yearOpts=['born before 1990'];this.userData={};for(var y=1991;y<=2011;y++){self.yearOpts.push(y);}clmDataStore.getProfileData(participant.$id).then(function(promise){return promise;}).then(function(data){self.participantInfo=data;console.log(self.participantInfo);if(self.participantInfo.yearOfBirth){self.userData.yearOfBirth=self.participantInfo.yearOfBirth;}if(self.participantInfo.school){self.userData.school=self.participantInfo.school;}}).catch(function(err){$log.error(err);return err;});clmDataStore.getSchools().then(function(promise){return promise;}).then(function(data){self.schools=data;}).catch(function(err){$log.error(err);return err;});this.camelText=function(input){return input.replace(/(?:^\w|[A-Z]|\b\w)/g,function(letter,index){return index==0?letter.toLowerCase():letter.toUpperCase();}).replace(/\s+/g,'');};this.save=function(){self.userData.displayName=self.participantInfo.displayName;self.userData.gravatar=self.participantInfo.gravatar;if(!self.userData.yearOfBirth){self.userData.yearOfBirth=self.participantInfo.yearOfBirth;}else{spfAuthData.user().then(function(data){var ref=authDb.ref('auth/users/'+data.$id+'/yearOfBirth');return ref.set(self.userData.yearOfBirth);}).catch(noop$6);}if(!self.userData.school){self.userData.school=self.participantInfo.school;}else{spfAuthData.user().then(function(data){var ref=authDb.ref('auth/users/'+data.$id+'/school');ref.set(cleanObj(self.userData.school));});}// if(!self.userData.country) {
//     self.userData.country = self.participantInfo.country;
// }
self.userData.publicId=participant.$id;clmDataStore.events.submitSolution(eventId,taskId,participant.$id,JSON.stringify(self.userData)).then(function(){}).catch(function(err){$log.error(err);spfAlert.error('Failed to register submission.');return err;});clmDataStore.updateProfile(self.userData).then(function(){$mdDialog.hide();spfAlert.success('Profile updated.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to update your profile.');return err;});// if(self.userData.school) {
//     spfFirebase.set(['auth/users'], actionObj);
// }
};this.cancel=function(){$mdDialog.hide();};}};this.promptForLink=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({parent:$document.body,template:linkTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(link){if(link.indexOf("http:")>-1){link=link.replace("http:","https:");}clmDataStore.events.submitSolution(eventId,taskId,participant.$id,link).then(function(){$mdDialog.hide();spfAlert.success('Link is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save the link.');return err;});clmDataStore.logging.inputLog({action:"submitLinkResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});};this.cancel=function(){$mdDialog.hide();};}};this.promptForTeamFormation=function(eventId,taskId,task,participant,userSolution){var db=firebaseApp.database();$mdDialog.show({parent:$document.body,template:teamFormationTmpl,controller:DialogController,controllerAs:'ctrl',resolve:{initialData:teamFormationInitialData}});function teamFormationInitialData(){console.log('InitialData loaded');//   var teamEventPromise = spfFirebase.loadedArray(['classMentors/eventTeams/',eventId,taskId]);
var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId);var teamEventPromise=$firebaseArray(ref);return $q.all({teams:teamEventPromise.$loaded().then(function(result){console.log(result);return result;}),selectedTeam:teamEventPromise.$loaded().then(function(result){console.log(result);var teams=result;for(var i=0;i<teams.length;i++){var team=teams[i];// If participant's public Id can be found, return team index.
console.log('Team: ',team);console.log('Participant id: ',participant.$id);if(team[participant.$id]){return i;}}return undefined;})});};function DialogController(initialData){console.log('initial data is: ',initialData);var self=this;// Learning point here. undefined means not yet assigned a value. Whereas null is a special object.
self.selectedTeam=initialData.selectedTeam;console.log(self.selectedTeam);self.teams={};self.teams=initialData.teams;console.log(self.teams);var previousSelectedTeam=undefined;var index2=undefined;for(var i=0;i<self.teams.length;i++){if(self.teams[i][participant.$id]){index2=i;break;}}console.log("participant id isss:",participant.$id);self.onChange=function(index){console.log('onChange fired');console.log(index);// If user has not joined any team before
if(previousSelectedTeam==undefined){if(index2!=undefined){leaveTeam(index2);}joinTeam(index);previousSelectedTeam=index;}else if(index!=previousSelectedTeam){//Check if selected index has changed, else do nothing.
// Leave previous team.
leaveTeam(previousSelectedTeam);// Join new team.
joinTeam(index);previousSelectedTeam=index;}};function leaveTeam(index){var team=self.teams[index];var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+team.$id+'/'+participant.$id);console.log(ref);//  spfFirebase.remove(['classMentors/eventTeams/',eventId,taskId,team.$id,participant.$id])
ref.remove().then(function(){team.currentSize-=1;});}function joinTeam(index){var team=self.teams[index];var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+team.$id+'/'+participant.$id);// spfFirebase.set(['classMentors/eventTeams/',eventId,taskId,team.$id,participant.$id],participant.user)
console.log(participant.user);ref.set(participant.user).then(function(){team.currentSize+=1;clmDataStore.events.submitSolution(eventId,taskId,participant.$id,"Completed");});}this.save=function(){};this.cancel=function(){$mdDialog.hide();};}DialogController.$inject=['initialData'];};this.promptForSurvey=function(eventId,taskId,task,participant,userSolution){if(task.survey==="School engagement scale"){$location.path('/events/'+eventId+'/'+taskId+'/survey1/'+task.survey);}if(task.survey==="Motivated strategies for learning"){//console.log("motivated strategies came in here");
//route to the below specified url
$location.path('/events/'+eventId+'/'+taskId+'/survey2/'+task.survey);}if(task.survey==="Education vs Dissatisfaction with learning"){$location.path('/events/'+eventId+'/'+taskId+'/survey3/'+task.survey);}};this.promptForTextResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({parent:$document.body,template:responseTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(response){console.log("this response is: ",response);//this line adds solution to firebase
clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});clmDataStore.logging.inputLog({action:"submitTextResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});};this.cancel=function(){$mdDialog.hide();};}};this.promptForCodeResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,controller:CodeController,controllerAs:'ctrl',onComplete:loadEditor});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);parent.loadingEditor=false;}function CodeController(){this.task=task;this.checkEditor=function(){return parent.loadingEditor;};if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(){var editor=ace.edit($document[0].querySelector('#editor'));var response=editor.getValue();clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});clmDataStore.logging.inputLog({action:"submitCodeResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});};this.cancel=function(){$mdDialog.hide();};}};this.viewCodeResponse=function(task,solution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,controller:CodeController,controllerAs:'ctrl',onComplete:loadEditor});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);parent.loadingEditor=false;}function CodeController(){this.task=task;this.checkEditor=function(){return parent.loadingEditor;};this.solution=solution;this.cancel=function(){$mdDialog.hide();};}};this.update=function(){};/*
     this.update = function(event, tasks, userSolutions, profile) {
     return clmDataStore.events.updateCurrentUserProfile(
     event, tasks, userSolutions, profile
     ).then(function() {
     spfAlert.success('Profile updated');
     }).catch(function(err) {
     $log.error(err);
     spfAlert.error('Failed to update profile');
     });
     };*/this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};// load up resources and start firebase watcher
this.loading=true;$q.all({userProgress:clmDataStore.events.getUserProgress(this.event.$id,this.profile.$id).then(function(progress){self.currentUserProgress=progress;unwatchers.push(progress.$destroy.bind(progress));return progress;}),userSolution:clmDataStore.events.getUserSolutions(this.event.$id,this.profile.$id).then(function(solutions){self.currentUserSolutions=solutions;unwatchers.push(solutions.$destroy.bind(solutions));return solutions;}),singpathQueuedSolution:clmDataStore.singPath.queuedSolutions(this.profile.$id).then(function(paths){unwatchers.push(paths.$destroy.bind(paths));return paths;})}).then(function(results){visibleTasks();// Set the participant view (via the pager range update event)
unwatchers.push(self.pagerOptions.onChange(participantsView));updateParticipantRowCount();// Monitor updates on task progress and participants list.
unwatchers.push(self.tasks.$watch(visibleTasks));unwatchers.push(self.progress.$watch(taskCompletion));unwatchers.push(self.participants.$watch(taskCompletion));unwatchers.push(self.participants.$watch(updateParticipantRowCount));return results;}).finally(function(){self.loading=false;}).then(function(results){var update=function update(){// Removed due to June 2016 profile updating process change.
// return clmDataStore.events.updateCurrentUserProfile(
// self.event,
// self.tasks,
// results.userSolution,
// self.profile
// );
};// Watch for singpath problem getting updated
unwatchers.push(results.singpathQueuedSolution.$watch(update));return update();}).catch(function(err){$log.error(err);});// clean up.
$scope.$on('$destroy',function(){unwatchers.forEach(function(f){if(f){try{f();}catch(err){$log.error(err);}}});});}//TODO: include the event to load initial data into surveyformfillctrl
function addSurveyEventTaskCtrlInitialData($q,$route,firebaseApp,$firebaseArray,spfAuthData,clmDataStore){//TODO: load and assign initial data for the survey form
// var eventId = $route.current.params.eventId
// var eventPromise = clmDataStore.events.get(eventId);
var db=firebaseApp.database();console.log("this firebaseapp database is",db);var errNoEvent=new Error('Event not found');var eventId=$route.current.params.eventId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$6);var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var canviewPromise=$q.all({event:eventPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.event));});//returns a promise object from firebase
var surveyRef=db.ref('classMentors/surveyTemplate');var survey=$firebaseArray(surveyRef);return $q.all({currentUser:spfAuthData.user().catch(noop$6),profile:profilePromise,event:eventPromise,canView:canviewPromise,survey2:survey.$loaded().then(function(){return survey;}),tasks:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getTasks(eventId);}}),participants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.participants(eventId);}}),progress:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getProgress(eventId);}}),solutions:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getSolutions(eventId);}})});}//TODO: include controller for the survey
function SurveyFormFillCtrl(spfNavBarService,$location,urlFor,initialData,$routeParams,clmDataStore,clmPagerOption,spfAlert,$scope,firebase){this.pagerOpts=clmPagerOption();var self=this;this.questions=initialData.survey2;this.ratingOptions=[{id:1},{id:2},{id:3},{id:4},{id:5},{id:6},{id:7}];if($routeParams.surveyTask==='School engagement scale'){self.responseRating=[{option:'Never'},{option:'On Occasion'},{option:'Some of the Time'},{option:'Most of the Time'},{option:'All of the Time'}];self.schEngageResp={};}if($routeParams.surveyTask==='Motivated strategies for learning'){self.questionsArr=[];for(var i=1;i<Object.keys(initialData.survey2[1]).length-1;i++){//console.log("testing: ", initialData.survey2[1]["Q" + i]);
self.questionsArr.push({'name':initialData.survey2[1]["Q"+i],'qnid':i});}self.motiResp={};}if($routeParams.surveyTask==='Education vs Dissatisfaction with learning'){this.familyMembers=[{name:'Father'},{name:'Mother'},{name:'Sister(s)'},{name:'Brother(s)'},{name:'Relative(s)'},{name:'Grandparent(s)'}];this.selectedFamily=[];this.selectedRaceEthnicity=[];this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}return list;};this.exists=function(item,list){return list.indexOf(item)>-1;};this.bdayMonth=[{month:'January'},{month:'February'},{month:'March'},{month:'April'},{month:'May'},{month:'June'},{month:'July'},{month:'August'},{month:'September'},{month:'October'},{month:'November'},{month:'December'}];this.ethnicity=[{firstRow:'White'},{firstRow:'African American'},{firstRow:'Hispanic/Latino'},{secondRow:'Asian'},{secondRow:'Native Hawaii/Pacific Islander'},{secondRow:'Other'}];//this.selectEthnicity = [];
this.eduDissResp={};this.questionJson={};console.log("this initialdata is",initialData.survey2[0]);//console.log("initial data before: ", initialData.survey2[0]);
for(var _i=1;_i<Object.keys(initialData.survey2[0]).length-1;_i++){this.eduDissResp[initialData.survey2[0][_i].title]={};}}//$routechangestart will be executed before users route to another page
var schEngageInvalid=true;var motiStratInvalid=true;var eduDissInvalid=true;$scope.$on("$routeChangeStart",function(event,next,current){if(schEngageInvalid&&motiStratInvalid&&eduDissInvalid){if(!confirm("You have not finished this survey. Are you sure you want to continue? All data will be lost")){event.preventDefault();}}});this.event=initialData.event;spfNavBarService.update('Survey',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})}]);this.saveSurveyResponse=function(response,item,task){var surveyResp=response;var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;//console.log("all the VALUES HERE: " + surveyResp + ", " + questionNumber + "," + taskId + ", " + eventId + ", " + userId + ", " + surveyType)
clmDataStore.events.saveSurveyResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyType);};this.saveEduDisMultiResponse=function(selectedArr,item,task,qnTitle){var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;if(questionNumber==2){var familyArr=[];//transfer selected family members values into array
for(var i=0;i<selectedArr.length;i++){familyArr.push(selectedArr[i].name);}clmDataStore.events.saveSurveyEduDisMultiResponse(familyArr,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}if(questionNumber==5){var ethnicityRace=[];//transfer selected race and ethnicity values into array
for(var i=0;i<selectedArr.length;i++){if(selectedArr[i].firstRow!=undefined){ethnicityRace.push(selectedArr[i].firstRow);}if(selectedArr[i].secondRow!=undefined){ethnicityRace.push(selectedArr[i].secondRow);}}clmDataStore.events.saveSurveyEduDisMultiResponse(ethnicityRace,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}};this.saveEduDisResponse=function(response,age,item,task,siblingNum,selectedMonth,country,language,qnTitle,bestResp){var surveyResp=response;var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var ageResp=age;var sibResp=siblingNum;var monthResp=selectedMonth;var qnTitle=qnTitle;var bornCountry=country;var spokenLanguage=language;var bestResp=bestResp;if(surveyResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(ageResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(ageResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(sibResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(sibResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(monthResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(monthResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(bornCountry!=undefined){clmDataStore.events.saveSurveyEduDisResponse(bornCountry,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(spokenLanguage!=undefined){clmDataStore.events.saveSurveyEduDisResponse(spokenLanguage,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(bestResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(bestResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}};this.submitSchEngageResponse=function(schEngageResp){//to set warning
schEngageInvalid=false;motiStratInvalid=true;eduDissInvalid=true;var allResponses=true;for(var i=1;i<schEngageResp.length;i++){if(schEngageResp[i][i+1]===0){allResponses=false;break;}}if(!allResponses){spfAlert.warning('Failed to save the responses. Please answer all questions.');}else{var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitSchEngageResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey responses have been submitted.');clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,schEngageResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");// clmDataStore.events.setProgress(eventId, taskId, userId, initialData.progress);
$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.submitMotiStratResponse=function(motiResp){//to set warning
motiStratInvalid=false;eduDissInvalid=true;schEngageInvalid=true;var allResponses=true;console.log("trying ",motiResp);for(var i=1;i<motiResp.length;i++){if(motiResp[i][i+1]===0){allResponses=false;break;}}if(!allResponses){spfAlert.warning('Failed to save the responses.');}else{var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitMotiStratResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey response has been submitted.');clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,motiResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.submitEduDissResponse=function(eduDissResp,selectedFamily,selectedRaceEthnicity){//to set warning
eduDissInvalid=true;motiStratInvalid=false;schEngageInvalid=false;//add checkbox values into json
var allResponses=true;for(var title in eduDissResp){if(title=="Tell us about YOURSELF:"){eduDissResp[title][2]=selectedFamily;eduDissResp[title][5]=selectedRaceEthnicity;}else if(title=="What do you like BEST in this class?"){//ignore
}else{for(var qn in eduDissResp[title]){if(eduDissResp[title][qn]==undefined){allResponses=false;break;}}}if(!allResponses){break;}}console.log("edudissresp values: ",eduDissResp);if(!allResponses){spfAlert.warning('Failed to save the responses.');}else{//retrieving all required variables to be added into firebase
var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitEduDissResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey response has been submitted.');//add into firebase
clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,eduDissResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.backToChallenge=function(){$location.path(urlFor('oneEvent',{eventId:self.event.$id}));};}function clmEventRankTableFactory(){return{template:eventTableRankTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',assistants:'='},controller:ClmEventRankTableCtrl,controllerAs:'ctrl'};}function ClmEventRankTableCtrl($scope,$log,firebaseApp,$firebaseObject,$firebaseArray,clmDataStore,clmPagerOption){var self=this;var db=firebaseApp.database();var unwatchers=[];var updateLog=function updateLog(actionObj){actionObj.publicId=self.profile.$id;actionObj.timestamp=TIMESTAMP$1;clmDataStore.logging.inputLog(actionObj);};// June 2016
this.rankingView2=[];// 2016 update to new cm-worker
// If there are no ranked services on the event, use the default.
// Add this after the event is fetched if rankedServices is null.
var addRankedServices=function addRankedServices(parentScope){if(parentScope.event.rankedServices){parentScope.rankedServices=[];for(var property in parentScope.event.rankedServices){if(parentScope.event.rankedServices.hasOwnProperty(property)){// do stuff
parentScope.rankedServices.push({id:property,name:property});}}}else{// load the default services to list in ranking table.
parentScope.rankedServices=[{id:'freeCodeCamp',name:'Free Code Camp'}];}};// Update the list of services to show in table.
addRankedServices(this);var getUserProfile=function getUserProfile(publicId,parentScope){var profileRef=db.ref('classMentors/userProfiles/'+publicId);var result=$firebaseObject(profileRef);result.$loaded().then(function(){var temp={};temp.$id=publicId;temp.$ranking=parentScope.rankingView2.length+1;temp.services=result.services;// console.log("In user profile fetch with services", result.services);
var total=0;// If the user has no registered services, add an empty object to support the following logic.
if(!result.services){result.services={};}// For each ranked service in the event.
for(var i=0;i<self.rankedServices.length;i++){// console.log(self.rankedServices[i].id);
// If the user has registered for the service and has a totoalAchievements value.
if(result.services[self.rankedServices[i].id]&&result.services[self.rankedServices[i].id].totalAchievements){temp[self.rankedServices[i].id]=parseInt(result.services[self.rankedServices[i].id].totalAchievements,10);total+=parseInt(result.services[self.rankedServices[i].id].totalAchievements,10);}else{temp[self.rankedServices[i].id]=0;}}temp.total=total;temp.displayName=result.user.displayName;temp.name=result.user.displayName;temp.user=result.user;// console.log(parentScope.event);
// console.log(parentScope.profile);
if(parentScope.assistants.indexOf(result.$id)<0&&parentScope.event.owner.publicId!==result.$id){parentScope.rankingView2.push(temp);}},function(reason){console.log('Failed '+reason);});};var refreshAchievements=function refreshAchievements(profileId,service){// TODO: Only request updates for the services that users have registered for.
console.log('Requesting achievement update for '+profileId);db.ref('queue/tasks').push({id:profileId,service:service});};this.updateAllParticipantUserProfiles=function(){// console.log("Requesting all users in ranking to be updated.");
updateLog({action:"updateAllParticipantUserProfiles","eventId":self.event.$id});// For each user in the ranking
for(var i=0;i<self.rankingView2.length;i++){var publicId=self.rankingView2[i].$id;// for service in ranked services
for(var j=0;j<self.rankedServices.length;j++){// console.log(self.rankedServices[j].id);
// If the user in the ranking has the key services and key for a service
if(self.rankingView2[i].services&&self.rankingView2[i].services[self.rankedServices[j].id]){// console.log("Adding "+self.rankedServices[j].id+ " for user "+publicId);
refreshAchievements(publicId,self.rankedServices[j].id);}else{// console.log("Skipping "+self.rankedServices[j].id+ " for user "+publicId+ " since not registered");
}}}};var getUserProfilesFromEventParticipants=function getUserProfilesFromEventParticipants(parentScope){// Clear ranking and re-rank
parentScope.rankingView2=[];console.log('Fetching participants for event');for(var i=0;i<parentScope.eventParticipants.length;i++){var publicId=parentScope.eventParticipants[i].$id;getUserProfile(publicId,parentScope);}};this.getParticipants=function(parentScope){var ref=db.ref('classMentors/eventParticipants/'+parentScope.event.$id);var query=ref.limitToLast(100);var data=$firebaseArray(query);data.$loaded().then(function(){var result=data;// console.log(result);
parentScope.eventParticipants=result;getUserProfilesFromEventParticipants(parentScope);},function(reason){console.log('Failed '+reason);});};this.getParticipants(this);this.loading=true;// This will hide the table view.
this.loading=false;this.currentUserRanking=undefined;this.orderOpts=[{key:'total',reversed:true},{key:'name',reversed:false}];this.pagerOpts=clmPagerOption();unwatchers.push(self.pagerOpts.$destroy.bind(self.pagerOpts));/*
     load();

     function load() {
     $scope.$on('$destroy', unload);

     return clmDataStore.events.getRanking(self.event.$id).then(function(ranking) {
     self.ranking = ranking;

     // Update ranking view via the pager range update event.
     unwatchers.push(self.pagerOpts.onChange(rankingView));
     updateRowCount();

     unwatchers.push(self.ranking.$destroy.bind(self.ranking));
     unwatchers.push(self.ranking.$watch(updateRowCount));
     }).finally(function() {
     self.loading = false;
     }).catch(function(e) {
     $log.error(e);
     });
     }

     function unload() {
     unwatchers.forEach(function(f) {
     if (f) {
     try {
     f();
     } catch (err) {
     $log.error(err);
     }
     }
     });
     }
     */// function badgeComparer(propId) {
//   return function(a, b) {
//     var aB = a[propId] || 0;
//     var bB = b[propId] || 0;
//     return aB - bB;
//   };
// }
// function comparer(options) {
//   return chainComparer(options.map(function(opt) {
//     return reverseComparer(opt.reversed, _comparers[opt.key] || _comparers.total);
//   }));
// }
// function currentUserRanking() {
//   self.currentUserRanking = undefined;
//   rankingList.some(function(p) {
//     if (!self.profile) {
//       return true;
//     }
//     if (p.$id === self.profile.$id) {
//       self.currentUserRanking = p;
//       return true;
//     }
//     return false;
//   });
// }
// function rankingView() {
//   console.log('In ranking view');
//   rankingList.sort(comparer(self.orderOpts)).forEach(function(p, i) {
//     p.$ranking = i + 1;
//   });
//   self.rankingView2 = rankingList.slice(
//     self.pagerOpts.range.start,
//     self.pagerOpts.range.end
//   );
//   currentUserRanking();
// }
// Update pager's row count
// (the pager should trigger a range update and call rankingView)
// function updateRowCount() {
//   if (!self.ranking) {
//     rankingList = [];
//     self.pagerOpts.setRowCount(0);
//     return;
//   }
//   rankingList = Object.keys(self.ranking).filter(function(publicId) {
//     return self.ranking[publicId] && self.ranking[publicId].user;
//   }).map(function(publicId) {
//     self.ranking[publicId].$id = publicId;
//     return self.ranking[publicId];
//   });
//   self.pagerOpts.setRowCount(rankingList.length);
// }
this.orderBy=function(key){// Adjust this to support new ordering mechanism.
console.log('orderBy '+key);if(self.orderOpts[0]&&self.orderOpts[0].key===key){self.orderOpts[0].reversed=!self.orderOpts[0].reversed;}else{self.orderOpts.unshift({key:key,reversed:true});self.orderOpts=self.orderOpts.slice(0,2);}updateLog({action:"eventRankingOrderby","eventId":self.event.$id,"key":key,"reversed":self.orderOpts[0].reversed});// TODO: Revisit when 2nd order ranking becomes a priority.
// There was an issue with getting both strings and numbers to rank properly.
// Just leaving the array as is and allowing the view to do the sorting.
// console.log(self.orderOpts);
// Can we use > rather than - to deal with strings?
/*
         if(self.orderOpts[1].reversed){
         self.rankingView2.sort(function(a, b) {
         return b[self.orderOpts[1].key] - a[self.orderOpts[1].key];
         });
         }
         else{
         self.rankingView2.sort(function(a, b) {
         return a[self.orderOpts[1].key] - b[self.orderOpts[1].key];
         });
         }

         if(self.orderOpts[0].reversed){
         self.rankingView2.sort(function(a, b) {
         return b[self.orderOpts[0].key] - a[self.orderOpts[0].key];
         });
         }
         else{
         self.rankingView2.sort(function(a, b) {
         return a[self.orderOpts[0].key] - b[self.orderOpts[0].key];
         });
         }

         //Update ordering
         for(var i=0; i<self.rankingView2.length; i++){
         self.rankingView2[i]["$ranking"] = i+1;
         }
         */// rankingView();
};}// Show event participants and submissions in a paged table
function clmEventResultsTableFactory(){return{template:eventTableResultsTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',participants:'=',tasks:'=',progress:'=',solutions:'=',selected:'=',scores:'='},controller:ClmEventResultsTableCtrl,controllerAs:'ctrl'};}function ClmEventResultsTableCtrl($scope,$q,$log,$mdDialog,$document,urlFor,spfAlert,clmServicesUrl,clmDataStore,clmPagerOption,$sce){var self=this;var unwatchers=[];this.currentUserParticipant=undefined;this.participantsView=[];this.visibleTasks=[];this.taskCompletion={};this.orderOptions={key:undefined,reversed:false};this.pagerOptions=clmPagerOption();unwatchers.push(self.pagerOptions.$destroy.bind(self.pagerOptions));/**
     * Get current user participant row
     */function currentUserParticipant(){if(!self.participants||!self.participants.$getRecord||!self.profile||!self.profile.$id){self.currentUserParticipant=undefined;}self.currentUserParticipant=self.participants.$getRecord(self.profile.$id);}/**
     * Set list of visible tasks and the % completion.
     *
     */function visibleTasks(){if(!self.tasks||!self.tasks.filter){self.visibleTasks=[];return;}self.visibleTasks=self.tasks.filter(function(t){return!t.hidden&&!t.archived;});taskCompletion();}/**
     * Calculate all visible tasks completion rate.
     *
     */function taskCompletion(){self.taskCompletion=self.visibleTasks.reduce(function(all,task){all[task.$id]=_taskCompletion(task.$id);return all;},{});}/**
     * Return the completion rate of a task.
     *
     */function _taskCompletion(taskId){var participantCount,participantsIds;if(!self.participants||!self.progress){return 0;}participantCount=self.participants.length;participantsIds=self.participants.reduce(function(all,participant){if(participant.$id){all[participant.$id]=true;}return all;},{});if(participantCount<1){return 0;}return Object.keys(self.progress).filter(function(publicId){return participantsIds[publicId]&&// Make sure user is still participating
// (user progress is kept when they leave)
self.progress[publicId]&&self.progress[publicId][taskId]&&self.progress[publicId][taskId].completed;}).length/participantCount*100;}function _completionComparer(options){var taskId=options.key;return function(a,b){var aP=self.progress&&self.progress[a.$id]&&self.progress[a.$id][taskId]&&self.progress[a.$id][taskId].completed;var bP=self.progress&&self.progress[b.$id]&&self.progress[b.$id][taskId]&&self.progress[b.$id][taskId].completed;if(aP===bP){return 0;}else if(aP){return 1;}return-1;};}function _solutionComparer(options){var taskId=options.key;var task=self.tasks.$getRecord(taskId);if(!task||!task.textResponse&&!task.linkPattern){return noop$6;}return function(a,b){var aS=self.solutions&&self.solutions[a.$id]&&self.solutions[a.$id][taskId]||'';var bS=self.solutions&&self.solutions[b.$id]&&self.solutions[b.$id][taskId]||'';return aS.localeCompare(bS);};}function _compareName(a,b){var aN=a.user&&a.user.displayName||'';var bN=b.user&&b.user.displayName||'';return aN.localeCompare(bN);}function sortedParticipants(participants,options){var rows=participants.filter(function(p){return p.$id!==self.profile.$id;});var comparer;if(options.key){comparer=chainComparer([_completionComparer(options),_solutionComparer(options),_compareName]);}else{comparer=_compareName;}rows.sort(reverseComparer(options.reversed,comparer));return rows;}// Update the pager rowCount
// (the pager should trigger a range update which will call participantsView)
function updateParticipantRowCount(){currentUserParticipant();if(self.currentUserParticipant){self.pagerOptions.setRowCount(self.participants.length-1);}else{self.pagerOptions.setRowCount(self.participants.length);}}/**
     * Set the slice of participant to show.
     *
     */function participantsView(){var rows=sortedParticipants(self.participants,self.orderOptions);self.participantsView=rows.slice(self.pagerOptions.range.start,self.pagerOptions.range.end);self.participantsView.unshift(self.currentUserParticipant);}/**
     * Switch ordering key or ordering direction.
     *
     * If the ordering key is changing, the ordering direction should be
     * ascendent.
     *
     * If the order key is not changing, the direction should be switched.
     *
     */this.orderBy=function(taskId){self.orderOptions.reversed=!self.orderOptions.reversed&&self.orderOptions.key===taskId;self.orderOptions.key=taskId;participantsView();};function defaultLinker(task,serviceProfile){if(!serviceProfile||!serviceProfile.details||!serviceProfile.details.id||!task||!task.badge||!task.badge.url){return'#'+urlFor('editProfile');}return task.badge.url;}var linkers={codeSchool:defaultLinker,codeCombat:defaultLinker,singPath:function singPath(task){if(!task||task.serviceId!=='singPath'){return'';}if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return clmServicesUrl.singPath;}return(clmServicesUrl.singPath+'/#'+'/paths/'+task.singPathProblem.path.id+'/levels/'+task.singPathProblem.level.id+'/problems/'+task.singPathProblem.problem.id+'/play').replace(/\/+/,'/');}};this.startLink=function(task,profile){var serviceProfile;if(!task||!task.serviceId||!linkers[task.serviceId]){return'';}serviceProfile=profile&&profile.services&&profile.services[task.serviceId];return linkers[task.serviceId](task,serviceProfile);};var trackedServices={codeSchool:true,codeCombat:true};this.mustRegister=function(task,profile){return Boolean(task&&task.serviceId&&trackedServices[task.serviceId]&&(!profile||!profile.services||!profile.services[task.serviceId]||!profile.services[task.serviceId].details||!profile.services[task.serviceId].details.id));};this.viewLink=function(eventId,taskId,task,participant,userSolution){console.log(participant);$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:linkTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.review=true;this.participant=participant;if(userSolution&&userSolution[taskId]){this.solution=$sce.trustAsResourceUrl(userSolution[taskId]);}this.save=function(link){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,link).then(function(){$mdDialog.hide();spfAlert.success('Link is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save the link.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.viewMultipleChoiceResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:mcqTmpl$1,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.viewOnly=true;this.questions=angular.fromJson(this.task.mcqQuestions);this.isChecked=function(answers,index){return answers.indexOf(index)>-1;};this.show=function(answers){return answers.length>1;};// If userSolution is not null and userSolution given
// taskId is not null
if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}var userAnswers=angular.fromJson(this.solution).userAnswers;console.log(userAnswers);for(var i=0;i<this.questions.length;i++){this.questions[i].answers=userAnswers[i];}console.log(this.questions);this.cancel=function(){$mdDialog.hide();};}};this.viewTextResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:responseTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.viewOnly=true;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(response){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.viewCodeResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,onComplete:loadEditor,controller:CodeController,controllerAs:'ctrl'});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);editor.setOptions({readOnly:true,highlightActiveLine:false,highlightGutterLine:false});parent.loadingEditor=false;}function CodeController(){this.task=task;this.viewOnly=true;this.checkEditor=function(){return parent.loadingEditor;console.log(parent.loadingEditor);};if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(){var editor=ace.edit(document.querySelector('#editor'));var response=editor.getValue();console.log("Function submitted for answer "+response);clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.saveAllocatedPoints=function(eventId,taskId,task,participant,score){clmDataStore.events.saveScore(eventId,participant.$id,taskId,score).then(function(){spfAlert.success('Score has been saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save score.');return err;});};this.update=function(){};/*
     this.update = function(event, tasks, userSolutions, profile) {
     return clmDataStore.events.updateCurrentUserProfile(
     event, tasks, userSolutions, profile
     ).then(function() {
     spfAlert.success('Profile updated');
     }).catch(function(err) {
     $log.error(err);
     spfAlert.error('Failed to update profile');
     });
     };*/this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};// load up resources and start firebase watcher
this.loading=true;$q.all({userProgress:clmDataStore.events.getUserProgress(this.event.$id,this.profile.$id).then(function(progress){self.currentUserProgress=progress;unwatchers.push(progress.$destroy.bind(progress));return progress;}),userSolution:clmDataStore.events.getUserSolutions(this.event.$id,this.profile.$id).then(function(solutions){self.currentUserSolutions=solutions;unwatchers.push(solutions.$destroy.bind(solutions));return solutions;}),singpathQueuedSolution:clmDataStore.singPath.queuedSolutions(this.profile.$id).then(function(paths){unwatchers.push(paths.$destroy.bind(paths));return paths;})}).then(function(results){visibleTasks();// Set the participant view (via the pager range update event)
unwatchers.push(self.pagerOptions.onChange(participantsView));updateParticipantRowCount();// Monitor updates on task progress and participants list.
unwatchers.push(self.tasks.$watch(visibleTasks));unwatchers.push(self.progress.$watch(taskCompletion));unwatchers.push(self.participants.$watch(taskCompletion));unwatchers.push(self.participants.$watch(updateParticipantRowCount));return results;}).finally(function(){self.loading=false;}).then(function(results){var update=function update(){// Removed due to June 2016 profile updating process change.
/*
             return clmDataStore.events.updateCurrentUserProfile(
             self.event,
             self.tasks,
             results.userSolution,
             self.profile
             );
             */};// Watch for singpath problem getting updated
unwatchers.push(results.singpathQueuedSolution.$watch(update));return update();}).catch(function(err){$log.error(err);});// clean up.
$scope.$on('$destroy',function(){unwatchers.forEach(function(f){if(f){try{f();}catch(err){$log.error(err);}}});});}function clmPagerFactory(){return{template:pagerTmpl,restrict:'E',bindToController:true,scope:{options:'='},controller:ClmPagerCtrl,controllerAs:'ctrl'};}// Keep row per page selection acrossviews.
function clmRowPerPageFactory($log){var cb=[];var opts={value:50,options:[5,10,25,50,75,100],set:function set(value){opts.value=parseInt(value,10);if(opts.value<1){opts.value=1;}opts.triggerChange();},/**
         * Register a function to call synchronously whn roePerPage is set.
         *
         * If the function needs to modify the rowPerPage it shouldn't use the
         * setter or do it asynchronously.
         *
         * @param  {function} fn
         * @return {function}
         */onChange:function onChange(fn){cb.push(fn);return function(){cb=cb.filter(function(f){return f!==fn;});};},triggerChange:function triggerChange(){cb.forEach(function(fn){try{fn(opts.value);}catch(err){$log.error(err);}});}};return opts;}function clmPagerOptionFactory($log,clmRowPerPage){return function clmPagerOption(){var rangeCBs=[];var unwatch;var opts={rowCount:0,range:{start:0,end:0},/**
             * Set rowCount and reset range.
             *
             * Trigger a change "event".
             *
             * @param {number} count
             */setRowCount:function setRowCount(count){opts.rowCount=count;opts.setRange(opts.range.start);},/**
             * Set range from its starting index and `clmRowPerPage.value`.
             *
             * The range start index will be set to the start of a page, with the
             * first page starting at zero and the second page starting at
             * `clmRowPerPage.value`, etc...
             *
             * @param {number} start
             */setRange:function setRange(start){var end;start=start||0;if(start<0){start=0;}start-=start%clmRowPerPage.value;if(start>opts.rowCount){start=opts.rowCount;}end=start+clmRowPerPage.value;if(end>opts.rowCount){end=opts.rowCount;}opts.range.start=start;opts.range.end=end;opts.triggerChange();},/**
             * Register a function to be called each time the the pager data
             * are set.
             *
             * Setting the rowCount, the range or setting `clmRowPerPage.value`
             * will trigger a call synchronously.
             *
             * The calls must not update rowCount or the range using the setters
             * (or if it does it use them asynchronously).
             *
             * @param  {Function} cb Function to register.
             * @return {Function}    Deregister the function.
             */onChange:function onChange(cb){rangeCBs.push(cb);return function(){rangeCBs=rangeCBs.filter(function(fn){return fn!==cb;});};},triggerChange:function triggerChange(){rangeCBs.forEach(callCB);},$destroy:function $destroy(){unwatch();}};unwatch=clmRowPerPage.onChange(function(){opts.setRange(opts.range.start);});function callCB(cb){try{cb(opts);}catch(err){$log.error(err);}}return opts;};}function ClmPagerCtrl(clmRowPerPage){this.rowPerPage=clmRowPerPage;this.nextPage=function(options){options.setRange(options.range.end);};this.prevPage=function(options){options.setRange(options.range.start-1);};this.firstPage=function(options){options.setRange(0);};this.lastPage=function(options){options.setRange(options.rowCount);};}function reverseComparer(reverse,fn){if(!reverse){return fn;}return function(a,b){var result=fn(a,b);return result*-1;};}function chainComparer(comparerList){return function(a,b){var i,result;for(i=0;i<comparerList.length;i++){result=comparerList[i](a,b);if(result){return result;}}return 0;};}function configServices(clmServices){clmServices.register('Code Combat');clmServices.register('Free Code Camp');clmServices.register('Pivotal Expert');}function configRoute$4($routeProvider,routes){$routeProvider.when(routes.editProfile,{template:editTmpl$1,controller:ClmProfileCtrl,controllerAs:'ctrl',resolve:{initialData:clmEditProfileInitialDataResolver}}).when(routes.profile,{template:showTmpl,controller:ClmProfileCtrl,controllerAs:'ctrl',resolve:{initialData:clmShowProfileInitialDataResolver}});}/**
 * Used to resolve `initialData` of `ClmProfileCtrl` the logged in user profile.
 *
 */function clmEditProfileInitialDataResolver($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('You need to be logged to edit her/his profile.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise,currentUserProfile:profilePromise,settings:clmDataStore.settings.getObj()});}/**
 * Used to resolve `initialData` of `ClmProfileCtrl` for a public profile.
 *
 */function clmShowProfileInitialDataResolver($q,$route,spfAuth,spfAuthData,clmDataStore){var publicId=$route.current.params.publicId;var profilePromise;var errNoPublicId=new Error('Unexpected error: the public id is missing');var errNoProfile=new Error('Could not found the profile for '+publicId);if(!publicId){return $q.reject(errNoPublicId);}profilePromise=clmDataStore.profile(publicId).then(function(profile){if(profile.$value===null){return $q.reject(errNoProfile);}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(noop$7),currentUserProfile:clmDataStore.currentUserProfile(),profile:profilePromise,settings:clmDataStore.settings.getObj()});}/**
 * ClmProfileCtrl
 *
 */function ClmProfileCtrl($log,$q,$timeout,$route,spfAuthData,spfNavBarService,initialData,clmDataStore,spfAlert,clmRefreshTimout){var _this=this;var refreshLabel='Refresh Achievements';var waitingLabel='Waiting...';var self=this;var refreshButton={title:refreshLabel,onClick:function onClick(){return _this.refreshAllService();},icon:'loop',disabled:false};var menu=[refreshButton];this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.currentUserProfile=initialData.currentUserProfile;this.profile=initialData.profile;this.settings=initialData.settings;this.canRefresh=true;this.refreshTimeout=undefined;if(this.profile&&this.profile.$id&&this.currentUser&&this.currentUser.publicId===this.profile.$id){menu.push({title:'Edit',onClick:function onClick(){return _this.profileNeedsUpdate=true;},icon:'create'});}spfNavBarService.update('Profile',undefined,menu);this.settingPublicId=false;// this.profileNeedsUpdate = this.currentUser && !this.currentUser.$completed();
this.profileNeedsUpdate=false;function cleanProfile(currentUser){currentUser.country=cleanObj(currentUser.country);currentUser.school=cleanObj(currentUser.school);}this.goBack=function(){self.profileNeedsUpdate=false;};this.setPublicId=function(currentUser){var saved;this.settingPublicId=true;cleanProfile(currentUser);if(!self.profile){saved=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved');return clmDataStore.initProfile();});}else{saved=currentUser.$save().then(function(){return clmDataStore.updateProfile(currentUser);});}return saved.then(function(){spfAlert.success('Profile setup.');return $route.reload();}).catch(function(err){spfAlert.error('Failed to ');return $q.reject(err);}).finally(function(){self.settingPublicId=false;});};this.refreshAllService=function(){_this.disableRefresh();clmDataStore.services.refresh(_this.profile).catch(function(err){_this.canRefresh=true;$log.error(err);spfAlert.error('Failed to refresh achievements.');});};this.disableRefresh=function(){refreshButton.title=waitingLabel;refreshButton.disabled=true;_this.canRefresh=false;_this.refreshTimeout=$timeout(clmRefreshTimout);_this.refreshTimeout.then(function(){return _this.enableRefresh();});};this.enableRefresh=function(){refreshButton.title=refreshLabel;refreshButton.disabled=false;if(_this.refreshTimeout){$timeout.cancel(_this.refreshTimeout);_this.refreshTimeout=undefined;}};this.$onDestroy=function(){if(_this.refreshTimeout){$timeout.cancel(_this.refreshTimeout);_this.refreshTimeout=undefined;}};}/**
 * Route admin requests to the admin component.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         Routes map.
 */function configRoute$5($routeProvider,routes){$routeProvider.when(routes.admin,{template:'<clm-admin></clm-admin>'});}/**
 * Bootstrap classmentors Angular app and overwrite default settings.
 *
 * @param {{firebaseApp: string, singpathUrl: string, backendUrl: string}} options Application
 */function bootstrap(options){var bootstrapModule=angular$1.module('classmentors.bootstrap',[module$1.name]);options=options||{};if(options.firebaseApp){bootstrapModule.constant('firebaseApp',options.firebaseApp);bootstrapModule.constant('authFirebaseApp',options.firebaseApp);}else{// use singpath firebase by default
var firebaseApp=firebase.initializeApp({apiKey:'AIzaSyBH01uLzdMqH0hkbDqvcgpzTDpo6yYtPDA',authDomain:'singpath.firebaseapp.com',databaseURL:'https://singpath.firebaseio.com'});bootstrapModule.constant('firebaseApp',firebaseApp);bootstrapModule.constant('authFirebaseApp',firebaseApp);}if(options.provider){bootstrapModule.constant('authProvider',options.provider);}else{var provider=new firebase.auth.GoogleAuthProvider();provider.addScope('https://www.googleapis.com/auth/userinfo.email');provider.addScope('https://www.googleapis.com/auth/userinfo.profile');bootstrapModule.constant('authProvider',provider);}bootstrapModule.run(['clmServicesUrl',function(clmServicesUrl){if(options.singpathURL){clmServicesUrl.singPath=options.singpathURL.replace(/\/$/,'');}if(options.backendURL){clmServicesUrl.backend=options.backendURL.replace(/\/$/,'');}}]);angular$1.element(document).ready(function(){angular$1.bootstrap(document,[bootstrapModule.name],{strictDi:true});});}return{setters:[function(_2){},function(_3){angular$1=_3.default;},function(_4){},function(_5){},function(_6){},function(_7){},function(_8){},function(_9){},function(_10){},function(_11){},function(_12){},function(_13){},function(_14){},function(_15){},function(_16){CryptoJS=_16.default;},function(_17){},function(_18){},function(_19){camelCase=_19.default;},function(_20){},function(_21){},function(_22){},function(_23){firebase=_23.default;},function(_24){},function(_25){},function(_26){},function(_27){},function(_28){},function(_29){},function(_d){},function(_b){ace=_b.default;},function(_a){},function(_c){},function(_d2){},function(_e){},function(_f){},function(_a2){},function(_d3){c3=_d3.default;},function(_e2){},function(_f2){}],execute:function(){noop=function noop(){return undefined;};spfEditorDirectiveFactory.$inject=['$log'];ace$1=Object.freeze({spfEditorDirectiveFactory:spfEditorDirectiveFactory});tmpl="<!-- ng-class=\"ctrl.notifications[0].notificationType\" -->\n<md-toast class=\"md-whiteframe-z2\" ng-class=\"ctrl.notifications[0].notificationType\" layout-padding layout-margin>\n    <span flex>{{ctrl.notifications[0].message}}</span>\n    <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.prev()\" ng-disabled=\"ctrl.notifications.length < 2\">\n        Prev\n    </md-button>\n    <md-button class=\"md-raised md-accent\" ng-click=\"ctrl.close()\">\n        Close\n    </md-button>\n</md-toast>\n";SpfAlertCtrl.$inject=['$mdToast','notifications','toastOptions'];spfAlertFactory.$inject=['$q','$mdToast'];alert=Object.freeze({spfAlertFactory:spfAlertFactory});tmpl$1="<div class=\"md-toolbar-tools\" ng-controller=\"SpfSharedNavBarCtrl as navBar\">\n    <md-button ng-click=\"navBar.openSideMenu('left')\" hide-gt-md class=\"open-menu\" aria-label=\"open side menu\">\n        <md-icon md-svg-icon=\"reorder\" alt=\"open side menu\"></md-icon>\n    </md-button>\n\n    <div hide-sm layout=\"row\" ng-repeat=\"parent in navBar.currentPage.parents\" class=\"nav-parent\">\n        <h2 ng-if=\"parent.title\">\n            <a ng-href=\"{{parent.url || ''}}\">\n                {{parent.title}}\n            </a>\n        </h2>\n\n        <md-icon class=\"separator\"\n            md-svg-icon=\"keyboard-arrow-right\"\n            ng-if=\"navBar.currentPage.parent &amp;&amp; navBar.currentPage.section\"\n        ></md-icon>\n    </div>\n\n    <h3 ng-bind=\"navBar.currentPage.section\"></h3>\n\n    <span flex></span>\n\n    <md-button class=\"menu-item responsive-button md-raised md-primary\" ng-repeat=\"btn in navBar.currentPage.menuItems track by (btn.url || btn.onClick)\" ng-href=\"{{btn.url}}\" aria-label=\"{{btn.title}}\" ng-click=\"btn.onClick()\" ng-disabled=\"btn.disabled\">\n        <md-icon md-svg-icon=\"{{btn.icon}}\" ng-if=\"btn.icon\"></md-icon>\n        <span ng-bind=\"btn.title\" hide show-gt-sm></span>\n    </md-button>\n\n    <span ng-switch=\"navBar.auth.user.uid\">\n        <span ng-switch-when=\"undefined\">\n            <md-button ng-click=\"navBar.login()\" class=\"responsive-button md-raised md-accent\">\n                <md-icon md-svg-icon=\"launch\"></md-icon>\n                <span hide-sm>login</span>\n            </md-button>\n        </span>\n        <span ng-switch-default>\n            <md-button ng-click=\"navBar.logout()\" class=\"responsive-button md-raised md-primary\">\n                <md-icon md-svg-icon=\"exit-to-app\"></md-icon>\n                <span hide-sm>logout</span>\n            </md-button>\n        </span>\n    </span>\n</div>\n";noop$1=function noop(){return undefined;};initNavBar.$inject=['$templateCache'];spfNavBarServiceFactory.$inject=[];SpfSharedNavBarCtrl.$inject=['$q','$mdSidenav','spfAlert','spfAuth','spfNavBarService'];navbar=Object.freeze({initNavBar:initNavBar,spfNavBarServiceFactory:spfNavBarServiceFactory,SpfSharedNavBarCtrl:SpfSharedNavBarCtrl});tmpl$2="<ng-form name=\"signForm\">\n\t<div layout layout-sm=\"column\">\n        <md-input-container flex ng-if=\"!ctrl.publicIdIsReadOnly\">\n            <label for=\"sign-public-id\">Your Public Id</label>\n            <input ng-minlength=\"3\" md-maxlength=\"20\" ng-pattern=\"/^[-a-z0-9]+$/\" required id=\"sign-public-id\" name=\"userPublicId\" ng-model=\"currentUser.publicId\" spf-uniq-public-id>\n            <div ng-messages=\"signForm.userPublicId.$error\">\n                <div ng-message=\"required\">This is required.</div>\n                <div ng-message=\"minlength\">The public id has to be more than 2 characters long.</div>\n                <div ng-message=\"md-maxlength\">The public id has to be less than 20 characters long.</div>\n                <div ng-message=\"pattern\">The public id should only include lowercase letters, numbers and \"-\".</div>\n                <div ng-message=\"spfUniqPublicId\">This public ID is already taken.</div>\n            </div>\n        </md-input-container>\n        <md-input-container flex ng-if=\"ctrl.publicIdIsReadOnly\">\n            <label for=\"sign-public-id\">Your Public Id</label>\n            <input ng-model=\"currentUser.publicId\" disabled=\"disabled\" />\n        </md-input-container>\n        <md-input-container flex>\n            <label for=\"sign-display-name\">Your screen name</label>\n            <input ng-minlength=\"3\" md-maxlength=\"64\" required id=\"sign-display-name\" name=\"userDisplayName\" ng-model=\"currentUser.displayName\">\n            <div ng-messages=\"signForm.userDisplayName.$error\">\n                <div ng-message=\"required\">This is required.</div>\n                <div ng-message=\"minlength\">The screen name has to be more than 2 characters long.</div>\n                <div ng-message=\"md-maxlength\">The screen name has to be less than 64 characters long.</div>\n            </div>\n        </md-input-container>\n    </div>\n\n    <div layout layout-sm=\"column\" ng-if=\"ctrl.publicIdIsReadOnly\">\n        <md-input-container flex layout=\"column\">\n            <md-select flex name=\"userCountry\" ng-model=\"currentUser.country\" required placeholder=\"Where are you from?\">\n                <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.countries track by opt.code\">{{opt.name}}</md-option>\n            </md-select>\n            <div ng-messages=\"signForm.userCountry.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container flex layout=\"column\" ng-if=\"currentUser.country.code == 'SG'\">\n            <md-select flex name=\"userYearOfBirth\" ng-model=\"currentUser.yearOfBirth\" required placeholder=\"When were you born?\">\n                <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.ageGroups\">\n                    <span ng-if=\"opt == 1990\">born before</span>\n                    {{opt}}\n                </md-option>\n            </md-select>\n            <div ng-messages=\"signForm.userYearOfBirth.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n    \t\n        <p ng-if=\"!ctrl.loaded\" flex>Loading schools...</p>\n\n\t\t<md-input-container flex layout=\"column\" ng-if=\"ctrl.loaded &amp;&amp; currentYear - currentUser.yearOfBirth <= 20 &amp;&amp; currentYear - currentUser.yearOfBirth  >= 10\">\n            <md-select flex name=\"userSchool\" ng-model=\"currentUser.school\" required placeholder=\"Select a School\">\n                <md-optgroup label=\"Other\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Other' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Junior College\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Junior College' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Secondary\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Secondary' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Polytechnic\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Polytechnic' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n            </md-select>\n            <div ng-messages=\"signForm.userSchool.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n    </div>\n</ng-form>";SpfSignFormCtrl.$inject=['$scope','SPF_COUNTRIES','spfSchools'];spfSignFormDirectiveFactory.$inject=[];spfUniqPublicIdFactory.$inject=['$q','spfAuthData'];sign=Object.freeze({spfSignFormDirectiveFactory:spfSignFormDirectiveFactory,spfUniqPublicIdFactory:spfUniqPublicIdFactory});components={ace:ace$1,alert:alert,navbar:navbar,sign:sign};list=[{name:'Afghanistan',code:'AF'},{name:'Åland Islands',code:'AX'},{name:'Albania',code:'AL'},{name:'Algeria',code:'DZ'},{name:'American Samoa',code:'AS'},{name:'AndorrA',code:'AD'},{name:'Angola',code:'AO'},{name:'Anguilla',code:'AI'},{name:'Antarctica',code:'AQ'},{name:'Antigua and Barbuda',code:'AG'},{name:'Argentina',code:'AR'},{name:'Armenia',code:'AM'},{name:'Aruba',code:'AW'},{name:'Australia',code:'AU'},{name:'Austria',code:'AT'},{name:'Azerbaijan',code:'AZ'},{name:'Bahamas',code:'BS'},{name:'Bahrain',code:'BH'},{name:'Bangladesh',code:'BD'},{name:'Barbados',code:'BB'},{name:'Belarus',code:'BY'},{name:'Belgium',code:'BE'},{name:'Belize',code:'BZ'},{name:'Benin',code:'BJ'},{name:'Bermuda',code:'BM'},{name:'Bhutan',code:'BT'},{name:'Bolivia',code:'BO'},{name:'Bosnia and Herzegovina',code:'BA'},{name:'Botswana',code:'BW'},{name:'Bouvet Island',code:'BV'},{name:'Brazil',code:'BR'},{name:'British Indian Ocean Territory',code:'IO'},{name:'Brunei Darussalam',code:'BN'},{name:'Bulgaria',code:'BG'},{name:'Burkina Faso',code:'BF'},{name:'Burundi',code:'BI'},{name:'Cambodia',code:'KH'},{name:'Cameroon',code:'CM'},{name:'Canada',code:'CA'},{name:'Cape Verde',code:'CV'},{name:'Cayman Islands',code:'KY'},{name:'Central African Republic',code:'CF'},{name:'Chad',code:'TD'},{name:'Chile',code:'CL'},{name:'China',code:'CN'},{name:'Christmas Island',code:'CX'},{name:'Cocos (Keeling) Islands',code:'CC'},{name:'Colombia',code:'CO'},{name:'Comoros',code:'KM'},{name:'Congo',code:'CG'},{name:'Congo, The Democratic Republic of the',code:'CD'},{name:'Cook Islands',code:'CK'},{name:'Costa Rica',code:'CR'},{name:'Cote D\'Ivoire',code:'CI'},{name:'Croatia',code:'HR'},{name:'Cuba',code:'CU'},{name:'Cyprus',code:'CY'},{name:'Czech Republic',code:'CZ'},{name:'Denmark',code:'DK'},{name:'Djibouti',code:'DJ'},{name:'Dominica',code:'DM'},{name:'Dominican Republic',code:'DO'},{name:'Ecuador',code:'EC'},{name:'Egypt',code:'EG'},{name:'El Salvador',code:'SV'},{name:'Equatorial Guinea',code:'GQ'},{name:'Eritrea',code:'ER'},{name:'Estonia',code:'EE'},{name:'Ethiopia',code:'ET'},{name:'Falkland Islands (Malvinas)',code:'FK'},{name:'Faroe Islands',code:'FO'},{name:'Fiji',code:'FJ'},{name:'Finland',code:'FI'},{name:'France',code:'FR'},{name:'French Guiana',code:'GF'},{name:'French Polynesia',code:'PF'},{name:'French Southern Territories',code:'TF'},{name:'Gabon',code:'GA'},{name:'Gambia',code:'GM'},{name:'Georgia',code:'GE'},{name:'Germany',code:'DE'},{name:'Ghana',code:'GH'},{name:'Gibraltar',code:'GI'},{name:'Greece',code:'GR'},{name:'Greenland',code:'GL'},{name:'Grenada',code:'GD'},{name:'Guadeloupe',code:'GP'},{name:'Guam',code:'GU'},{name:'Guatemala',code:'GT'},{name:'Guernsey',code:'GG'},{name:'Guinea',code:'GN'},{name:'Guinea-Bissau',code:'GW'},{name:'Guyana',code:'GY'},{name:'Haiti',code:'HT'},{name:'Heard Island and Mcdonald Islands',code:'HM'},{name:'Holy See (Vatican City State)',code:'VA'},{name:'Honduras',code:'HN'},{name:'Hong Kong',code:'HK'},{name:'Hungary',code:'HU'},{name:'Iceland',code:'IS'},{name:'India',code:'IN'},{name:'Indonesia',code:'ID'},{name:'Iran, Islamic Republic Of',code:'IR'},{name:'Iraq',code:'IQ'},{name:'Ireland',code:'IE'},{name:'Isle of Man',code:'IM'},{name:'Israel',code:'IL'},{name:'Italy',code:'IT'},{name:'Jamaica',code:'JM'},{name:'Japan',code:'JP'},{name:'Jersey',code:'JE'},{name:'Jordan',code:'JO'},{name:'Kazakhstan',code:'KZ'},{name:'Kenya',code:'KE'},{name:'Kiribati',code:'KI'},{name:'Korea, Democratic People\'S Republic of',code:'KP'},{name:'Korea, Republic of',code:'KR'},{name:'Kuwait',code:'KW'},{name:'Kyrgyzstan',code:'KG'},{name:'Lao People\'S Democratic Republic',code:'LA'},{name:'Latvia',code:'LV'},{name:'Lebanon',code:'LB'},{name:'Lesotho',code:'LS'},{name:'Liberia',code:'LR'},{name:'Libyan Arab Jamahiriya',code:'LY'},{name:'Liechtenstein',code:'LI'},{name:'Lithuania',code:'LT'},{name:'Luxembourg',code:'LU'},{name:'Macao',code:'MO'},{name:'Macedonia, The Former Yugoslav Republic of',code:'MK'},{name:'Madagascar',code:'MG'},{name:'Malawi',code:'MW'},{name:'Malaysia',code:'MY'},{name:'Maldives',code:'MV'},{name:'Mali',code:'ML'},{name:'Malta',code:'MT'},{name:'Marshall Islands',code:'MH'},{name:'Martinique',code:'MQ'},{name:'Mauritania',code:'MR'},{name:'Mauritius',code:'MU'},{name:'Mayotte',code:'YT'},{name:'Mexico',code:'MX'},{name:'Micronesia, Federated States of',code:'FM'},{name:'Moldova, Republic of',code:'MD'},{name:'Monaco',code:'MC'},{name:'Mongolia',code:'MN'},{name:'Montserrat',code:'MS'},{name:'Morocco',code:'MA'},{name:'Mozambique',code:'MZ'},{name:'Myanmar',code:'MM'},{name:'Namibia',code:'NA'},{name:'Nauru',code:'NR'},{name:'Nepal',code:'NP'},{name:'Netherlands',code:'NL'},{name:'Netherlands Antilles',code:'AN'},{name:'New Caledonia',code:'NC'},{name:'New Zealand',code:'NZ'},{name:'Nicaragua',code:'NI'},{name:'Niger',code:'NE'},{name:'Nigeria',code:'NG'},{name:'Niue',code:'NU'},{name:'Norfolk Island',code:'NF'},{name:'Northern Mariana Islands',code:'MP'},{name:'Norway',code:'NO'},{name:'Oman',code:'OM'},{name:'Pakistan',code:'PK'},{name:'Palau',code:'PW'},{name:'Palestinian Territory, Occupied',code:'PS'},{name:'Panama',code:'PA'},{name:'Papua New Guinea',code:'PG'},{name:'Paraguay',code:'PY'},{name:'Peru',code:'PE'},{name:'Philippines',code:'PH'},{name:'Pitcairn',code:'PN'},{name:'Poland',code:'PL'},{name:'Portugal',code:'PT'},{name:'Puerto Rico',code:'PR'},{name:'Qatar',code:'QA'},{name:'Reunion',code:'RE'},{name:'Romania',code:'RO'},{name:'Russian Federation',code:'RU'},{name:'RWANDA',code:'RW'},{name:'Saint Helena',code:'SH'},{name:'Saint Kitts and Nevis',code:'KN'},{name:'Saint Lucia',code:'LC'},{name:'Saint Pierre and Miquelon',code:'PM'},{name:'Saint Vincent and the Grenadines',code:'VC'},{name:'Samoa',code:'WS'},{name:'San Marino',code:'SM'},{name:'Sao Tome and Principe',code:'ST'},{name:'Saudi Arabia',code:'SA'},{name:'Senegal',code:'SN'},{name:'Serbia and Montenegro',code:'CS'},{name:'Seychelles',code:'SC'},{name:'Sierra Leone',code:'SL'},{name:'Singapore',code:'SG'},{name:'Slovakia',code:'SK'},{name:'Slovenia',code:'SI'},{name:'Solomon Islands',code:'SB'},{name:'Somalia',code:'SO'},{name:'South Africa',code:'ZA'},{name:'South Georgia and the South Sandwich Islands',code:'GS'},{name:'Spain',code:'ES'},{name:'Sri Lanka',code:'LK'},{name:'Sudan',code:'SD'},{name:'Suriname',code:'SR'},{name:'Svalbard and Jan Mayen',code:'SJ'},{name:'Swaziland',code:'SZ'},{name:'Sweden',code:'SE'},{name:'Switzerland',code:'CH'},{name:'Syrian Arab Republic',code:'SY'},{name:'Taiwan, Province of China',code:'TW'},{name:'Tajikistan',code:'TJ'},{name:'Tanzania, United Republic of',code:'TZ'},{name:'Thailand',code:'TH'},{name:'Timor-Leste',code:'TL'},{name:'Togo',code:'TG'},{name:'Tokelau',code:'TK'},{name:'Tonga',code:'TO'},{name:'Trinidad and Tobago',code:'TT'},{name:'Tunisia',code:'TN'},{name:'Turkey',code:'TR'},{name:'Turkmenistan',code:'TM'},{name:'Turks and Caicos Islands',code:'TC'},{name:'Tuvalu',code:'TV'},{name:'Uganda',code:'UG'},{name:'Ukraine',code:'UA'},{name:'United Arab Emirates',code:'AE'},{name:'United Kingdom',code:'GB'},{name:'United States',code:'US'},{name:'United States Minor Outlying Islands',code:'UM'},{name:'Uruguay',code:'UY'},{name:'Uzbekistan',code:'UZ'},{name:'Vanuatu',code:'VU'},{name:'Venezuela',code:'VE'},{name:'Viet Nam',code:'VN'},{name:'Virgin Islands, British',code:'VG'},{name:'Virgin Islands, U.S.',code:'VI'},{name:'Wallis and Futuna',code:'WF'},{name:'Western Sahara',code:'EH'},{name:'Yemen',code:'YE'},{name:'Zambia',code:'ZM'},{name:'Zimbabwe',code:'ZW'}];setTmpl="<svg display=\"none\" width=\"0\" height=\"0\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs>\n        <g id=\"bookmark-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M725.333 128h-426.667c-47.147 0-84.907 38.187-84.907 85.333l-0.427 682.667 298.667-128 298.667 128v-682.667c0-47.147-38.187-85.333-85.333-85.333zM725.333 768l-213.333-92.8-213.333 92.8v-554.667h426.667v554.667z\"></path>\n        </g>\n        <g id=\"delete\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M256 810.667c0 47.147 38.187 85.333 85.333 85.333h341.333c47.147 0 85.333-38.187 85.333-85.333v-512h-512v512zM810.667 170.667h-149.333l-42.667-42.667h-213.333l-42.667 42.667h-149.333v85.333h597.333v-85.333z\"></path>\n        </g>\n        <g id=\"exit-to-app\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M430.293 664.96l60.373 60.373 213.333-213.333-213.333-213.333-60.373 60.373 110.293 110.293h-412.587v85.333h412.587l-110.293 110.293zM810.667 128h-597.333c-47.147 0-85.333 38.187-85.333 85.333v170.667h85.333v-170.667h597.333v597.333h-597.333v-170.667h-85.333v170.667c0 47.147 38.187 85.333 85.333 85.333h597.333c47.147 0 85.333-38.187 85.333-85.333v-597.333c0-47.147-38.187-85.333-85.333-85.333z\"></path>\n        </g>\n        <g id=\"highlight-remove\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M622.293 341.333l-110.293 110.293-110.293-110.293-60.373 60.373 110.293 110.293-110.293 110.293 60.373 60.373 110.293-110.293 110.293 110.293 60.373-60.373-110.293-110.293 110.293-110.293-60.373-60.373zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333z\"></path>\n        </g>\n        <g id=\"home\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M426.667 853.333v-256h170.667v256h213.333v-341.333h128l-426.667-384-426.667 384h128v341.333z\"></path>\n        </g>\n        <g id=\"info-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M469.333 725.333h85.333v-256h-85.333v256zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333zM469.333 384h85.333v-85.333h-85.333v85.333z\"></path>\n        </g>\n        <g id=\"launch\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M810.667 810.667h-597.333v-597.333h298.667v-85.333h-298.667c-47.147 0-85.333 38.187-85.333 85.333v597.333c0 47.147 38.187 85.333 85.333 85.333h597.333c47.147 0 85.333-38.187 85.333-85.333v-298.667h-85.333v298.667zM597.333 128v85.333h152.96l-419.413 419.413 60.373 60.373 419.413-419.413v152.96h85.333v-298.667h-298.667z\"></path>\n        </g>\n        <g id=\"reorder\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M128 640h768v-85.333h-768v85.333zM128 810.667h768v-85.333h-768v85.333zM128 469.333h768v-85.333h-768v85.333zM128 213.333v85.333h768v-85.333h-768z\"></path>\n        </g>\n        <g id=\"settings\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M829.013 553.6c1.707-13.653 2.987-27.52 2.987-41.6s-1.28-27.947-2.987-41.6l90.24-70.613c8.107-6.4 10.453-17.92 5.12-27.307l-85.333-147.84c-5.333-9.173-16.427-13.013-26.027-9.173l-106.24 42.88c-21.973-16.853-46.080-31.147-72.107-42.027l-16-113.067c-1.92-10.027-10.667-17.92-21.333-17.92h-170.667c-10.667 0-19.413 7.893-21.12 17.92l-16 113.067c-26.027 10.88-50.133 24.96-72.107 42.027l-106.24-42.88c-9.6-3.627-20.693 0-26.027 9.173l-85.333 147.84c-5.333 9.173-2.987 20.693 5.12 27.307l90.027 70.613c-1.707 13.653-2.987 27.52-2.987 41.6s1.28 27.947 2.987 41.6l-90.027 70.613c-8.107 6.4-10.453 17.92-5.12 27.307l85.333 147.84c5.333 9.173 16.427 13.013 26.027 9.173l106.24-42.88c21.973 16.853 46.080 31.147 72.107 42.027l16 113.067c1.707 10.027 10.453 17.92 21.12 17.92h170.667c10.667 0 19.413-7.893 21.12-17.92l16-113.067c26.027-10.88 50.133-24.96 72.107-42.027l106.24 42.88c9.6 3.627 20.693 0 26.027-9.173l85.333-147.84c5.333-9.173 2.987-20.693-5.12-27.307l-90.027-70.613zM512 661.333c-82.56 0-149.333-66.773-149.333-149.333s66.773-149.333 149.333-149.333 149.333 66.773 149.333 149.333-66.773 149.333-149.333 149.333z\"></path>\n        </g>\n        <g id=\"not-interested\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.587 0-341.333-152.747-341.333-341.333 0-78.933 27.093-151.253 71.893-209.067l478.507 478.507c-57.813 44.8-130.133 71.893-209.067 71.893zM781.44 721.067l-478.507-478.507c57.813-44.8 130.133-71.893 209.067-71.893 188.587 0 341.333 152.747 341.333 341.333 0 78.933-27.093 151.253-71.893 209.067z\"></path>\n        </g>\n        <g id=\"play-arrow\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M341.333 213.333v597.333l469.333-298.667z\"></path>\n        </g>\n        <g id=\"add-circle-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M554.667 298.667h-85.333v170.667h-170.667v85.333h170.667v170.667h85.333v-170.667h170.667v-85.333h-170.667v-170.667zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333z\"></path>\n        </g>\n        <g id=\"create\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M128 736v160h160l472.107-472.107-160-160-472.107 472.107zM883.413 300.587c16.64-16.64 16.64-43.733 0-60.373l-99.627-99.627c-16.64-16.64-43.733-16.64-60.373 0l-78.080 78.080 160 160 78.080-78.080z\"></path>\n        </g>\n        <g id=\"keyboard-arrow-right\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M366.293 702.293l195.627-195.627-195.627-195.627 60.373-60.373 256 256-256 256z\"></path>\n        </g>\n        <g id=\"keyboard-arrow-left\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M657.707 696.96l-195.627-195.627 195.627-195.627-60.373-60.373-256 256 256 256z\"></path>\n        </g>\n        <g id=\"person\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 512c94.293 0 170.667-76.587 170.667-170.667 0-94.293-76.373-170.667-170.667-170.667s-170.667 76.373-170.667 170.667c0 94.080 76.373 170.667 170.667 170.667zM512 597.333c-113.707 0-341.333 56.96-341.333 170.667v85.333h682.667v-85.333c0-113.707-227.627-170.667-341.333-170.667z\"></path>\n        </g>\n        <g id=\"loop\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 170.667v-128l-170.667 170.667 170.667 170.667v-128c141.44 0 256 114.56 256 256 0 43.307-10.88 83.84-29.653 119.68l62.293 62.293c33.067-52.907 52.693-114.987 52.693-181.973 0-188.587-152.747-341.333-341.333-341.333zM512 768c-141.44 0-256-114.56-256-256 0-43.307 10.88-83.84 29.653-119.68l-62.293-62.293c-33.067 52.907-52.693 114.987-52.693 181.973 0 188.587 152.747 341.333 341.333 341.333v128l170.667-170.667-170.667-170.667v128z\"></path>\n        </g>\n        <g id=\"done\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M384 689.92l-177.92-177.92-60.373 60.373 238.293 238.293 512-512-60.373-60.373z\"></path>\n        </g>\n        <g id=\"chevron-left\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M657.707 316.373l-60.373-60.373-256 256 256 256 60.373-60.373-195.627-195.627z\"></path>\n        </g>\n        <g id=\"chevron-right\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M323.525 752.112l253.021-253.021-253.021-253.021 77.455-77.455 330.475 330.475-330.475 330.475z\"></path>\n        </g>\n        <g id=\"check\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M384 690l452-452 60 60-512 512-238-238 60-60z\"></path>\n        </g>\n        <g id=\"clear\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M810 274l-238 238 238 238-60 60-238-238-238 238-60-60 238-238-238-238 60-60 238 238 238-238z\"></path>\n        </g>\n        <g id=\"add\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M899.725 566.645h-333.077v333.077h-109.292v-333.077h-333.077v-109.292h333.077v-333.077h109.292v333.077h333.077v109.292z\"></path>\n        </g>\n        <g id=\"more-horiz\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M256 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333zM768 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333zM512 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333z\"></path>\n        </g>\n        <g id=\"arrow-back\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M853.333 469.333h-519.253l238.293-238.293-60.373-60.373-341.333 341.333 341.333 341.333 60.373-60.373-238.293-238.293h519.253v-85.333z\"></path>\n        </g>\n        <g id=\"arrow-forward\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 170.667l-60.373 60.373 238.293 238.293h-519.253v85.333h519.253l-238.293 238.293 60.373 60.373 341.333-341.333z\"></path>\n        </g>\n    </defs>\n</svg>\n";pythonTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n    <linearGradient id=\"a\" gradientUnits=\"userSpaceOnUse\" x1=\"70.252\" y1=\"1237.476\" x2=\"170.659\" y2=\"1151.089\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\">\n        <stop offset=\"0\" stop-color=\"#5A9FD4\"/>\n        <stop offset=\"1\" stop-color=\"#306998\"/>\n    </linearGradient>\n    <path fill=\"url(#a)\" d=\"M63.391 1.988c-4.222.02-8.252.379-11.8 1.007-10.45 1.846-12.346 5.71-12.346 12.837v9.411h24.693v3.137h-33.961c-7.176 0-13.46 4.313-15.426 12.521-2.268 9.405-2.368 15.275 0 25.096 1.755 7.311 5.947 12.519 13.124 12.519h8.491v-11.282c0-8.151 7.051-15.34 15.426-15.34h24.665c6.866 0 12.346-5.654 12.346-12.548v-23.513c0-6.693-5.646-11.72-12.346-12.837-4.244-.706-8.645-1.027-12.866-1.008zm-13.354 7.569c2.55 0 4.634 2.117 4.634 4.721 0 2.593-2.083 4.69-4.634 4.69-2.56 0-4.633-2.097-4.633-4.69-.001-2.604 2.073-4.721 4.633-4.721z\"/>\n    <linearGradient id=\"b\" gradientUnits=\"userSpaceOnUse\" x1=\"209.474\" y1=\"1098.811\" x2=\"173.62\" y2=\"1149.537\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\">\n        <stop offset=\"0\" stop-color=\"#FFD43B\"/>\n        <stop offset=\"1\" stop-color=\"#FFE873\"/>\n    </linearGradient>\n    <path fill=\"url(#b)\" d=\"M91.682 28.38v10.966c0 8.5-7.208 15.655-15.426 15.655h-24.665c-6.756 0-12.346 5.783-12.346 12.549v23.515c0 6.691 5.818 10.628 12.346 12.547 7.816 2.297 15.312 2.713 24.665 0 6.216-1.801 12.346-5.423 12.346-12.547v-9.412h-24.664v-3.138h37.012c7.176 0 9.852-5.005 12.348-12.519 2.578-7.735 2.467-15.174 0-25.096-1.774-7.145-5.161-12.521-12.348-12.521h-9.268zm-13.873 59.547c2.561 0 4.634 2.097 4.634 4.692 0 2.602-2.074 4.719-4.634 4.719-2.55 0-4.633-2.117-4.633-4.719 0-2.595 2.083-4.692 4.633-4.692z\"/>\n    <radialGradient id=\"c\" cx=\"1825.678\" cy=\"444.45\" r=\"26.743\" gradientTransform=\"matrix(0 -.24 -1.055 0 532.979 557.576)\" gradientUnits=\"userSpaceOnUse\">\n        <stop offset=\"0\" stop-color=\"#B8B8B8\" stop-opacity=\".498\"/>\n        <stop offset=\"1\" stop-color=\"#7F7F7F\" stop-opacity=\"0\"/>\n    </radialGradient>\n    <path opacity=\".444\" fill=\"url(#c)\" enable-background=\"new\" d=\"M97.309 119.597c0 3.543-14.816 6.416-33.091 6.416-18.276 0-33.092-2.873-33.092-6.416 0-3.544 14.815-6.417 33.092-6.417 18.275 0 33.091 2.872 33.091 6.417z\"/>\n</svg>";angularjsTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n  <path fill=\"#B3B3B3\" d=\"M63.81 1.026l-59.257 20.854 9.363 77.637 49.957 27.457 50.214-27.828 9.36-77.635z\"/>\n  <path fill=\"#A6120D\" d=\"M117.536 25.998l-53.864-18.369v112.785l45.141-24.983z\"/>\n  <path fill=\"#DD1B16\" d=\"M11.201 26.329l8.026 69.434 44.444 24.651v-112.787z\"/>\n  <path fill=\"#F2F2F2\" d=\"M78.499 67.67l-14.827 6.934h-15.628l-7.347 18.374-13.663.254 36.638-81.508 14.827 55.946zm-1.434-3.491l-13.295-26.321-10.906 25.868h10.807l13.394.453z\"/>\n  <path fill=\"#B3B3B3\" d=\"M63.671 11.724l.098 26.134 12.375 25.888h-12.446l-.027 10.841 17.209.017 8.042 18.63 13.074.242z\"/>\n</svg>";javascriptTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n\t<path fill=\"#F0DB4F\" d=\"M1.408 1.408h125.184v125.185h-125.184z\"/>\n\t<path fill=\"#323330\" d=\"M116.347 96.736c-.917-5.711-4.641-10.508-15.672-14.981-3.832-1.761-8.104-3.022-9.377-5.926-.452-1.69-.512-2.642-.226-3.665.821-3.32 4.784-4.355 7.925-3.403 2.023.678 3.938 2.237 5.093 4.724 5.402-3.498 5.391-3.475 9.163-5.879-1.381-2.141-2.118-3.129-3.022-4.045-3.249-3.629-7.676-5.498-14.756-5.355l-3.688.477c-3.534.893-6.902 2.748-8.877 5.235-5.926 6.724-4.236 18.492 2.975 23.335 7.104 5.332 17.54 6.545 18.873 11.531 1.297 6.104-4.486 8.08-10.234 7.378-4.236-.881-6.592-3.034-9.139-6.949-4.688 2.713-4.688 2.713-9.508 5.485 1.143 2.499 2.344 3.63 4.26 5.795 9.068 9.198 31.76 8.746 35.83-5.176.165-.478 1.261-3.666.38-8.581zm-46.885-37.793h-11.709l-.048 30.272c0 6.438.333 12.34-.714 14.149-1.713 3.558-6.152 3.117-8.175 2.427-2.059-1.012-3.106-2.451-4.319-4.485-.333-.584-.583-1.036-.667-1.071l-9.52 5.83c1.583 3.249 3.915 6.069 6.902 7.901 4.462 2.678 10.459 3.499 16.731 2.059 4.082-1.189 7.604-3.652 9.448-7.401 2.666-4.915 2.094-10.864 2.07-17.444.06-10.735.001-21.468.001-32.237z\"/>\n</svg>";javaTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n  <path fill=\"#0074BD\" d=\"M47.617 98.12s-4.767 2.774 3.397 3.71c9.892 1.13 14.947.968 25.845-1.092 0 0 2.871 1.795 6.873 3.351-24.439 10.47-55.308-.607-36.115-5.969zM44.629 84.455s-5.348 3.959 2.823 4.805c10.567 1.091 18.91 1.18 33.354-1.6 0 0 1.993 2.025 5.132 3.131-29.542 8.64-62.446.68-41.309-6.336z\"/>\n  <path fill=\"#EA2D2E\" d=\"M69.802 61.271c6.025 6.935-1.58 13.17-1.58 13.17s15.289-7.891 8.269-17.777c-6.559-9.215-11.587-13.792 15.635-29.58 0 .001-42.731 10.67-22.324 34.187z\"/>\n  <path fill=\"#0074BD\" d=\"M102.123 108.229s3.529 2.91-3.888 5.159c-14.102 4.272-58.706 5.56-71.094.171-4.451-1.938 3.899-4.625 6.526-5.192 2.739-.593 4.303-.485 4.303-.485-4.953-3.487-32.013 6.85-13.743 9.815 49.821 8.076 90.817-3.637 77.896-9.468zM49.912 70.294s-22.686 5.389-8.033 7.348c6.188.828 18.518.638 30.011-.326 9.39-.789 18.813-2.474 18.813-2.474s-3.308 1.419-5.704 3.053c-23.042 6.061-67.544 3.238-54.731-2.958 10.832-5.239 19.644-4.643 19.644-4.643zM90.609 93.041c23.421-12.167 12.591-23.86 5.032-22.285-1.848.385-2.677.72-2.677.72s.688-1.079 2-1.543c14.953-5.255 26.451 15.503-4.823 23.725 0-.002.359-.327.468-.617z\"/>\n  <path fill=\"#EA2D2E\" d=\"M76.491 1.587s12.968 12.976-12.303 32.923c-20.266 16.006-4.621 25.13-.007 35.559-11.831-10.673-20.509-20.07-14.688-28.815 8.548-12.834 32.229-19.059 26.998-39.667z\"/>\n  <path fill=\"#0074BD\" d=\"M52.214 126.021c22.476 1.437 57-.8 57.817-11.436 0 0-1.571 4.032-18.577 7.231-19.186 3.612-42.854 3.191-56.887.874 0 .001 2.875 2.381 17.647 3.331z\"/>\n</svg>";iconSet={url:'icons/svgdefs.svg',tmpl:setTmpl,vb:1024};langIcons=[{title:'language:python',url:'icons/icons-python.svg',tmpl:pythonTmpl,vb:128},{title:'language:angularjs',url:'icons/icons-angularjs.svg',tmpl:angularjsTmpl,vb:128},{title:'language:javascript',url:'icons/icons-javascript.svg',tmpl:javascriptTmpl,vb:128},{title:'language:java',url:'icons/icons-java.svg',tmpl:javaTmpl,vb:128}];config.$inject=['$mdIconProvider'];run.$inject=['$templateCache'];icons=Object.freeze({config:config,run:run});_classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();hex=CryptoJS.enc.Hex;random=CryptoJS.lib.WordArray.random;pbkdf2=CryptoJS.PBKDF2;saltSize=16;keySize=8;iterations=1012;prf='SHA256';PasswordService=function(){function PasswordService(settings){_classCallCheck(this,PasswordService);this.settings=settings;}/**
   * Return a hash for the password and options allowing
   * to rebuild the same against the same password.
   *
   * The options will include the hashing algorithm name, the
   * salt an other parameters.
   *
   * @param  {string} password password to hash
   * @return {{value: string, options: {salt: string, iterations: number, keySize: number, hasher: string}}}
   */_createClass(PasswordService,[{key:'newHash',value:function newHash(password){var salt=random(this.settings.saltSize);var hash=pbkdf2(password,salt,{keySize:this.settings.keySize,iterations:this.settings.iterations,hasher:CryptoJS.algo[prf]});return{value:hex.stringify(hash),options:{salt:hex.stringify(salt),iterations:this.settings.iterations,keySize:this.settings.keySize,hasher:'PBKDF2',prf:prf}};}/**
  * Return a hash built from the password, the hash and the
  * hashing options.
  *
  * The salt should be hex encoded.
  *
   * @param  {string} password password to hash.
   * @param  {string} hexSalt  hash salt.
   * @param  {object} options  hash options
   * @return {string}
   */},{key:'fromSalt',value:function fromSalt(password,hexSalt,options){var salt=hex.parse(hexSalt);var hash=pbkdf2(password,salt,{keySize:options.keySize||this.settings.keySize,iterations:options.iterations||this.settings.iterations,hasher:CryptoJS.algo[options.prf||prf]});return hex.stringify(hash);}}]);return PasswordService;}();Service=function(){function Service(spfCryptoSaltSize,spfCryptoHashKeySize,spfCryptoIteration){_classCallCheck(this,Service);this.password=new PasswordService({saltSize:spfCryptoSaltSize,iterations:spfCryptoIteration,keySize:spfCryptoHashKeySize});}/**
   * Return a CryptoJS MD5 Hash.
   *
   * Usage:
   *
   *  const spfCrypto = new Service();
   *  const hash = spfCrypto.md5();
   *  const hex = hash.toString();
   *
   * @param  {string} message message to hash.
   * @return {object}
   */_createClass(Service,[{key:'md5',value:function md5(message){return new CryptoJS.MD5(message);}},{key:'randomString',value:function randomString(size){var str=random(size);return hex.stringify(str);}}]);return Service;}();Service.$inject=['spfCryptoSaltSize','spfCryptoHashKeySize','spfCryptoIteration'];crypto=Object.freeze({saltSize:saltSize,keySize:keySize,iterations:iterations,prf:prf,Service:Service});defaults={home:'/'};urlForFactory.$inject=['routes'];urlForFilterFactory.$inject=['urlFor'];run$1.$inject=['$rootScope','$location','routes','spfAlert'];routeServices=Object.freeze({defaults:defaults,urlForFactory:urlForFactory,urlForFilterFactory:urlForFilterFactory,run:run$1});_defineProperty=function(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};gravatarBaseUrl='//www.gravatar.com/avatar/';eventName='spfCurrentUser.authChanged';SpfCurrentUserService=function(){function SpfCurrentUserService($q,$timeout,$log,$rootScope,spfCrypto,firebaseApp,authFirebaseApp,spfAuth,spfProfilesPath){var _this=this;_classCallCheck(this,SpfCurrentUserService);this.$q=$q;this.$timeout=$timeout;this.$log=$log;this.$rootScope=$rootScope;this.$db=firebaseApp.database();this.$authDb=authFirebaseApp.database();this.$spfAuth=spfAuth;this.$spfCrypto=spfCrypto;this.$spfProfilesPath=spfProfilesPath;this.$watchers={};this.firebaseUser=undefined;this.uid=undefined;this.user=undefined;this.publicId=undefined;this.profile=undefined;this.isAdmin=false;this.isPremium=false;this.$watchers.firebaseUser=spfAuth.onAuth(function(firebaseUser){return _this.authChangedHandler(firebaseUser);});}/**
   * Return a promise resolving once the profile/auth data currently loading
   * finishes.
   *
   * Reject if the it times out (2000ms timeout delay by default).
   *
   * @param  {number} delay timeout delay
   * @return {Promise<void, Error>}
   */_createClass(SpfCurrentUserService,[{key:'$loaded',value:function $loaded(delay){var _this2=this;var defaultTimeout=2000;delay=isNaN(delay)?defaultTimeout:delay;return this.$q(function(resolve,reject){var loaded=function loaded(){return _this2.user!==undefined&&_this2.profile!==undefined;};if(loaded()){resolve();return;}var timer=void 0;var stop=_this2.$rootScope.$on(eventName,function(){if(!loaded()){return;}stop();resolve();_this2.$timeout.cancel(timer);});timer=_this2.$timeout(function(){stop();reject(new Error('timeout'));},delay);});}/**
   * Stop watching user's data and profile and reset them.
   *
   * It should notify (event and digest trigger) the changed state.
   *
   * @param {any} value to set the value to null (loaded) instead indefined.
   */},{key:'resetUser',value:function resetUser(value){this.publicId=value!==undefined?null:undefined;this.user=value!==undefined?null:undefined;this.doResetProfile(value);if(this.$watchers.user){this.$watchers.user();this.$watchers.user=undefined;}this.$rootScope.$emit(eventName,{user:true,profile:true});this.$rootScope.$applyAsync();}/**
   * Stop watching user's profile and reset it.
   *
   * It should notify (event and digest trigger) the changed state.
   *
   * @param {any} value to set the value to null (loaded) instead indefined.
   */},{key:'resetProfile',value:function resetProfile(value){this.doResetProfile(value);this.$rootScope.$emit(eventName,{profile:true});this.$rootScope.$applyAsync();}},{key:'doResetProfile',value:function doResetProfile(value){this.profile=value!==undefined?null:undefined;this.isAdmin=false;this.isPremium=false;if(this.$watchers.profile){this.$watchers.profile();this.$watchers.profile=undefined;}}},{key:'userRef',value:function userRef(uid){if(!uid){throw new Error('The user uid provided.');}return this.$authDb.ref('auth/users/'+uid);}},{key:'profileRef',value:function profileRef(publicId){if(!publicId){throw new Error('The user publicId provided.');}return this.$db.ref(this.$spfProfilesPath+'/'+publicId);}},{key:'profileDetailsRef',value:function profileDetailsRef(publicId){return this.profileRef(publicId).child('user');}/**
   * Set or update the saved user data at "auth/users/$userId".
   *
   * @return {Promise<void, Error>}
   */},{key:'patchUser',value:function patchUser(){var _this3=this;var ref=this.userRef(this.firebaseUser.uid);return ref.once('value').then(function(){return ref.transaction(function(value){return _this3.updateUser(value);});});}},{key:'updateUser',value:function updateUser(user){var info=this.info();if(!info){return undefined;}if(!user){return{id:this.firebaseUser.uid,fullName:info.name,displayName:info.name,email:info.email,gravatar:this.gravatar(info.email),createdAt:{'.sv':'timestamp'}};}var updated=false;if(info.name!==user.fullName){user.fullName=info.name;updated=true;}if(info.email!==user.email){user.email=info.email;user.gravatar=this.gravatar(info.email);updated=true;}return updated?user:undefined;}/**
   * Set or update the Profile data at "path/to/profile/$publicId/user".
   *
   * The path to app profile location is set via the "spfProfilesPath" angular
   * module constant.
   *
   * @return {Promise<void, Error>}
   */},{key:'patchProfile',value:function patchProfile(){var _this4=this;var ref=this.profileDetailsRef(this.user.publicId);return ref.once('value').then(function(){return ref.transaction(function(value){return _this4.updateProfile(value);});});}},{key:'updateProfile',value:function updateProfile(profile){if(!this.user||!this.user.displayName||!this.user.gravatar){return undefined;}var newProfile={displayName:this.user.displayName,gravatar:this.user.gravatar,yearOfBirth:this.user.yearOfBirth||null,school:this.user.school||null,country:this.user.country||null};if(!profile){return newProfile;}var updatedProfile=Object.assign({},profile,newProfile);var updated=Object.keys(updatedProfile).some(function(key){var value=updatedProfile[key];var old=profile[key]||null;var isObject=value instanceof Object;if(!isObject){return value!==old;}if(Boolean(value)!==Boolean(old)){return true;}var propsChanged=Object.keys(value).some(function(p){return value[p]!==old[p];});if(propsChanged){return true;}var propsDeleted=Object.keys(old).some(function(p){return!value[p];});return propsDeleted;});return updated?Object.assign(profile,updatedProfile):undefined;}/**
   * Handle changes to the current user auth status.
   *
   * It should update the firebaseUser and uid properties and notify (event and
   * digest trigger) the changed state.
   *
   * The changes should cascade to the auth and profile data, and the related
   * properties related.
   *
   * @param  {?{uid: string, provider: string, google: object}} firebaseUser firebase auth data
   */},{key:'authChangedHandler',value:function authChangedHandler(firebaseUser){var isLogged=firebaseUser&&firebaseUser.uid;var wasAlreadyLogged=isLogged&&this.firebaseUser&&this.firebaseUser.uid&&this.firebaseUser.uid;this.uid=firebaseUser&&firebaseUser.uid||null;this.firebaseUser=firebaseUser||null;if(!isLogged){this.resetUser(null);this.$rootScope.$emit(eventName,{firebaseUser:true});return;}this.patchUser();if(!wasAlreadyLogged){this.watchUser();}this.$rootScope.$emit(eventName,{firebaseUser:true});this.$rootScope.$applyAsync();}/**
   * Handle changes to the current user saved auth data.
   *
   * It should update the user and public properties and notify (event and
   * digest trigger) the changed state.
   *
   * The changes should cascade to the save profile data and to profile related
   * properties
   *
   * @param {?{publicId: string, displayName: string, gravatar: string}} user saved firebase auth data
   */},{key:'userChangedHandler',value:function userChangedHandler(user){var dataSaved=user!==null;var newPublicId=user&&user.publicId&&(!this.user||!this.user.publicId);this.publicId=user&&user.publicId||null;this.user=user;if(!dataSaved||!user.publicId){this.resetProfile(null);this.$rootScope.$emit(eventName,{user:true});return;}this.patchProfile();if(!this.$watchers.profile||newPublicId){this.watchProfile();}this.$rootScope.$emit(eventName,{user:true});this.$rootScope.$applyAsync();}/**
   * Handle changes to the current user saved auth data.
   *
   * update the profile. isAdmin and isPremium properties, and notify (event and
   * digest trigger) the changed state.
   *
   * @param  {?{isAdmin: boolean, isPremium: boolean}} profile profile data
   */},{key:'profileChangedHandler',value:function profileChangedHandler(profile){this.isAdmin=profile&&profile.isAdmin||false;this.isPremium=profile&&profile.isPremium||false;this.profile=profile;this.$rootScope.$emit(eventName,{profile:true});this.$rootScope.$applyAsync();}},{key:'watchUser',value:function watchUser(){var _this5=this;if(!this.firebaseUser||!this.firebaseUser.uid){this.resetUser(null);return;}var ref=this.userRef(this.firebaseUser.uid);var handler=function handler(snapshot){return _this5.userChangedHandler(snapshot.val());};var onError=function onError(err){_this5.$log.error(err);_this5.resetUser(null);};this.resetUser();this.$watchers.user=function(){return ref.off('value',handler);};ref.on('value',handler,onError);}},{key:'watchProfile',value:function watchProfile(){var _this6=this;if(!this.user||!this.user.publicId){this.resetProfile(null);return;}var ref=this.profileDetailsRef(this.user.publicId);var handler=function handler(snapshot){return _this6.profileChangedHandler(snapshot.val());};var onError=function onError(err){_this6.$log.error(err);_this6.resetProfile(null);};this.resetProfile();this.$watchers.profile=function(){return ref.off('value',handler);};ref.on('value',handler,onError);}/**
   * Extract the current user name and email from the auth data.
   *
   * Only support google and custom provided data.
   *
   * @return {?{name: string, email: string}}
   */},{key:'info',value:function info(){if(!this.firebaseUser||!this.firebaseUser.provider){return null;}if(this.firebaseUser.provider==='google'){return{email:this.firebaseUser.google.email,name:this.firebaseUser.google.displayName};}if(this.firebaseUser.provider==='custom'){return{email:'custom@example.com',name:'Custom User'};}throw new Error('Wrong provider: '+this.firebaseUser.provider);}/**
   * Return the gravatar url for an email.
   *
   * @param  {string} email email to calculate gravatar url for.
   * @return {string}
   */},{key:'gravatar',value:function gravatar(email){return gravatarBaseUrl+this.$spfCrypto.md5(email);}/**
   * Register a handler for any changes to the current user authentication state
   *
   * @param  {function} handler function run for any changed state.
   * @return {function}         function to register the hanlder.
   */},{key:'$watch',value:function $watch(handler){return this.$rootScope.$on(eventName,handler);}/**
   * Log user in.
   *
   * @return {Promise<void, Error>}
   */},{key:'login',value:function login(){return this.$spfAuth.login();}/**
   * Log user out.
   *
   * @return {void}
   */},{key:'logout',value:function logout(){return this.$spfAuth.logout();}/**
   * Register user's public id and display name (optional).
   *
   * @param  {{publicId: string, displayName: string}} options user chosen public id and display name.
   * @return {Promise<void, Error>}
   */},{key:'register',value:function register(options){var _this7=this;return new Promise(function(resolve,reject){var _patch;if(!_this7.uid){reject(new Error('You are not logged and cannot register.'));}if(_this7.publicId){reject(new Error('you are already registered as "'+_this7.publicId+'"'));}var publicId=options&&options.publicId;var displayName=options&&options.displayName;if(!publicId){reject(new Error('The public id was not provided.'));}var patch=(_patch={},_defineProperty(_patch,'publicIds/'+publicId,_this7.uid),_defineProperty(_patch,'usedPublicIds/'+publicId,true),_defineProperty(_patch,'users/'+_this7.uid+'/publicId',publicId),_patch);if(displayName){patch['users/'+_this7.uid+'/displayName']=displayName;}resolve(patch);}).then(function(patch){var ref=_this7.$authDb.ref('auth');return ref.update(patch);});}}]);return SpfCurrentUserService;}();SpfCurrentUserService.$inject=['$q','$timeout','$log','$rootScope','spfCrypto','firebaseApp','authFirebaseApp','spfAuth','spfProfilesPath'];spfAuthFactory.$inject=['$q','$route','$log','$firebaseAuth','authFirebaseApp','authProvider'];spfAuthDataFactory.$inject=['$q','$log','$firebaseObject','authFirebaseApp','spfAuth','spfCrypto'];spfSchoolsFactory.$inject=['$firebaseObject','firebaseApp'];run$2.$inject=['$log','spfProfilesPath'];datastore=Object.freeze({gravatarBaseUrl:gravatarBaseUrl,eventName:eventName,SpfCurrentUserService:SpfCurrentUserService,spfAuthFactory:spfAuthFactory,spfAuthDataFactory:spfAuthDataFactory,spfSchoolsFactory:spfSchoolsFactory,run:run$2});run$3.$inject=['$log','firebaseApp','authFirebaseApp','authProvider'];invalidChar=['.','#','$','/','[',']'];services={countries:list,icons:icons,crypto:crypto,routes:routeServices,datastore:datastore,firebase:{run:run$3}};spfEmptyFilterFactory.$inject=[];spfLengthFilterFactory.$inject=[];spfToArrayFilterFactory.$inject=[];loadingBar.$inject=['cfpLoadingBarProvider'];mdTheme.$inject=['$mdThemingProvider'];spfShared=angular$1.module('spf.shared',['angular-loading-bar','firebase','ngAnimate','ngMessages','ngRoute','ngMaterial']);//
// Register directives, services and filters.
//
// spfShared.factory('spfFirebase', services.firebase.spfFirebaseFactory);
// spfShared.provider('spfFirebaseRef', services.firebase.SpfFirebaseRefProvider);
spfShared.config(loadingBar);spfShared.config(mdTheme);spfShared.config(services.icons.config);spfShared.constant('authFirebaseApp',null);spfShared.constant('authProvider',null);spfShared.constant('firebaseApp',null);spfShared.constant('routes',services.routes.defaults);spfShared.constant('SPF_COUNTRIES',services.countries);spfShared.constant('spfCryptoHashKeySize',services.crypto.keySize);spfShared.constant('spfCryptoIteration',services.crypto.iterations);spfShared.constant('spfCryptoSaltSize',services.crypto.saltSize);spfShared.constant('spfProfilesPath',null);spfShared.controller('SpfSharedNavBarCtrl',components.navbar.SpfSharedNavBarCtrl);spfShared.directive('spfEditor',components.ace.spfEditorDirectiveFactory);spfShared.directive('spfSignForm',components.sign.spfSignFormDirectiveFactory);spfShared.directive('spfUniqPublicId',components.sign.spfUniqPublicIdFactory);spfShared.factory('spfAlert',components.alert.spfAlertFactory);spfShared.factory('spfAuth',services.datastore.spfAuthFactory);spfShared.factory('spfAuthData',services.datastore.spfAuthDataFactory);spfShared.factory('spfNavBarService',components.navbar.spfNavBarServiceFactory);spfShared.factory('spfSchools',services.datastore.spfSchoolsFactory);spfShared.factory('urlFor',services.routes.urlForFactory);spfShared.filter('spfEmpty',spfEmptyFilterFactory);spfShared.filter('spfLength',spfLengthFilterFactory);spfShared.filter('spfToArray',spfToArrayFilterFactory);spfShared.filter('urlFor',services.routes.urlForFilterFactory);spfShared.run(components.navbar.initNavBar);spfShared.run(services.datastore.run);spfShared.run(services.firebase.run);spfShared.run(services.icons.run);spfShared.run(services.routes.run);spfShared.service('spfCrypto',services.crypto.Service);spfShared.service('spfCurrentUser',services.datastore.SpfCurrentUserService);clmServicesFactory.$inject=['$firebaseObject','$log','$q','$timeout','firebaseApp'];clmDataStoreFactory.$inject=['$window','$location','$q','$log','$http','$timeout','firebaseApp','$firebaseObject','$firebaseArray','spfSchools','routes','spfAuth','spfAuthData','spfCrypto','clmServices','clmServicesUrl'];cmTruncateFilterFactory.$inject=[];cmTruncateFilterBooleanFactory.$inject=[];showSchoolFilterFactory.$inject=[];cmContainsFactory.$inject=[];template="<md-content flex>\n\t<md-content class=\"md-padding\">\n\t\t<p>The IDA <a href=\"https://www.ida.gov.sg/Sub/Talent/Student-Programmes/National-Infocomm-Competition\">2016 Ace of Coders</a> National Infocomm Competition will take place on November 12, 2016.</p>\n\t\t<p>There will be a junior and senior category. The password to join all events is \"ida\" unless a teacher from your school has requested to change the password. </p>\n<ol>\t    \n\t<li>Please login to ClassMentors.com by clicking the login button above.</li>\n    <li>If you are new to ClassMentors, you will need to enter a unique public ID after you login (example: chris123).</li>\n    <li>After you are logged-in and have completed registering, click on the event for your school below.</li>\n\t<li>From the school event page, click the <b>Join</b> button, enter the password <b>ida</b>, and press enter. </li> \n\t<li>Once you have joined an event, go register for an account at <a href=\"https://www.freecodecamp.com\">FreeCodeCamp.com</a> and complete the first few achievements.</li>\n\t<li>Then come back to ClassMentors and update <a href=\"/#/profile/\">your profile</a> with your FreeCodeCamp username. This will allow ClassMentors to see how many FreeCodeCamp achievements you have completed.</li> \n</ol>\n\n\t    <p>If you see a school missing in the rankings below, please encoruage them to participate. If your school is not listed, you can join the <b>All Other Junior</b> or <b>All Other Senior</b> events.</p>\n\t\t<p>You can visit the <a href=\"https://www.facebook.com/aceofcoders\">Ace of Coders Facebook page</a> to leave comments, ask questions, and join in the conversation.</p>\n\t\t\t\nThank you!<br>\nHave fun learning :)<br>\nClassMentors Team<br>\n\t\t\n\t\t<!-- <p><b>{{$ctrl.stats.total_participants}}</b> students have registered so far.</p>\n\t\t<p><b>{{$ctrl.stats.total_schools}}</b> schools are participating.</p>\n\t\t-->\n\n\t</md-content>\n \n\t<md-toolbar md-scroll-shrink>\n\t\t<div class=\"md-toolbar-tools\">\n\t\t\t<h3><span>Junior Category Schools</span></h3>\n\t\t</div>\n\t</md-toolbar>\n\t<md-content class=\"md-padding\">\n\t\t<!--<md-subheader>0 School yet.</md-subheader>-->\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th>Rank</th> \n\t\t\t\t<th>Registerd Students</th>\n\t\t\t\t<th>School Event</th>\n\t\t\t\t<th></th> \n\t\t\t\t<th></th> \n\t\t\t</tr>\n\t\t\t<tr ng-repeat=\"school in $ctrl.stats.junior_ranking\" bgcolor=\"{{$index==11?'lightgreen':'white'}}\">\n\t\t\t\t<td>{{$index+1}}</td>\t\t\t\t\n\t\t\t\t<td>{{school.total}}</td>\n\t\t\t\t<td><a href=\"{{school.eventURL}}\">{{school.school}}</a></td>\n\t\t\t\t<td ng-if=\"school.name !== 'no second student'\"></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\n\t    </table>\n\t</md-content>\n\n\t<md-toolbar md-scroll-shrink>\n\t\t<div class=\"md-toolbar-tools\">\n\t\t\t<h3><span>Senior Category Schools</span></h3>\n\t\t</div>\n\t</md-toolbar>\n\t<md-content class=\"md-padding\">\n\t\t<!--<md-subheader>0 School yet.</md-subheader>-->\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th>Rank</th> \n\t\t\t\t<th>Registered Students</th>\n\t\t\t\t<th>School Event</th>\n\t\t\t\t<th></th> \n\t\t\t\t<th></th>\n\t\t\t</tr>\n\t\t\t<tr ng-repeat=\"school in $ctrl.stats.senior_ranking\"  bgcolor=\"{{$index==5?'lightgreen':'white'}}\">\n\t\t\t\t<td>{{$index+1}}</td>\n\t\t\t\t<td>{{school.total}}</td>\n\t\t\t\t<td><a href=\"{{school.eventURL}}\">{{school.school}}</a></td>\n\t\t\t\t<td ng-if=\"school.name !== 'no second student'\"></td>\n\t\t\t\t<td></td>\n\t\t\t\t<!--<td ng-if=\"school.name == 'no second student'\"><span style=\"font-style: italic; color: grey;\">No second student</span></td>-->\n\t\t\t</tr>\n\t    </table>\n    </md-content>\n</md-content>";AceController.$inject=['spfNavBarService'];/**
 * ace component.
 *
 * @type {Object}
 */component={template:template,bindings:{// binds $ctrl.stats to the value of the stats attribute.
stats:'<'},controller:AceController};ACE_STATS_URL='https://dl.dropboxusercontent.com/u/4972572/ace_of_coders_2016_stats.json';getStats.$inject=['$http','aceStatsUrl'];configRoute.$inject=['$routeProvider','routes'];ace$2=Object.freeze({component:component,ACE_STATS_URL:ACE_STATS_URL,getStats:getStats,configRoute:configRoute});mcqTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editMcq\" ng-submit=\"ctrl.save(ctrl.questions)\" >\n        {{ctrl.data}}\n        <div align=\"center\">\n            <h3>Multiple Choice</h3>\n            <h4>Title: {{ctrl.task.title}}</h4>\n            <h4>Description: {{ctrl.task.description}}</h4>\n            <br><br>\n        </div>\n\n        <!--<div>-->\n            <!--todo: requires timer to enable this function.-->\n            <!--<md-input-container>-->\n                <!--*Time Limit (in minute)-->\n                <!--<input type=\"number\" name=\"editTimeLimit\" id=\"edit-time-limit\"-->\n                       <!--ng-model=\"ctrl.task.timeLimit\"-->\n                       <!--min=\"0\" step=\"1\"-->\n                       <!--placeholder=\"Time Limit for the quiz\" value=\"\" required-->\n                <!--/>-->\n                <!--<div ng-messages=\"editMcq.editTimeLimit.$error\">-->\n                    <!--<div ng-message=\"number\">Time limit allowed should be a positive number in minutes.</div>-->\n                    <!--<div ng-message=\"required\">Enter time limit for the quiz. </div>-->\n                <!--</div>-->\n            <!--</md-input-container>-->\n\n            <!--<p>-->\n                <!--<h5>Questions</h5>-->\n                <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.randomQOrder\" aria-label=\"\">-->\n                    <!--Randomise questions order-->\n                <!--</md-switch>-->\n\n                <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.randomOOrder\" aria-label=\"\">-->\n                    <!--Randomise options order-->\n                <!--</md-switch>-->\n            <!--</p>-->\n\n            <!--<h5>Results Release</h5>-->\n            <!--<md-input-container>-->\n                <!--*Waiting time to view result after student's completion (minutes)-->\n                <!--<input type=\"number\" name=\"resultRelease\" id=\"result-release\"-->\n                       <!--ng-model=\"ctrl.task.resultRelease\"-->\n                       <!--min=\"0\" step=\"1\"-->\n                       <!--placeholder=\"Waiting time to view result after student's completion\" value=\"\" required-->\n                <!--/>-->\n                <!--<div ng-messages=\"editMcq.resultRelease.$error\">-->\n                    <!--<div ng-message=\"number\">Release time after completion should be a positive number in minutes.</div>-->\n                    <!--<div ng-message=\"required\">Please enter time(minutes) to release results after completion.</div>-->\n                <!--</div>-->\n            <!--</md-input-container>-->\n\n            <!--todo: install angular-timer and make timer work first before uncommenting-->\n            <!--<h5> Re-attempts Allowance</h5>-->\n            <!--<md-input-container>-->\n                <!--*Waiting time before students can re-attempt challenge (minutes)-->\n                <!--<input type=\"number\" name=\"reattempts\" id=\"reattempts\"-->\n                       <!--ng-model=\"ctrl.task.reattempts\"-->\n                       <!--min=\"0\" step=\"1\"-->\n                       <!--placeholder=\"Waiting time before students can re-attempt challenge (minutes)\" value=\"\" required-->\n                <!--/>-->\n                <!--<div ng-messages=\"editMcq.reattempts.$error\">-->\n                    <!--<div ng-message=\"number\">Waiting time before students can re-attempt challenge should be a positive number in minutes.</div>-->\n                    <!--<div ng-message=\"required\">Please enter time(minutes) before students can re-attempt challenge.</div>-->\n                <!--</div>-->\n            <!--</md-input-container>-->\n\n            <!--<h5>Team Mode</h5>-->\n            <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.enableTeam\" aria-label=\"\">-->\n                <!--Enable team answering mode-->\n            <!--</md-switch>-->\n\n        <!--</div>-->\n\n        <!------------------starting of questions--------------------------------------------->\n\n        <div align=\"center\">\n            <h4>Question Details</h4>\n        </div>\n\n        <div ng-repeat=\"question in ctrl.questions\">\n            <h3>\n                Question {{$index + 1}}\n                <md-button class=\"md-raised\" ng-click=\"ctrl.removeQuestion($event,$index)\" ng-disabled = \"ctrl.questions.length == 1\">Delete this question</md-button>\n            </h3>\n\n\n            <div align=\"center\" layout=\"row\" >\n                <md-input-container flex>\n                    <label for=\"edit-question_{{$index}}\">Question</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"edit-question_{{$index}}\"\n                           ng-model=\"question.text\"\n                           placeholer=\"Question\"\n                    />\n                </md-input-container>\n            </div>\n\n            <md-input-container >\n                <md-button type=\"button\" class=\"md-raised md-primary\" id=\"addOptions\" ng-click=\"ctrl.addOption(question)\">Add option</md-button>\n            </md-input-container>\n\n            <p ng-show=\"ctrl.isMcqValid == false\"><font color=\"red\">*One of the option must be an answer.</font></p>\n\n            <!--answer options-->\n            <div align=\"center\" layout=\"row\" ng-repeat=\"option in question.options\" >\n                <!--{{$index}}-->\n                <md-input-container flex >\n                    <label for=\"q-option_{{$index}}\">Option</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"q-option_{{$index}}\"\n                           ng-model=\"option.text\"\n                           placeholer=\"Options\"\n                    />\n                </md-input-container>\n\n                <!--todo: required at least one option to be the answer.-->\n                <md-input-container>\n                    <md-button ng-model=\"question.answers\" ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"\n                               ng-click=\"ctrl.toggleOption(question, $index)\">Answer</md-button>\n                </md-input-container>\n\n                <md-input-container >\n                    <md-button class=\"md-raised\" ng-click=\"ctrl.removeOption(question,$index)\" ng-disabled = \"question.options.length == 1\">Delete option</md-button>\n                </md-input-container>\n            </div>\n\n        </div>\n\n\n        <br>\n        <div align=\"center\">\n            <!--todo: can add new set of question-->\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click =\"ctrl.addQuestion()\">Add question</md-button>\n        </div>\n\n        <br>\n\n        <div align=\"center\">\n            <md-button type=\"submit\" ng-disabled=\"ctrl.isMcqValid == false\" class=\"md-raised md-primary\">Save</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n        </div>\n    </form>\n\n</md-content>";mcqEditTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editMcq\" ng-submit=\"ctrl.save(ctrl.questions)\" >\n        {{ctrl.data}}\n        <div align=\"center\">\n            <h3>Multiple Choice</h3>\n            <h4>Title: {{ctrl.task.title}}</h4>\n            <h4>Description: {{ctrl.task.description}}</h4>\n            <br><br>\n        </div>\n\n        <!--<div>-->\n        <!--todo: requires timer to enable this function.-->\n        <!--<md-input-container>-->\n        <!--*Time Limit (in minute)-->\n        <!--<input type=\"number\" name=\"editTimeLimit\" id=\"edit-time-limit\"-->\n        <!--ng-model=\"ctrl.task.timeLimit\"-->\n        <!--min=\"0\" step=\"1\"-->\n        <!--placeholder=\"Time Limit for the quiz\" value=\"\" required-->\n        <!--/>-->\n        <!--<div ng-messages=\"editMcq.editTimeLimit.$error\">-->\n        <!--<div ng-message=\"number\">Time limit allowed should be a positive number in minutes.</div>-->\n        <!--<div ng-message=\"required\">Enter time limit for the quiz. </div>-->\n        <!--</div>-->\n        <!--</md-input-container>-->\n\n        <!--<p>-->\n        <!--<h5>Questions</h5>-->\n        <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.randomQOrder\" aria-label=\"\">-->\n        <!--Randomise questions order-->\n        <!--</md-switch>-->\n\n        <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.randomOOrder\" aria-label=\"\">-->\n        <!--Randomise options order-->\n        <!--</md-switch>-->\n        <!--</p>-->\n\n        <!--<h5>Results Release</h5>-->\n        <!--<md-input-container>-->\n        <!--*Waiting time to view result after student's completion (minutes)-->\n        <!--<input type=\"number\" name=\"resultRelease\" id=\"result-release\"-->\n        <!--ng-model=\"ctrl.task.resultRelease\"-->\n        <!--min=\"0\" step=\"1\"-->\n        <!--placeholder=\"Waiting time to view result after student's completion\" value=\"\" required-->\n        <!--/>-->\n        <!--<div ng-messages=\"editMcq.resultRelease.$error\">-->\n        <!--<div ng-message=\"number\">Release time after completion should be a positive number in minutes.</div>-->\n        <!--<div ng-message=\"required\">Please enter time(minutes) to release results after completion.</div>-->\n        <!--</div>-->\n        <!--</md-input-container>-->\n\n        <!--todo: install angular-timer and make timer work first before uncommenting-->\n        <!--<h5> Re-attempts Allowance</h5>-->\n        <!--<md-input-container>-->\n        <!--*Waiting time before students can re-attempt challenge (minutes)-->\n        <!--<input type=\"number\" name=\"reattempts\" id=\"reattempts\"-->\n        <!--ng-model=\"ctrl.task.reattempts\"-->\n        <!--min=\"0\" step=\"1\"-->\n        <!--placeholder=\"Waiting time before students can re-attempt challenge (minutes)\" value=\"\" required-->\n        <!--/>-->\n        <!--<div ng-messages=\"editMcq.reattempts.$error\">-->\n        <!--<div ng-message=\"number\">Waiting time before students can re-attempt challenge should be a positive number in minutes.</div>-->\n        <!--<div ng-message=\"required\">Please enter time(minutes) before students can re-attempt challenge.</div>-->\n        <!--</div>-->\n        <!--</md-input-container>-->\n\n        <!--<h5>Team Mode</h5>-->\n        <!--<md-switch class=\"md-primary\" ng-model=\"ctrl.task.enableTeam\" aria-label=\"\">-->\n        <!--Enable team answering mode-->\n        <!--</md-switch>-->\n\n        <!--</div>-->\n\n        <!------------------starting of questions--------------------------------------------->\n\n        <div align=\"center\">\n            <h4>Question Details</h4>\n        </div>\n\n        <div ng-repeat=\"question in ctrl.questions\">\n            <h3>\n                Question {{$index + 1}}\n                <md-button class=\"md-raised\" ng-click=\"ctrl.removeQuestion($event,$index)\" ng-disabled = \"ctrl.questions.length == 1\">Delete this question</md-button>\n            </h3>\n\n\n            <div align=\"center\" layout=\"row\" >\n                <md-input-container flex>\n                    <label for=\"edit-question_{{$index}}\">Question</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"edit-question_{{$index}}\"\n                           ng-model=\"question.text\"\n                           placeholer=\"Question\"\n                    />\n                </md-input-container>\n            </div>\n\n            <md-input-container >\n                <md-button type=\"button\" class=\"md-raised md-primary\" id=\"addOptions\" ng-click=\"ctrl.addOption(question)\">Add option</md-button>\n            </md-input-container>\n\n            <p ng-show=\"ctrl.isMcqValid == false\"><font color=\"red\">*One of the option must be an answer.</font></p>\n\n            <!--answer options-->\n            <div align=\"center\" layout=\"row\" ng-repeat=\"option in question.options\" >\n                <!--{{$index}}-->\n                <md-input-container flex >\n                    <label for=\"q-option_{{$index}}\">Option</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"q-option_{{$index}}\"\n                           ng-model=\"option.text\"\n                           placeholer=\"Options\"\n                    />\n                </md-input-container>\n\n                <!--todo: required at least one option to be the answer.-->\n                <md-input-container>\n                    <md-button ng-model=\"question.answers\" ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"\n                               ng-click=\"ctrl.toggleOption(question, $index)\">Answer</md-button>\n                </md-input-container>\n\n                <md-input-container >\n                    <md-button class=\"md-raised\" ng-click=\"ctrl.removeOption(question,$index)\" ng-disabled = \"question.options.length == 1\">Delete option</md-button>\n                </md-input-container>\n            </div>\n\n        </div>\n\n\n        <br>\n        <div align=\"center\">\n            <!--todo: can add new set of question-->\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click =\"ctrl.addQuestion()\">Add question</md-button>\n        </div>\n\n        <br>\n\n        <div align=\"center\">\n            <md-button ng-disabled=\"ctrl.isMcqValid == false\" type=\"submit\" class=\"md-raised md-primary\">Save</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n        </div>\n    </form>\n\n</md-content>";mcqStart="<md-content flex class=\"md-padding\">\n\n  <div layout='column' align=\"center\">\n    <h3>Multiple Choice</h3>\n    <h4>Title: {{ctrl.task.title}}</h4>\n    <h4>Description: {{ctrl.task.description}}</h4>\n    <br>\n  </div>\n\n  <form name=\"startMcq\" ng-submit=\"ctrl.submit()\">\n    <div layout-align=\"column\">\n        <!------------------starting of questions--------------------------------------------->\n        <div flex ng-repeat=\"question in ctrl.questions\">\n          <div align=\"start\" layout=\"column\" >\n            <label><h2>Question {{$index + 1}}</h2></label>\n            <md-divider></md-divider>\n            <label><h4>{{question.text}}</h4></label>\n          </div>\n\n          <!--answer's options-->\n          \n            <!--Radio button inputs-->\n            <div ng-show=\"!ctrl.multipleAns[$index]\">\n                <md-radio-group ng-required=\"true\" ng-model=\"question.answers\" >\n                  <div layout=\"column\" ng-repeat=\"option in question.options\">\n                    <div layout=\"row\">\n                      <div flex=\"80\">\n                        <label>{{$index + 1}}) {{option.text}}</label>\n                      </div>\n                      <div flex=\"20\">\n                        <md-radio-button value={{$index}}></md-radio-button>\n                      </div>\n                    </div>\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                  </div>\n                </md-radio-group>\n            </div>\n            \n            <!--Checkbox inputs-->\n            <div ng-show=\"ctrl.multipleAns[$index]\">\n              <div layout=\"column\" ng-repeat=\"option in question.options\">\n                <div layout=\"row\">\n                  <div flex=\"80\">\n                    <label>{{$index + 1}}) {{option.text}}</label>\n                  </div>\n                  <div flex=\"20\">\n                    <md-checkbox ng-model=\"option.checked\" ng-required=\"question.answers.length == 0\" ng-click=\"ctrl.toggle(question.answers, $index)\"></md-checkbox>\n                  </div>\n                </div>\n                <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n              </div>\n            </div>\n        </div>\n      </div>\n    <br/>\n      <div layout=\"row\" layout-align=\"center center\">\n        <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"startMcq.$invalid\">Submit</md-button>\n        <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n      </div>\n  </form>\n</md-content>";editMcqController.$inject=['initialData','challengeService','$filter','$mdDialog','urlFor','$location'];startMcqController.$inject=['initialData','challengeService','clmDataStore','$location','$mdDialog','urlFor','spfAlert','$scope'];newMcqController.$inject=['initialData','challengeService','$filter','$mdDialog','urlFor','$location'];surveyTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyTask\" ng-submit=\"ctrl.saveSurveyTask(ctrl.surveyType.name)\">\n        <div align=\"center\">\n            <h2>Survey Challenge</h2>\n        </div>\n        <div align=\"center\">\n            <h3>End of class survey</h3>\n        </div>\n        <div align=\"center\">\n            <h3><i>How did you find this class? Take the following survey and provide feedback about what you liked\n                or</i>\n            </h3>\n            <h3><i>disliked about the class and classmentors as an in-class tool</i></h3>\n        </div>\n        <br>\n        <div align=\"center\" class=\"md-padding\">\n            <md-input-container align=\"center\">\n                <md-select ng-model=\"ctrl.surveyType\" style=\"width: 500px\" placeholder=\"Please select a form\">\n                    <md-optgroup label=\"Upload Standard Template\">\n                        <md-option ng-value=\"survey\"\n                           ng-repeat=\"survey in ctrl.surveys\">{{survey.name}}\n                        </md-option>\n                    </md-optgroup>\n                </md-select>\n            </md-input-container>\n        </div>\n        <!--ng-disabled=\"survey.name == 'Education vs Dissatisfaction with learning'\"-->\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-raised\">Submit</md-button>\n        </div>\n    </form>\n</md-content>";teamActivityCreateTmpl="<md-content flex class=\"md-padding\">\n  <div layout=\"column\" layout-align=\"center stretch\">\n    <form name=\"createTeamActivity\" ng-submit=\"ctrl.submit()\">\n\n      <div align=\"center\">\n        <h4>Title: {{ctrl.task.title}}</h4>\n        <h4>Description: {{ctrl.task.description}}</h4>\n        <br>\n      </div>\n\n      <label><b>Select Activity Type</b></label><br>\n      <div flex layout=\"column\" layout-align=\"center stretch\">\n        \n        <!--Radio group for Activity Types-->\n        <div>\n          <md-input-container>\n            <md-radio-group ng-model='ctrl.activityType' ng-required=\"true\">\n              {{ctrl.activityType}}\n              <md-radio-button value=\"gameShow\">Game Show (IRAT,TRAT)</md-radio-button>\n              <md-radio-button value=\"indexCards\">Index Cards</md-radio-button>\n              <md-radio-button value=\"collabSubmission\">Collaborative Submission</md-radio-button>\n            </md-radio-group>\n          </md-input-container>\n        </div>\n      </div>\n\n      <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n      <label><b>Team Formation</b></label><br><br>\n\n      <!--team formation segment-->\n      <div flex layout=\"column\" layout-align=\"center stretch\">\n        <!--{{ctrl.newExistingTeams}}-->\n        <div>\n          <label for=\"newExistingTeams\">Select team formation method:</label><br>\n          <md-input-container>\n            <md-select ng-model=\"ctrl.newExistingTeams\" id=\"newExistingTeams\">\n              <md-option value=\"existingTeams\" selected>From existing team formation</md-option>\n              <md-option value=\"newTeams\">Create new teams</md-option>\n            </md-select>\n          </md-input-container>\n        </div>\n\n        <!--if \"set new teams\" is checked-->\n        <div flex layout=\"column\" layout-align=\"center stretch\" ng-show=\"ctrl.newExistingTeams == 'newTeams'\">\n          <br>\n          <!--{{ctrl.teamFormationMethod}}-->\n          <label>Select create new team method:</label>\n          <md-input-container>\n            <md-select ng-model=\"ctrl.teamFormationMethod\" name=\"teamFormationMethod\">\n              <md-option value=\"teamSize\" >By Team Size</md-option>\n              <md-option value=\"noOfTeams\" selected>By Number Of Teams</md-option>\n            </md-select>\n          </md-input-container>\n        </div>\n\n         <!--setting for team size/ number of teams-->\n\n        <div flex layout=\"column\" ng-show=\"ctrl.newExistingTeams == 'newTeams'\" ng-hide=\"ctrl.newExistingTeams == 'existingTeams'\">\n          <md-input-container ng-required=\"true\">\n            <label for='edit-teamFormationInput_${{index}}'>{{ctrl.teamFormationMethod === \"teamSize\" ? \"Maximum number of students per team\" : \"Number of Teams\"}}</label>\n            <input type =\"number\" ng-model=\"ctrl.teamFormationParameter\"\n              name=\"teamFormationInput\"\n              id='edit-teamFormationInput_${{index}}' ng-change=\"ctrl.calculateTeamMaximumStudent(ctrl.teamFormationParameter)\"\n              >\n          </md-input-container>\n\n          <!--added remarks to assist user.-->\n          <label ng-show=\"ctrl.teamFormationMethod == 'noOfTeams'\" ng-hide=\"ctrl.teamFormationMethod == 'teamSize'\" ><font color=\"red\"> A team may have maximum enrollment of <b>{{ctrl.calculationResult()}}</b> student(s).</font></label>\n          <label ng-hide=\"ctrl.teamFormationMethod == 'noOfTeams'\" ng-show=\"ctrl.teamFormationMethod == 'teamSize'\" ><font color=\"red\">You will have <b>{{ctrl.calculationResult()}}</b> team(s).</font></label>\n          <br>\n        </div>\n\n\n        <!--if \"set new teams\" is unchecked-->\n        <div ng-hide=\"ctrl.newExistingTeams == 'newTeams'\" ng-show=\"ctrl.newExistingTeams == 'existingTeams'\" flex layout=\"column\" layout-align=\"center stretch\">\n\n          {{ctrl.teams}}\n          <label>Select from existing team activity challenges</label>\n          <md-input-container ng-disabled=\"ctrl.teams\">\n            <label ng-show=\"ctrl.teams\">Assign teams from previous team challenges</label>\n            <label ng-hide=\"ctrl.teams || ctrl.teams.length == 0\">No team challenges available</label>\n            <md-select ng-model=\"ctrl.selectedTeam\" ng-disabled=\"!ctrl.teams || ctrl.teams.length == 0\">\n              <md-option ng-repeat=\"team in ctrl.teams\" ng-value=\"team.name\"></md-option>\n            </md-select>\n          </md-input-container>\n        </div>\n\n\n        <!--multiple choice segment-->\n        <div flex layout=\"column\" layout-align=\"center stretch\" ng-show=\"ctrl.activityType == 'gameShow'\">\n\n          <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n          <label><b>IRAT/TRAT Questions</b></label><br>\n\n          {{ctrl.selectedMCQ}}\n          <md-input-container>\n            <label for=\"q-timelimit\">Time limit for each question (in minutes)</label>\n            <input type=\"number\" ng-model=\"ctrl.questionTimeLimit\" id=\"q-timelimit\">\n          </md-input-container>\n\n          <label>Select existing or create new multiple choice question</label>\n          <md-input-container>\n            <md-select ng-model=\"ctrl.selectedMCQ\">\n              <md-option ng-value=\"createMCQ\" selected>Create new MCQ</md-option>\n              <md-option ng-repeat=\"m in mcqs\" ng-value=\"$index\"></md-option>\n            </md-select>\n          </md-input-container>\n        </div>\n\n        <div>\n          <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"createTeamActivity.$invalid\">CREATE</md-button>\n        </div>\n\n      </div>\n    </form>\n  </div>\n</md-content>";teamIRATTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"iratForm\" ng-submit=\"ctrl.submitIrat()\">\n        <table width=\"100%\">\n            <tr>\n                <td>\n                    <h2>Question 1</h2>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <hr>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h3>What is the meaning of life?</h3>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <md-radio-group ng-model=\"radio1\">\n                        <md-radio-button value=\"1\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">1)</div>\n                            To be happy\n                        </md-radio-button>\n                        <md-radio-button value=\"2\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">2)</div>\n                            To get good grades\n                        </md-radio-button>\n                        <md-radio-button value=\"3\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">3)</div>\n                            To love\n                        </md-radio-button>\n                    </md-radio-group>\n\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h2>Question 2</h2>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <hr>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h3>What is 10x2?</h3>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <md-radio-group ng-model=\"radio2\">\n                        <md-radio-button value=\"1\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">1)</div>\n                            130\n                        </md-radio-button>\n                        <md-radio-button value=\"2\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">2)</div>\n                            120\n                        </md-radio-button>\n                        <md-radio-button value=\"3\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">3)</div>\n                            150\n                        </md-radio-button>\n                    </md-radio-group>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <div>\n                        <md-button type=\"submit\" class=\"md-raised md-primary\" style=\"width: 150px;\">Submit</md-button>\n                    </div>\n                </td>\n            </tr>\n        </table>\n    </form>\n</md-content>";teamTRATTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"tratForm\">\n        <!--Remember to correct the the logic when done-->\n        <div ng-show=\"ctrl.question\" flex layout='row' layout-align='start stretch'>\n            <div flex-offset='2' flex='66' name='question_box'>\n                <h1 class='md-title'>Question {{ctrl.index + 1}} </h1>\n                <md-divider></md-divider>\n                <!------------------starting of questions--------------------------------------------->\n                <div align=\"start\" layout=\"column\">\n                    <label><h4>{{ctrl.question.text}}</h4></label>\n                </div>\n\n                <!------------------starting of questions--------------------------------------------->\n                <div ng-show=\"!ctrl.multipleAns[ctrl.index]\">\n                    <md-radio-group ng-required=\"true\" ng-model=\"ctrl.selected\" ng-required='true'\n                                    ng-change='ctrl.onChange()'>\n                        <div layout=\"column\" ng-repeat=\"option in ctrl.options\">\n                            <div layout=\"row\">\n                                <div flex=\"80\">\n                                    <label>{{$index + 1}}) {{option.text}}</label>\n                                </div>\n                                <div flex=\"20\">\n                                    <md-radio-button aria-label=\"{{option.text}}\" value={{$index}}>\n                                    </md-radio-button>\n                                </div>\n                            </div>\n                            <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                        </div>\n                    </md-radio-group>\n                </div>\n                <div ng-show=\"ctrl.multipleAns[ctrl.index]\">\n                    <div layout=\"column\" ng-repeat=\"option in ctrl.options\">\n                        <div layout=\"row\">\n                            <div flex=\"80\">\n                                <label>{{$index + 1}}) {{option.text}}</label>\n                            </div>\n                            <div flex=\"20\">\n                                <md-checkbox ng-model=\"option.checked\" ng-required=\"true\"\n                                             ng-click=\"ctrl.toggle(ctrl.multiAns, $index)\"></md-checkbox>\n                            </div>\n                        </div>\n                        <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    </div>\n                </div>\n\n            </div>\n            <!------------------log box--------------------------------------------->\n            <div style=\"width:300px\" name='team_log' layout='column' class=\"md-whiteframe-3dp\">\n                <md-tool-bar layout='row' class=\"md-hue-1\">\n                    <div class='md-toolbar-tools'>\n                        <span>Team Log</span>\n                    </div>\n                </md-tool-bar>\n                <md-content>\n                    <!--{{ctrl.teamLog}}-->\n                    <!--<md-subheader class='md-no-sticky'>Last activity at: {{time}}</md-subheader>-->\n                    <md-virtual-repeat-container id=\"vertical-container\" style=\"width:400px\">\n                        <table md-virtual-repeat=\"msg in ctrl.teamLog | orderBy: '-'\" width=\"100%\">\n                            <tr>\n                                <td>\n                                    <md-list-item class='md-3-line' ng-model='ctrl.teamLog'>\n                                        <table class=\"md-list-item-text\">\n                                            <tr>\n                                                <td>\n                                                    <h3><b>{{ msg.user }}</b></h3>\n                                                </td>\n                                                <td>\n                                                    <div ng-style=\"{'font-size': '10px', 'color': '#A9A9A9'}\"> at\n                                                        {{msg.timestamp | date: 'hh:mm:ss'}}\n                                                    </div>\n                                                </td>\n                                            </tr>\n                                            <tr>\n                                                <td>\n                                                    Selected:\n                                                </td>\n                                                <td>\n                                                    <h3 ng-style=\"{'color': '#A9241C'}\"><b>{{ msg.text }}</b></h3>\n                                                </td>\n                                            </tr>\n                                        </table>\n                                    </md-list-item>\n                                </td>\n                            </tr>\n                            <tr>\n                                <td colspan=\"100%\">\n                                    <md-divider></md-divider>\n                                </td>\n                            </tr>\n                        </table>\n                    </md-virtual-repeat-container>\n                    <!--<md-list class='md-dense' flex>\n                        <md-list-item class='md-3-line' ng-model='ctrl.teamLog' ng-repeat=\"msg in ctrl.teamLog\">\n                            <div class=\"md-list-item-text\" layout=\"column\">\n                                <h3>{{ msg.user }}</h3>\n                                <h4>{{ msg.text }}</h4>\n                            </div>\n                        </md-list-item>\n                    </md-list>-->\n                </md-content>\n\n            </div>\n        </div>\n        <div layout=\"row\" layout-align=\"center center\">\n            {{ctrl.teamleader}}\n            <md-button class=\"md-raised md-primary\"\n                       ng-disabled=\"(ctrl.multiAns.length == 0 && ctrl.multipleAns[ctrl.index]) ||\n                    (ctrl.selected == null && !ctrl.multipleAns[ctrl.index])\"\n                       ng-click=\"ctrl.nextQuestion()\">Next\n            </md-button>\n        </div>\n    </form>\n</md-content>";teamFormationTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"teamFormation\" ng-submit=\"ctrl.save()\" layout-align=\"center center\">\n        <md-dialog-content class=\"sticky-container\">\n            <div flex layout='column'>\n                <div flex align='center'>\n                    <h1>Please join a team</h1>\n\n                </div>\n                <div>\n                    <md-input-container md-no-float>\n                       <md-radio-group ng-model=\"ctrl.selectedTeam\" ng-required='true' ng-change=\"ctrl.onChange(ctrl.selectedTeam)\">\n                           <md-radio-button ng-disabled='t.currentSize == t.maxSize'\n                            ng-repeat='t in ctrl.teams'\n                            ng-disabled=\"t.currentSize == t.maxSize\"\n                            ng-value=\"$index\">Team {{$index + 1}}, max: {{t.maxSize}} <br> {{t | showTeamMembers}}</md-radio-button>\n                       </md-radio-group>\n                    </md-input-container>\n                </div>\n                        <!--ng-model=\"ctrl.selectedTeam\"\n                            ng-change=\"ctrl.onClick($index)\"-->\n                <!--{{ctrl.teams | json}}-->\n                <div flex align='row'>\n                <md-button ng-click=\"ctrl.cancel()\" class=\"md-raised md-primary\" style=\"width: 150px;\">Close\n                        </md-button>\n                </div>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";TIMESTAMP={'.sv':'timestamp'};createTeamActivityInitialData.$inject=['$q','eventService','clmDataStore'];createTeamActivityController.$inject=['$q','initialData','clmDataStore','$location','urlFor','eventService'];startTRATInitialData.$inject=['$q','spfAuthData','eventService','clmDataStore','firebaseApp','$firebaseObject','$firebaseArray','$route'];startTRATController.$inject=['$q','initialData','clmDataStore','$location','urlFor','firebaseApp','$firebaseObject','$firebaseArray','spfAlert'];tratQuestionFactory.$inject=['$q','spfAuthData','eventService','clmDataStore'];configRoute$1.$inject=['$routeProvider','routes'];editMCQInitialData.$inject=['$q','eventService','clmDataStore'];startMCQInitialData.$inject=['$q','spfAuthData','eventService','clmDataStore','$route','firebaseApp','$firebaseObject'];createMCQInitialData.$inject=['$q','eventService'];challengeServiceFactory.$inject=['$q','$route','spfAuthData','clmDataStore','$log','spfAlert','$location','urlFor','firebaseApp','$firebaseArray','$firebaseObject'];surveyFormEvent.$inject=['$scope','clmSurvey','clmDataStore','$log','spfAlert','$location','urlFor'];getTaskSurveyValues.$inject=['clmSurvey','$q','$route','spfAuthData','clmDataStore'];challenges=Object.freeze({tratQuestionFactory:tratQuestionFactory,configRoute:configRoute$1,scrollBottom:scrollBottom,challengeServiceFactory:challengeServiceFactory});tmpl$3="<md-sidenav md-component-id=\"left\" md-is-locked-open=\"$mdMedia('gt-md')\" class=\"md-whiteframe-z2\">\n  <md-toolbar>\n    <h1 class=\"md-toolbar-tools\">\n      <a href=\"#/\">Class Mentors</a>\n    </h1>\n  </md-toolbar>\n  <md-list flex>\n    <md-item>\n      <md-item-content>\n        <md-button class=\"md-padding\" href=\"#{{ 'aceOfCoders' | urlFor }}\">\n          Ace of Coders\n        </md-button>\n      </md-item-content>\n      <md-item-content>\n        <md-button class=\"md-padding\" href=\"#{{ 'cohorts' | urlFor }}\">\n          Cohorts\n        </md-button>\n      </md-item-content>\n      <md-item-content>\n        <md-button class=\"md-padding\" href=\"#{{ 'events' | urlFor }}\">\n          Events\n        </md-button>\n      </md-item-content>\n      <md-item-content>\n        <md-button class=\"md-padding\" href=\"#{{ 'profile' | urlFor }}\">\n          Profile\n        </md-button>\n      </md-item-content>\n    </md-item>\n  </md-list>\n</md-sidenav>\n</md-sidenav>\n\n<div layout=\"column\" role=\"main\" flex>\n  <md-toolbar class=\"md-hue-2\" layout=\"row\" ng-include=\"'shared/navbar-view.html'\"></md-toolbar>\n\n  <md-content flex class=\"main-view\" layout=\"column\">\n    <div ng-view=\"\" layout=\"column\" flex></div>\n  </md-content>\n</div>";component$1={template:tmpl$3};classmentors=Object.freeze({component:component$1});cohortTmpl="<md-content flex class=\"md-padding\">\n    <!--<md-content layout-align=\"center\">-->\n        <!--<h1>Hey there!</h1>-->\n        <!--<h2>Check back later for more cool stuff! (:</h2>-->\n    <!--</md-content>-->\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\">\n\n        <md-tab label=\"Featured Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.featuredCohorts.length }} featured cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.featuredCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{c.owner.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Created Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.createdCohorts.length }} created cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.createdCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{ctrl.currentUser.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Joined Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.joinedCohorts.length }} joined cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.joinedCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{c.owner.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n</md-content>";newCohortTmpl="<md-content class=\"md-padding\">\n    <form name=\"newCohortForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.newCohort.data, ctrl.selectedEvents, ctrl.featured)\">\n        <spf-sign-form current-user=\"ctrl.currentUser\" ng-if=\"ctrl.profileNeedsUpdate\"></spf-sign-form>\n\n        <md-input-container>\n            <label for=\"cohort-name\">Cohort Name</label>\n            <input name=\"cohortName\" type=\"text\" id=\"cohort-name\" ng-model=\"ctrl.newCohort.data.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required/>\n            <div ng-messages=\"newCohortForm.cohortName.$error\">\n                <div ng-message=\"required\">A cohort must have a name.</div>\n                <div ng-message=\"minlength\">A cohort name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">A cohort name shouldn't be longer than 60 characters.</div>\n            </div>\n            <md-switch class=\"md-primary\" ng-model=\"ctrl.featured\" aria-label=\"feature?\">\n                Feature cohort\n            </md-switch>\n        </md-input-container>\n        <md-switch class=\"md-primary\" ng-model=\"ctrl.includeCreated\" aria-label=\"includeCreated?\">\n            <md-tooltip>\n                Select only one at a time. Unselect both to view featured events\n            </md-tooltip>\n            Include created events\n        </md-switch>\n        <md-switch class=\"md-primary\" ng-model=\"ctrl.includeJoined\" aria-label=\"includeJoined?\">\n            <md-tooltip>\n                Select only one at a time. Unselect both to view featured events\n            </md-tooltip>\n            Include joined events\n        </md-switch>\n\n        <h3>Select events to add to your cohort</h3>\n        <md-input-container>\n            <md-list class=\"path-list\" ng-repeat=\"e in (ctrl.events | orderBy:'createdAt':true) track by e.$id\" ng-if=\"!ctrl.includeCreated && !ctrl.includeJoined\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n\n            <md-list class=\"path-list\" ng-repeat=\"e in (ctrl.createdEvents | orderBy:'createdAt':true) track by e.$id\" ng-if=\"ctrl.includeCreated && !ctrl.includeJoined\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n\n            <md-list ng-if=\"ctrl.includeJoined && !ctrl.includeCreated\" class=\"path-list\" ng-repeat=\"e in (ctrl.joinedEvents | orderBy:'createdAt':true) track by e.$id\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.creatingEvent\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n        <div flex=\"100\">\n            <h2 class=\"md-title\">Selected Events</h2>\n            <code style=\"display: block; padding: 8px;\">{{ctrl.selectedEventsNames | json}}</code>\n        </div>\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-primary\" ng-disabled=\"newCohortForm.$invalid || ctrl.creatingCohort\">Create</md-button>\n            <md-button type=\"reset\" ng-click=\"ctrl.reset(newCohortForm)\" ng-disabled=\"ctrl.creatingCohort || newCohortForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n</md-content>\n";cohortViewTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\">\n\n        <md-tab label=\"Ranking\">\n            <md-content layout-padding>\n                <clm-cohorts-ranking-page\n                        cohort=\"ctrl.cohort\"\n                        profile=\"ctrl.profile\">\n                </clm-cohorts-ranking-page>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Announcements\">\n            <md-content layout-padding>\n                Events within this cohort:\n                <md-select flex ng-model=\"ctrl.selectedEvent\" name=\"selectEvent\" placeholder=\"View cohort events\">\n                    <md-option disabled ng-value=\"event\" ng-repeat=\"event in ctrl.cohort.events\">\n                        <a href=\"#{{ 'oneEvent' | urlFor: {eventId: event} }}\">{{ ctrl.events[event].title }}</a>\n                    </md-option>\n                </md-select>\n                Go to my event:<br>\n                <md-button aria-label=\"Child Event\" class=\"md-raised md-primary\" ng-repeat=\"event in ctrl.cohort.events\" ng-if=\"ctrl.joinedEvents[event]\" ng-href=\"#{{ 'oneEvent' | urlFor: {eventId: event} }}\">\n                    {{ctrl.events[event].title}}\n                </md-button>\n                <h3>Featured Announcements</h3>\n                <md-card ng-repeat=\"a in ctrl.announcements\" ng-if=\"a.featured && a.visible\">\n                    <md-toolbar>\n                        <md-card-title>\n                            <md-card-title-text>\n                                <span class=\"md-headline\">{{a.title}}</span>\n                            </md-card-title-text>\n                        </md-card-title>\n                    </md-toolbar>\n                    <md-card-content>\n                        <p class=\"subhead\">By {{a.madeBy}} at {{a.madeAt|date:'yyyy-MM-dd HH:mm'}}</p>\n                        <div style=\"white-space: pre-wrap;\">{{(a.content | cmTruncated: 2000).content}}<md-button ng-if=\"(a.content | cmTruncated: 2000).truncated\" class=\"material-icons\" ng-click=\"ctrl.viewFullAnnouncement(a.content, a.title)\">visibility<md-tooltip>View full announcement</md-tooltip></md-button></div>\n                    </md-card-content>\n                </md-card>\n                <h3>Announcements</h3>\n                <md-content layout=\"row\" layout-wrap>\n                    <md-card ng-repeat=\"a in ctrl.announcements\" ng-if=\"!a.featured && a.visible\" flex=\"49\" style=\"min-width: 400px;\">\n                        <md-toolbar>\n                            <md-card-title>\n                                <md-card-title-text>\n                                    <span class=\"md-headline\">{{a.title}}</span>\n                                </md-card-title-text>\n                            </md-card-title>\n                        </md-toolbar>\n                        <md-card-content>\n                            <p class=\"subhead\">By {{a.madeBy}} at {{a.madeAt|date:'yyyy-MM-dd HH:mm'}}<md-button ng-if=\"(a.content | cmTruncated: 300).truncated\" class=\"material-icons\" ng-click=\"ctrl.viewFullAnnouncement(a.content, a.title)\">visibility<md-tooltip>View full announcement</md-tooltip></md-button></p>\n                            <div style=\"white-space: pre-wrap;\">{{(a.content | cmTruncated: 140).content}}</div>\n                        </md-card-content>\n                    </md-card>\n                </md-content>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Stats\" ng-if=\"ctrl.isOwner\">\n            <md-content layout-padding>\n                <clm-cohorts-stats-page\n                        cohort=\"ctrl.cohort\"\n                        profile=\"ctrl.profile\">\n                </clm-cohorts-stats-page>\n            </md-content>\n        </md-tab>\n        <md-tab label=\"Manage\" ng-if=\"ctrl.isOwner\">\n            <md-content layout-padding>\n                <md-button ng-click=\"ctrl.selectedAction='dupChallenges'\">\n                    Duplicate event challenges\n                    <md-icon class=\"material-icons\">leak_remove</md-icon>\n                </md-button>\n                <div ng-if=\"ctrl.selectedAction=='dupChallenges'\">\n                    Move events:<br>\n                    Select event\n                    <md-select ng-model=\"ctrl.selectedEvent\" aria-label=\"select_event\" required placeholder=\"Select the event with the challenge you wish to duplicate\" ng-change=\"ctrl.loadEventChallenges()\">\n                        <h2>Cohort events</h2>\n                        <md-option ng-value=\"e\" ng-repeat=\"e in ctrl.cohort.events\">\n                            {{ctrl.events[e].title}}\n                        </md-option>\n                        <h2>Your events</h2>\n                        <md-option ng-value=\"e.$id\" ng-repeat=\"e in ctrl.createdEvents\">\n                            {{ctrl.events[e.$id].title}}\n                        </md-option>\n                    </md-select>\n                    <div ng-if=\"ctrl.selectedEvent\">\n                        You have selected {{ctrl.selectedEvent}}\n                        <md-select ng-model=\"ctrl.selectedChallenge\" aria-label=\"select_challenge\" required placeholder=\"Select the challenge you wish to duplicate\">\n                            <md-option ng-value=\"c\" ng-repeat=\"c in ctrl.eventChallenges\">\n                                {{c.title}}\n                            </md-option>\n                        </md-select>\n                    </div>\n                    <div ng-if=\"ctrl.selectedChallenge\">\n                        Duplicate {{ctrl.selectedChallenge.title}} from event {{ctrl.events[ctrl.selectedEvent].title}}?<br>\n                        Select events to duplicate the challenge to:\n                        <md-select ng-model=\"ctrl.selectedEvents\"\n                                   data-md-container-class=\"selectdemoSelectHeader\"\n                                   multiple aria-label=\"select_events\">\n                            <md-select-header class=\"demo-select-header\">\n                                <input ng-model=\"searchTerm\"\n                                       type=\"search\"\n                                       placeholder=\"Search for a vegetable..\"\n                                       class=\"demo-header-searchbox md-text\">\n                            </md-select-header>\n                            <md-optgroup label=\"vegetables\">\n                                <md-option ng-value=\"e\" ng-repeat=\"e in ctrl.cohort.events |\n              filter:searchTerm\" ng-if=\"e != ctrl.selectedEvent\">{{ctrl.events[e].title}}</md-option>\n                            </md-optgroup>\n                        </md-select>\n                    </div>\n                    <div layout=\"row\" layout-align=\"center center\">\n                        <md-button class=\"md-raised md-primary\" ng-if=\"ctrl.selectedEvents\" ng-click=\"ctrl.duplicateChallenges()\">\n                            Duplicate\n                        </md-button>\n                    </div>\n                </div>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n</md-content>";cohortEditTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <h2 hide show-sm>\n        {{ ctrl.event.title }}\n    </h2>\n\n    <form name=\"editCohortForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.cohort, editCohortForm)\">\n        <md-input-container>\n            <label for=\"cohort-title\">Cohort Name</label>\n            <input flex name=\"cohortTitle\" type=\"text\" id=\"cohort-title\" ng-model=\"ctrl.cohort.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required/>\n            <div ng-messages=\"editCohortForm.cohortTitle.$error\">\n                <div ng-message=\"required\">A cohort must have a name.</div>\n                <div ng-message=\"minlength\">A cohort name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">A cohort name shouldn't be longer than 60 characters.</div>\n            </div>\n            <md-switch class=\"md-primary\" ng-model=\"ctrl.cohort.featured\" aria-label=\"feature?\">\n                Feature cohort\n            </md-switch>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.savingCohort\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"editCohortForm.$pristine || editCohortForm.$invalid || ctrl.savingCohort\">Save</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset(editCohortForm)\" ng-disabled=\"ctrl.savingCohort || editCohortForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n\n    <md-divider></md-divider>\n\n    <md-subheader><md-button ng-click=\"ctrl.toggleEvents()\">Cohort Events<md-tooltip ng-if=\"!ctrl.showingEvents\">Click to view and edit cohort events</md-tooltip><md-tooltip ng-if=\"ctrl.showingEvents\">Click to hide cohort events</md-tooltip></md-button></md-subheader>\n    <div ng-if=\"ctrl.showingEvents\">\n        <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.addEvent()\" aria-label=\"addEvent\">Add Event</md-button>\n        <form name=\"addEventForm\" ng-submit=\"ctrl.saveAddedEvent(ctrl.cohort.$id)\">\n            <md-card ng-if=\"ctrl.addingEvent\">\n                <md-card-content>\n                    <md-autocomplete flex required ng-if=\"ctrl.addingEvent\"\n                                     md-input-name=\"eventName\"\n                                     md-input-minlength=\"1\"\n                                     md-input-maxlength=\"64\"\n                                     md-no-cache=\"true\"\n                                     md-selected-item=\"ctrl.selectedEvent\"\n                                     md-search-text=\"ctrl.searchEvent\"\n                                     md-items=\"event in ctrl.querySearch(ctrl.searchEvent)\"\n                                     md-item-text=\"event.title\"\n                                     placeholder=\"Select event\">\n                        <md-item-template>\n                            <span md-highlight-text=\"ctrl.searchEvent\">{{event.title}}</span>\n                        </md-item-template>\n                        <div ng-messages=\"addEventForm.eventName.$error\" ng-if=\"addEventForm.eventName.$touched\">\n                            <div ng-message=\"required\">You <b>must</b> select an event.</div>\n                        </div>\n                        <md-not-found>\n                            No events matching \"{{ctrl.searchEvent}}\" were found.\n                        </md-not-found>\n                    </md-autocomplete>\n                </md-card-content>\n                <md-card-actions layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"addEventForm.$pristine || addEventForm.$invalid || !ctrl.selectedEvent\">Add Event</md-button>\n                    <md-button class=\"md-raised\" ng-click=\"ctrl.closeAddingEvent()\">Cancel</md-button>\n                </md-card-actions>\n            </md-card>\n        </form>\n        <md-list>\n            <md-list-item ng-repeat=\"e in ctrl.cohort.events\" ng-if=\"ctrl.events[e]\">\n                {{ctrl.events[e].title}}\n                <span flex></span>\n                <md-button ng-click=\"ctrl.removeCohortEvent(e, ctrl.cohort.events.indexOf(e))\">\n                    <md-icon class=\"material-icons\">clear</md-icon>\n                    <md-tooltip md-direction=\"left\">\n                        Remove event\n                    </md-tooltip>\n                </md-button>\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n\n    <md-divider></md-divider>\n\n    <md-subheader><md-button ng-click=\"ctrl.toggleAnnouncements()\">Cohort Announcements<md-tooltip ng-if=\"!ctrl.showingAnnouncements\">Click to view and edit cohort announcements</md-tooltip><md-tooltip ng-if=\"ctrl.showingAnnouncements\">Click to hide cohort announcements</md-tooltip></md-button></md-subheader>\n    <div ng-if=\"ctrl.showingAnnouncements\">\n    <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.createNewAnnouncement()\">New Announcement</md-button>\n    <form name=\"addAnnouncementForm\" ng-submit=\"ctrl.saveAnnouncement(ctrl.cohort.$id)\">\n        <md-card ng-if=\"ctrl.creatingNewAnnouncement\">\n            <md-input-container>\n                <input aria-label=\"Announcement title\" required placeholder=\"Announcement title\" type=\"text\" ng-model=\"ctrl.newAnnouncement.title\" id=\"new-announcement-title\" name=\"newAnnouncementTitle\">\n                <div ng-messages=\"addAnnouncementForm.newAnnouncementTitle.$error\">\n                    <div ng-message=\"required\">An announcement must have a title.</div>\n                </div>\n            </md-input-container>\n            <textarea aria-label=\"Announcement content\" required placeholder=\"Announcement content\" name=\"newAnnouncementContent\" id=\"new-announcement-content\"\n                      ng-model=\"ctrl.newAnnouncement.content\" rows=\"3\">\n            </textarea>\n            <md-switch ng-model=\"ctrl.newAnnouncement.featured\" aria-label=\"Featured?\">\n                Featured: {{ ctrl.newAnnouncement.featured }}\n            </md-switch>\n            <md-switch ng-model=\"ctrl.newAnnouncement.visible\" aria-label=\"Visibility\">\n                Visible: {{ ctrl.newAnnouncement.visible }}\n            </md-switch>\n            <md-card-actions layout=\"row\" layout-align=\"start center\">\n                <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"addAnnouncementForm.$pristine || addAnnouncementForm.$invalid\">Save Announcement</md-button>\n                <md-button class=\"md-raised\" ng-click=\"ctrl.closeNewAnnouncement()\">Cancel</md-button>\n            </md-card-actions>\n        </md-card>\n    </form>\n\n    <md-list>\n        <md-list-item ng-repeat=\"a in ctrl.announcements\">\n            {{a.title}}\n            <span flex></span>\n            <md-button ng-if=\"!a.featured\" ng-click=\"ctrl.featureAnnouncement(ctrl.cohort.$id, a.$id)\">\n                <md-icon class=\"material-icons\">leak_add</md-icon>\n                <md-tooltip>\n                Feature\n                </md-tooltip>\n            </md-button>\n            <md-button ng-if=\"a.featured\" ng-click=\"ctrl.unfeatureAnnouncement(ctrl.cohort.$id, a.$id)\">\n                <md-icon class=\"material-icons\">leak_remove</md-icon>\n                <md-tooltip>\n                    Un-Feature\n                </md-tooltip>\n            </md-button>\n            <md-button ng-if=\"!a.visible\" ng-click=\"ctrl.showAnnouncement(ctrl.cohort.$id, a.$id)\">\n                <md-icon class=\"material-icons\">visibility</md-icon>\n                <md-tooltip>\n                    Show announcement\n                </md-tooltip>\n            </md-button>\n            <md-button ng-if=\"a.visible\" ng-click=\"ctrl.hideAnnouncement(ctrl.cohort.$id, a.$id)\">\n                <md-icon class=\"material-icons\">visibility_off</md-icon>\n                <md-tooltip>\n                    Hide announcement\n                </md-tooltip>\n            </md-button>\n            <md-divider ng-if=\"!$last\"></md-divider>\n        </md-list-item>\n    </md-list>\n    </div>\n</md-content>\n";cohortStatsPageTmpl="<md-content flex class=\"md-padding\">\n\n    <!--<link href=\"../../../jspm_packages/graphing/c3.min.css\" rel=\"stylesheet\" type=\"text/css\">-->\n    <!--<script src=\"../../../jspm_packages/graphing/d3.min.js\"></script>-->\n    <script src=\"../../../jspm_packages/npm/c3@0.4.11/c3.css\"></script>\n\n    <md-select flex ng-model=\"ctrl.selectedStatistic\" name=\"selectStatistic\" placeholder=\"Select statistic to view\" ng-change=\"ctrl.renderDashboard()\">\n        <md-option ng-repeat=\"statistic in ['Submission time series', 'Ordering']\">\n            {{statistic}}\n        </md-option>\n    </md-select>\n\n    <div id=\"chart\" align=\"center\"></div>\n    <!--<div ng-if=\"ctrl.selectedStatistic=='Submission time series'\">-->\n        <!--<svg width=\"960\" height=\"960\"></svg>-->\n        <!--<canvas width=\"960\" height=\"960\" id=\"canvas\"></canvas>-->\n    <!--</div>-->\n\n</md-content>";cohortRankingPageTmpl="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n<div ng-if=\"!ctrl.loading\">\n    <md-content class=\"md-padding\">\n        <!--<timer interval=\"1000\">{{hhours}} hour{{hhoursS}}, {{mminutes}} minute{{minutesS}}, {{sseconds}} second{{secondsS}}.</timer>-->\n        <md-switch ng-model=\"ctrl.showFilteredRanking\" aria-label=\"showFilter?\" ng-change=\"ctrl.filterRanking()\">\n            Show Filtered Rankings: {{ ctrl.showFilteredRanking }}\n        </md-switch>\n        <table class=\"events ranking\">\n            <thead>\n            <tr>\n                <th>\n                    <md-button>Rank</md-button>\n                </th>\n                <th ng-if=\"!ctrl.showFilteredRanking\">\n                    <md-button>Registered ({{ctrl.cohortTotalParticipants.length}})</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button>Qualified</md-button>\n                </th>\n                <th>\n                    <md-button>Event</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">1st</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">2nd</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">3rd</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">4th</md-button>\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n                <tr ng-if=\"!ctrl.showFilteredRanking\" ng-repeat=\"event in ctrl.cohortEventData | orderBy:'-participants'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                     {{$index+1}}\n                    </th>\n                    <td>{{ event.participants.length }}</td>\n                    <td><a href=\"#{{ 'oneEvent' | urlFor: {eventId: event.id} }}\">{{ event.title }}</a></td>\n                </tr>\n                <tr ng-if=\"ctrl.showFilteredRanking\" ng-repeat=\"event in ctrl.cohortEventData | orderBy:'-qualifiedParticipants'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                        {{$index+1}}\n                    </th>\n                    <td>{{ event.qualifiedParticipants.length }}</td>\n                    <td><a href=\"#{{ 'oneEvent' | urlFor: {eventId: event.id} }}\">{{ event.title }}</a></td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<12\">{{event.qualifiedParticipants[0].displayName }} ({{event.qualifiedParticipants[0].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<12\">{{event.qualifiedParticipants[1].displayName }} ({{event.qualifiedParticipants[1].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<2\">{{event.qualifiedParticipants[2].displayName }} ({{event.qualifiedParticipants[2].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<2\">{{event.qualifiedParticipants[3].displayName }} ({{event.qualifiedParticipants[3].score}})</td>\n                </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOpts\" class=\"md-padding\"></clm-pager>\n</div>";noop$5=function noop(){return undefined;};component$2={controller:ViewCohortCtrl};configRoute$2.$inject=['$routeProvider','routes'];ClmListCohorts.$inject=['initialData','spfNavBarService','urlFor','spfAuthData'];classMentorsCohortResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];NewCohortCtrl.$inject=['$q','$location','initialData','urlFor','spfAuthData','spfAlert','spfNavBarService','clmDataStore'];newCohortCtrlInitialData.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];viewCohortCtrlInitialData.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ViewCohortCtrl.$inject=['$log','$scope','initialData','$document','$mdDialog','$route','$firebaseObject','spfAlert','urlFor','firebaseApp','spfAuthData','spfNavBarService','clmDataStore'];editCohortCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditCohortCtrl.$inject=['initialData','spfNavBarService','urlFor','spfAlert','clmDataStore'];ClmCohortStatsPageCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','$firebaseArray','urlFor','spfAlert','firebaseApp','clmServicesUrl','clmDataStore'];ClmCohortRankPageCtrl.$inject=['$q','$scope','$log','firebaseApp','$firebaseObject','$firebaseArray','clmDataStore','clmPagerOption'];cohorts=Object.freeze({component:component$2,configRoute:configRoute$2,clmCohortsStatsPageFactory:clmCohortsStatsPageFactory,clmCohortRankPageFactory:clmCohortRankPageFactory});editTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <h2 hide show-sm>\n        {{ ctrl.event.title }}\n    </h2>\n\n    <form name=\"editEventForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.event, ctrl.newPassword, editEventForm)\">\n        <md-input-container>\n            <label for=\"event-title\">Event Name</label>\n            <input name=\"eventTitle\" type=\"text\" id=\"event-title\" ng-model=\"ctrl.event.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required=\"true\"/>\n            <div ng-messages=\"editEventForm.eventTitle.$error\">\n                <div ng-message=\"required\">An event should have a name.</div>\n                <div ng-message=\"minlength\">An event name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">An event name shouldn't be longer than 60 characters.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container>\n            <label for=\"event-pw\">New Password</label>\n            <input name=\"eventPw\" type=\"text\" id=\"event-pw\" ng-model=\"ctrl.newPassword\" />\n            <div ng-messages=\"editEventForm.eventPw.$error\">\n            </div>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.savingEvent\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n\n        <div class=\"information\">Created by {{ctrl.event.owner.displayName}} on ({{ctrl.event.createdAt|date}})</div>\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"editEventForm.$pristine || editEventForm.$invalid || ctrl.savingEvent || !ctrl.isOwner\">Save</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset(editEventForm)\" ng-disabled=\"ctrl.savingEvent || editEventForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n\n    <md-divider></md-divider>\n\n    <md-subheader><md-button ng-click=\"ctrl.toggleAssistants()\">Event Assistants<md-tooltip ng-if=\"!ctrl.showingAssistants\">Click to view and edit event assistants</md-tooltip><md-tooltip ng-if=\"ctrl.showingAssistants\">Click to hide event assistants</md-tooltip></md-button></md-subheader>\n    <div ng-if=\"ctrl.showingAssistants\">\n        <div class=\"information\">\n            <md-button ng-click=\"ctrl.addAssistant()\">\n                <md-icon md-svg-icon=\"add\"></md-icon>\n                <md-tooltip>\n                    Add assistant\n                </md-tooltip>\n            </md-button>\n        </div>\n        <form name=\"addAssistantForm\" ng-submit=\"ctrl.saveNewAssistant(ctrl.event.$id)\">\n            <md-card ng-if=\"ctrl.addingNewAssistant\">\n                <md-card-content>\n                    <md-autocomplete flex required\n                                     md-input-name=\"assistantName\"\n                                     md-input-minlength=\"1\"\n                                     md-input-maxlength=\"64\"\n                                     md-no-cache=\"true\"\n                                     md-selected-item=\"ctrl.selectedUser\"\n                                     md-search-text=\"ctrl.searchUser\"\n                                     md-items=\"user in ctrl.querySearch(ctrl.searchUser)\"\n                                     md-item-text=\"user.displayName\"\n                                     placeholder=\"Select assistant profile\">\n                        <md-item-template>\n                            <span md-highlight-text=\"ctrl.searchUser\">{{user.displayName}}</span>\n                        </md-item-template>\n                        <div ng-messages=\"addAssistantForm.assistantName.$error\" ng-if=\"addAssistantForm.assistantName.$touched\">\n                            <div ng-message=\"required\">You <b>must</b> select a user.</div>\n                        </div>\n                        <md-not-found>\n                            No users matching \"{{ctrl.searchUser}}\" were found.\n                        </md-not-found>\n                    </md-autocomplete>\n\n                    <md-switch ng-model=\"ctrl.newAssistant.canEdit\" aria-label=\"canEdit?\">\n                        Can Edit Events: {{ ctrl.newAssistant.canEdit }}\n                    </md-switch>\n                    <md-switch ng-model=\"ctrl.newAssistant.canReview\" aria-label=\"canReview?\">\n                        Can Review Event Submissions: {{ ctrl.newAssistant.canReview }}\n                    </md-switch>\n                </md-card-content>\n                <md-card-actions layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"addAssistantForm.$pristine || addAssistantForm.$invalid || !ctrl.selectedUser\">Approve Assistant</md-button>\n                    <md-button class=\"md-raised\" ng-click=\"ctrl.closeNewAssistant()\">Cancel</md-button>\n                </md-card-actions>\n            </md-card>\n        </form>\n        <md-list>\n            <md-subheader class=\"md-no-sticky\">{{ ctrl.assistants | spfLength }} assistants</md-subheader>\n            <md-list-item ng-repeat=\"asst in ctrl.assistants track by asst.$id\">\n                {{ asst.name }}\n                <span flex></span>\n                <md-button ng-click=\"ctrl.disableReview(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"asst.canReview\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Disable reviewing of event task submissions\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Reviewing\n                </md-button>\n                <md-button ng-click=\"ctrl.enableReview(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"!asst.canReview\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Enable reviewing of event task submissions\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Reviewing\n                </md-button>\n                <md-button ng-click=\"ctrl.disableEdit(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"asst.canEdit\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Disable editing of event\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Editing\n                </md-button>\n                <md-button ng-click=\"ctrl.enableEdit(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"!asst.canEdit\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Enable editing of event\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Editing\n                </md-button>\n                <md-button ng-click=\"ctrl.removeAssistant(ctrl.event.$id, asst.$id, asst.name)\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Remove user as event assistant\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Remove\n                </md-button>\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n        \n    <md-divider></md-divider>\n\n    <md-subheader><md-button ng-click=\"ctrl.toggleTaskEditView()\">Event Challenges<md-tooltip ng-if=\"!ctrl.showingTasks\">Click to view and edit event challenges</md-tooltip><md-tooltip ng-if=\"ctrl.showingTasks\">Click to hide event challenges</md-tooltip></md-button></md-subheader>\n    <md-list ng-if=\"ctrl.showingTasks\">\n        <md-subheader class=\"md-no-sticky\">{{ ctrl.tasks | spfLength }} challenges</md-subheader>\n        <md-list-item class=\"md-3-line\" ng-repeat=\"task in ctrl.tasks track by task.$id\" ng-if=\"!task.archived\">\n            <div class=\"md-list-item-text\">\n                <h3>\n                    {{ task.title }}\n                    <span ng-if=\"task.closedAt\">(closed)</span>\n                    <span ng-if=\"task.openedAt\">(opened)</span>\n                </h3>\n                <h4>{{ task.description }}</h4>\n                <p ng-if=\"task.badge.id\">{{ task.badge.name}}</p>\n            </div>\n\n            <div layout=\"row\">\n                <md-button ng-href=\"#{{ 'editEventTask'|urlFor: {eventId: ctrl.event.$id, taskId: task.$id} }}\" layout layout-align=\"center center\" class=\"md-raised md-primary\" aria-label=\"Edit\">\n                    <md-icon md-svg-icon=\"create\"></md-icon>\n                    Edit\n                </md-button>\n                <md-button ng-click=\"ctrl.openTask(ctrl.event.$id, task.$id)\"\n                    ng-if=\"task.closedAt\"\n                    layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                    aria-label=\"open\"\n                >\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Open\n                </md-button>\n                <md-button ng-click=\"ctrl.closeTask(ctrl.event.$id, task.$id)\"\n                    ng-if=\"task.openedAt\"\n                    layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                    aria-label=\"open\"\n                >\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Close\n                </md-button>\n                <md-button ng-click=\"ctrl.showTask(ctrl.event.$id, task.$id)\"\n                    ng-if=\"task.hidden\"\n                    layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                    aria-label=\"open\"\n                >\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Show\n                </md-button>\n                <md-button ng-click=\"ctrl.hideTask(ctrl.event.$id, task.$id)\"\n                    ng-if=\"!task.hidden\"\n                    layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                    aria-label=\"open\"\n                >\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Hide\n                </md-button>\n                <md-button ng-click=\"ctrl.archiveTask(ctrl.event.$id, task.$id)\"\n                    layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                    aria-label=\"open\"\n                >\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Archive\n                </md-button>\n            </div>\n\n            <md-divider ng-if=\"!$last\"></md-divider>\n        </md-list-item>\n    </md-list>\n\n</md-content>\n";eventTableParticipantsTmpl="<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n\n<div ng-if=\"!ctrl.loading\">\n    <md-content class=\"md-padding\">\n        <table class=\"events tasks\">\n            <thead>\n            <tr ng-class=\"{'reversed': ctrl.orderOptions.reversed}\">\n                <th rowspan=\"4\" ng-class=\"{orderer: !ctrl.orderOptions.key}\">\n                    <md-button ng-click=\"ctrl.orderBy()\">Participants</md-button>\n                </th>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\">\n                    <em>No challenge</em>\n                </th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\"\n                    ng-class=\"{orderer: ctrl.orderOptions.key == task.$id}\"\n                >\n                    <md-button ng-click=\"ctrl.orderBy(task.$id)\">{{ task.title }}</md-button>\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    {{ task.description }}\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <a ng-href=\"{{task.link}}\" ng-if=\"task.link\" target=\"_blank\">More details</a>\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    {{ctrl.taskCompletion[task.$id] | number: 0}} %\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr ng-if=\"ctrl.currentUserParticipant\">\n                <th layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"name-button\"\n                               ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserParticipant.$id} }}\">\n                        Yourself\n                    </md-button>\n\n                    <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Update\"\n                               ng-click=\"ctrl.update(ctrl.event, ctrl.tasks, ctrl.currentUserSolutions, ctrl.profile)\">\n                        <md-icon md-svg-icon=\"loop\"></md-icon>\n                    </md-button>\n\n                </th>\n\n                <td ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <div ng-if=\"task.mcqQuestions\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n\n                                <!--todo: add timer and make it work before allowing re-attempts-->\n                                <!--<timer countdown = \"10041\" max-time-unit=\"minute\" interval=\"1000\"> {{mminutes}} minute {{minutesS}},{{sseconds}} second{{secondsS}}</timer>-->\n                                Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n\n                                <!--<md-button class=\"md-raised md-primary\"-->\n                                <!--ng-click=\"ctrl.startMCQ(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"-->\n                                <!--target=\"_blank\"-->\n                                <!--ng-if=\"task.openedAt\"-->\n                                <!--aria-label=\"Re-attempt challenge\"-->\n                                <!--&gt;-->\n\n                                <!--Re-attempt Mcq-->\n                                <!--</md-button>-->\n\n                            </span>\n                        <!--added one more contraint to change the button to Start IRAT-->\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button ng-if=\"!task.teamFormationMethod\" class=\"md-raised md-primary\"\n                                           ng-click=\"ctrl.startMCQ(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           target=\"_blank\"\n                                           ng-disabled=\"task.closedAt\"\n                                           aria-label=\"Start challenge\"\n                                >\n                                    Start Mcq\n                                    <!--<span ng-switch on=\"ctrl.mustRegister(task, ctrl.profile)\">-->\n                                    <!--<span ng-switch-when=\"true\">Register</span>-->\n                                    <!--<span ng-switch-default>Start challenge</span>-->\n                                    <!--</span>-->\n                                </md-button>\n                            </span>\n                    </div>\n                    <div ng-if=\"task.teamFormationMethod\">\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                        <md-button class=\"md-raised md-primary\" ng-if=\"task.startIRAT\"\n                                   ng-click=\"ctrl.startMCQ(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   target=\"_blank\"\n                                   ng-disabled=\"task.closedAt\"\n                                   aria-label=\"Start irat\"\n                        >\n                            Start IRAT\n\n                        </md-button>\n                        </span>\n\n                        <md-button class=\"md-raised md-primary\" ng-if=\"task.formationPattern\"\n                                   ng-click=\"ctrl.promptForTeamFormation(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   target=\"_blank\"\n                                   ng-disabled=\"task.closedAt\"\n                                   aria-label=\"Start form team\"\n                        >\n\n                            Form Team\n                        </md-button>\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                        <md-button class=\"md-raised md-primary\" ng-if=\"task.startTRAT\"\n                                   ng-click=\"ctrl.startTRAT(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                   target=\"_blank\"\n                                   ng-disabled=\"task.closedAt\"\n                                   aria-label=\"Start trat\"\n                        >\n                            Start TRAT\n                        </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.serviceId\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                            </span>\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           ng-href=\"{{ctrl.startLink(task, ctrl.profile)}}\"\n                                           target=\"_blank\"\n                                           ng-disabled=\"task.closedAt\"\n                                           aria-label=\"Start challenge\"\n                                >\n                                    <span ng-switch on=\"ctrl.mustRegister(task, ctrl.profile)\">\n                                        <span ng-switch-when=\"true\">Register</span>\n                                        <span ng-switch-default>Start challenge</span>\n                                    </span>\n                                </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.textResponse && !task.lang && !task.toEdit\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                {{ ctrl.currentUserSolutions[task.$id] | cmTruncate: 10 }}<span\n                                    ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update response\"\n                                           ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           aria-label=\"Submit response\"\n                                           ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-disabled=\"task.closedAt\"\n                                >\n                                    Submit Response\n                                </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.textResponse && task.lang\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                {{ ctrl.currentUserSolutions[task.$id] | cmTruncate: 10 }}<span\n                                    ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update response\"\n                                           ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           aria-label=\"Submit response\"\n                                           ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-disabled=\"task.closedAt\"\n                                >\n                                    Submit Code\n                                </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.linkPattern\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                <a ng-href=\"{{ctrl.currentUserSolutions[task.$id]}}\" target=\"_blank\">Completed<span\n                                        ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span></a>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update link\"\n                                           ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           aria-label=\"Submit link\"\n                                           ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-disabled=\"task.closedAt\"\n                                >\n                                    Submit Link\n                                </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.survey\">\n                                <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                    Completed\n                                    <span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                                </span>\n\n                        <md-button class=\"md-raised md-primary\"\n                                   aria-label=\"Submit survey\"\n                                   ng-click=\"ctrl.promptForSurvey(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   ng-disabled=\"task.closedAt\" ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            Start Survey\n                        </md-button>\n                    </div>\n                    <div ng-if=\"task.toEdit\">\n                        <div ng-if=\"ctrl.profile.user.school\">\n                            {{ctrl.profile.user.school.name | cmTruncate: 10}}\n                            <md-button class=\"md-icon-button md-primary small-icon\"\n                                       aria-label=\"Update_profile\"\n                                       ng-click=\"ctrl.editProfileInfo(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                       ng-if=\"task.openedAt\"\n                            >\n                                <md-icon md-svg-icon=\"create\"></md-icon>\n                            </md-button>\n                        </div>\n\n                        <div ng-if=\"!ctrl.profile.user.school\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Enter_profile_info\"\n                                       ng-click=\"ctrl.editProfileInfo(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                       ng-disabled=\"task.closedAt\">\n                                Enter Information\n                            </md-button>\n                        </div>\n                    </div>\n                </td>\n                <!--team activity challenge button!\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-href=\"#{{'viewIRAT' | urlFor:{'publicId': participant.$id} }}\">\n                        Start IRAT\n                    </md-button>\n                </td>\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-click=\"ctrl.promptForTeamFormation(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\">\n                        Join Team\n                    </md-button>\n                </td>\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-href=\"#{{'viewTRAT' | urlFor:{'publicId': participant.$id} }}\">\n                        Start TRAT\n                    </md-button>\n                </td>-->\n            </tr>\n\n            <tr ng-repeat=\"participant in ctrl.participantsView track by participant.$id\"\n                ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n\n                <th layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\">\n                        {{ participant.user.displayName }}\n                    </md-button>\n\n                    <span ng-if=\"ctrl.profile.$id == ctrl.event.owner.publicId &amp;&amp; participant.$id != ctrl.profile.$id\">\n                            <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Delete\"\n                                       ng-click=\"ctrl.removeParticipant($event, ctrl.event, participant)\">\n                                <md-icon md-svg-icon=\"clear\"></md-icon>\n                            </md-button>\n                        </span>\n                </th>\n\n                <td ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <div ng-if=\"ctrl.progress[participant.$id][task.$id].completed && task.showProgress\">\n                        <!--<span ng-if=\"(!task.textResponse && !task.linkPattern) || !ctrl.isReviewSuperUser\">-->\n                        <!--Completed-->\n                        <!--</span>-->\n\n                        <span ng-if=\"task.showLinks\">\n                                <span ng-if=\"task.linkPattern\">\n                                    <a ng-href=\"{{ctrl.solutions[participant.$id][task.$id]}}\"\n                                       target=\"_blank\">completed</a>\n                                </span>\n                                <span ng-if=\"task.textResponse && !task.lang && !task.linkPattern && !task.toEdit\">\n                                    <md-menu>\n                                        <md-button ng-click=\"$mdOpenMenu()\">\n                                            {{ ctrl.solutions[participant.$id][task.$id] | cmTruncate: 10 }}\n                                        </md-button>\n                                        <md-menu-content>\n                                            <div style=\"white-space: pre-wrap;\">{{ ctrl.solutions[participant.$id][task.$id]}}</div>\n                                        </md-menu-content>\n                                    </md-menu>\n                                    <!--<md-tooltip ng-if=\"(ctrl.solutions[participant.$id][task.$id] | cmTruncated: 10).truncated\">-->\n                                    <!--<div style=\"white-space: pre-wrap;\">{{ ctrl.solutions[participant.$id][task.$id]}}</div>-->\n                                    <!--</md-tooltip>-->\n                                </span>\n                                <span ng-if=\"task.lang\">\n                                    <md-button aria-label=\"viewCode\"\n                                               ng-click=\"ctrl.viewCodeResponse(task, ctrl.solutions[participant.$id][task.$id])\">\n                                        view code\n                                    </md-button>\n                                </span>\n                                <span ng-if=\"task.toEdit\">\n                                    <div>{{ctrl.solutions[participant.$id][task.$id] | showSchool}}</div>\n                                </span>\n                            </span>\n\n                        <span ng-if=\"!task.showLinks\">\n                                Completed\n                            </span>\n                    </div>\n                </td>\n                <!--for team activity (temporary)\n                <td>\n                </td>\n                <td>\n                </td>\n                <td>\n                </td>-->\n            </tr>\n\n            <tr ng-if=\"ctrl.participantsView | spfEmpty\">\n                <td>No<span ng-if=\"ctrl.ctrl.currentUserParticipant\"> other</span> participants</td>\n            </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOptions\" class=\"md-padding\"></clm-pager>\n</div>";eventTableRankTmpl="<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n<div ng-if=\"!ctrl.loading\">\n    <md-content class=\"md-padding\">\n        <button ng-show=\"ctrl.event.owner.publicId==ctrl.profile.$id\" type=\"submit\" ng-click=\"ctrl.updateAllParticipantUserProfiles()\">Update All User Achievements</button>\n        <table class=\"events ranking\">\n            <thead>\n                <tr ng-class=\"{'reversed': ctrl.orderOpts[0].reversed, secondaryReversed: ctrl.orderOpts[1].reversed}\">\n                    <th></th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'name', secondaryOrderer: ctrl.orderOpts[1].key == 'name'}\">\n                        <md-button ng-click=\"ctrl.orderBy('name')\">Participants</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'schoolName', secondaryOrderer: ctrl.orderOpts[1].key == 'schoolName'}\" ng-if=\"ctrl.event.schoolEvent\">\n                        <md-button ng-click=\"ctrl.orderBy('schoolName')\">School</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'schoolRank', secondaryOrderer: ctrl.orderOpts[1].key == 'schoolRank'}\" ng-if=\"ctrl.event.schoolEvent\">\n                        <md-button ng-click=\"ctrl.orderBy('schoolRank')\">Rank in School</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'total', secondaryOrderer: ctrl.orderOpts[1].key == 'total'}\">\n                        <md-button ng-click=\"ctrl.orderBy('total')\">Total</md-button>\n                    </th>\n                    <!-- add from rankedServices list -->\n                    <th ng-repeat=\"service in ctrl.rankedServices\" ng-class=\"{orderer: ctrl.orderOpts[0].key == service.id, secondaryOrderer: ctrl.orderOpts[1].key == service.id}\">\n                        <md-button ng-click=\"ctrl.orderBy(service.id)\">{{service.name}}</md-button>\n                    </th>\n  \n                    <!-- Legacy approach to remove. \n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'codeCombat', secondaryOrderer: ctrl.orderOpts[1].key == 'codeCombat'}\">\n                        <md-button ng-click=\"ctrl.orderBy('codeCombat')\">Code Combat Levels</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'codeSchool', secondaryOrderer: ctrl.orderOpts[1].key == 'codeSchool'}\">\n                        <md-button ng-click=\"ctrl.orderBy('codeSchool')\">Code School Badges</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'singPath', secondaryOrderer: ctrl.orderOpts[1].key == 'singPath'}\">\n                        <md-button ng-click=\"ctrl.orderBy('singPath')\">SingPath Problems</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'freeCodeCamp', secondaryOrderer: ctrl.orderOpts[1].key == 'freeCodeCamp'}\">\n                        <md-button ng-click=\"ctrl.orderBy('freeCodeCamp')\">FreeCodeCamp</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == 'codeVantage', secondaryOrderer: ctrl.orderOpts[1].key == 'codeVantage'}\">\n                        <md-button ng-click=\"ctrl.orderBy('codeVantage')\">CodeVantage</md-button>\n                    </th>\n                    -->\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <th colspan=\"5\" ng-if=\"(ctrl.rankingView2|spfEmpty)\">\n                        No participants\n                    </th> \n                </tr>\n\n                <tr ng-if=\"ctrl.currentUserRanking &amp;&amp; (ctrl.currentUserRanking.$ranking - 1) < ctrl.pagerOpts.range.start\">\n                    <th>\n                        {{ ctrl.currentUserRanking.$ranking }}\n                    </th>\n                    <th>\n                        <!-- spfToArray adds the $$hashKey property to every element in the object -->\n                        <md-button class=\"name-button\" \n                            ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserRanking.$$hashKey} }}\"\n                            ng-attr-aria-label=\"profile of {{ctrl.currentUserRanking.user.displayName}}\"\n                        >\n                            Yourself\n                        </md-button>\n                    </th>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ ctrl.currentUserRanking.user.school.name }}</td>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ ctrl.currentUserRanking.$rankInSchool || 'N/A'}}</td>\n                    <td>{{ ctrl.currentUserRanking.total || 0}}</td>\n\n                    <td ng-repeat=\"service in ctrl.rankedServices\">{{ ctrl.currentUserRanking[service.id] || 0 }}</td>\n                    <!--\n                    <td>{{ ctrl.currentUserRanking.codeCombat || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.codeSchool || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.singPath || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.freeCodeCamp || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.pivotalExpert || 0 }}</td>\n                    --> \n                </tr>\n\n                <tr ng-repeat=\"participant in ctrl.rankingView2 | orderBy : ctrl.orderOpts[0].key:ctrl.orderOpts[0].reversed\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                        {{$index+1}}\n                    </th>\n                    <th>\n                        <!-- spfToArray adds the $$hashKey property to every element in the object -->\n                        <md-button class=\"name-button\" \n                            ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\"\n                            ng-attr-aria-label=\"profile of {{participant.user.displayName}}\"\n                        >\n                            <span ng-if=\"participant.$id != ctrl.profile.$id\">{{ participant.user.displayName }}</span>\n                            <span ng-if=\"participant.$id == ctrl.profile.$id\">Yourself</span>\n                        </md-button>\n                    </th>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ participant.user.school.name }}</td>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ participant.$rankInSchool || 'N/A'}}</td>\n                    <td>{{ participant.total || 0}}</td>\n                    \n                    <td ng-repeat=\"service in ctrl.rankedServices\">{{ participant[service.id] || 0 }}</td>\n                    <!--\n                    <td>{{ participant.codeCombat || 0 }}</td>\n                    <td>{{ participant.codeSchool || 0 }}</td>\n                    <td>{{ participant.singPath || 0 }}</td>\n                    <td>{{ participant.freeCodeCamp || 0 }}</td>\n                    <td>{{ participant.codeVantage || 0 }}</td>\n                    -->\n                </tr>\n\n                <tr ng-if=\"ctrl.currentUserRanking &amp;&amp; ctrl.currentUserRanking.$ranking > ctrl.pagerOpts.range.end\">\n                    <th>\n                        {{ ctrl.currentUserRanking.$ranking }}\n                    </th>\n                    <th>\n                        <!-- spfToArray adds the $$hashKey property to every element in the object -->\n                        <md-button class=\"name-button\" \n                            ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserRanking.$$hashKey} }}\"\n                            ng-attr-aria-label=\"profile of {{ctrl.currentUserRanking.user.displayName}}\"\n                        >\n                            Yourself\n                        </md-button>\n                    </th>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ ctrl.currentUserRanking.user.school.name }}</td>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ ctrl.currentUserRanking.$rankInSchool || 'N/A'}}</td>\n                    <td>{{ ctrl.currentUserRanking.total || 0}}</td>\n                    <td>{{ ctrl.currentUserRanking.codeCombat || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.codeSchool || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.singPath || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.freeCodeCamp || 0 }}</td>\n                    <td>{{ ctrl.currentUserRanking.codeVantage || 0 }}</td>\n                </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOpts\" class=\"md-padding\"></clm-pager>\n</div>";eventTableResultsTmpl="<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n\n<div ng-if=\"!ctrl.loading\">\n\n    <md-content class=\"md-padding\">\n        <table class=\"events tasks\">\n            <thead>\n            <tr ng-class=\"{'reversed': ctrl.orderOptions.reversed}\">\n                <th rowspan=\"4\" ng-class=\"{orderer: !ctrl.orderOptions.key}\">\n                    <md-button ng-click=\"ctrl.orderBy()\">Participants</md-button>\n                </th>\n                <th rowspan=\"8\">\n                    Submission\n                    {{ctrl.taskCompletion[ctrl.selected.$id] | number: 0}} %\n                </th>\n                <th rowspan=\"8\" ng-class=\"{orderer: ctrl.orderOptions.key == ctrl.selected.$id}\">\n                    <md-button ng-click=\"ctrl.orderBy(ctrl.selected.$id)\">Allocated Points</md-button>\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n\n            <tr ng-repeat=\"participant in ctrl.participantsView track by participant.$id\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                <th layout=\"row\" layout-align=\"start center\" ng-if=\"ctrl.currentUserParticipant.$id === participant.$id\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserParticipant.$id} }}\">\n                        Yourself\n                    </md-button>\n\n                    <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Update\" ng-click=\"ctrl.update(ctrl.event, ctrl.tasks, ctrl.currentUserSolutions, ctrl.profile)\">\n                        <md-icon md-svg-icon=\"loop\"></md-icon>\n                    </md-button>\n                </th>\n\n                <th layout=\"row\" layout-align=\"start center\" ng-if=\"ctrl.currentUserParticipant.$id !== participant.$id\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\">\n                        {{ participant.user.displayName }}\n                    </md-button>\n\n                    <span ng-if=\"ctrl.profile.$id == ctrl.event.owner.publicId &amp;&amp; participant.$id != ctrl.profile.$id\">\n                            <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Delete\" ng-click=\"ctrl.removeParticipant($event, ctrl.event, participant)\">\n                                <md-icon md-svg-icon=\"clear\"></md-icon>\n                            </md-button>\n                        </span>\n                </th>\n\n                <td>\n                    <!--<div ng-if=\"ctrl.selected.serviceId\">-->\n                            <!--<span ng-if=\"ctrl.currentUserSolutions[task.$id]\">-->\n                                <!--Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>-->\n                            <!--</span>-->\n                        <!--<span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">-->\n                                <!--<md-button class=\"md-raised md-primary\"-->\n                                           <!--ng-href=\"{{ctrl.startLink(task, ctrl.profile)}}\"-->\n                                           <!--target=\"_blank\"-->\n                                           <!--ng-disabled=\"task.closedAt\"-->\n                                           <!--aria-label=\"Start challenge\"-->\n                                <!--&gt;-->\n                                    <!--<span ng-switch on=\"ctrl.mustRegister(task, ctrl.profile)\">-->\n                                        <!--<span ng-switch-when=\"true\">Register</span>-->\n                                        <!--<span ng-switch-default>Start challenge</span>-->\n                                    <!--</span>-->\n                                <!--</md-button>-->\n                            <!--</span>-->\n                    <!--</div>-->\n                    <div ng-if=\"ctrl.selected.mcqQuestions\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update response\"\n                                       ng-click=\"ctrl.viewMultipleChoiceResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Submission\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.textResponse && !ctrl.selected.lang\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            {{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 140 }}<br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update response\"\n                                       ng-click=\"ctrl.viewTextResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Response\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.textResponse && ctrl.selected.lang\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            {{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 140 }}<br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update response\"\n                                       ng-click=\"ctrl.viewCodeResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Code\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.linkPattern\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            <a href={{ctrl.solutions[participant.$id][ctrl.selected.$id]}}>{{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 50 }}</a>\n                            <br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update link\"\n                                       ng-click=\"ctrl.viewLink(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >\n                                View Link\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                                No Submission\n                        </span>\n                    </div>\n                </td>\n                <td>\n                    <!--{{ctrl.scores[participant.$id][ctrl.selected.$id]}}-->\n                    <md-input-container flex ng-disabled=\"ctrl.selected.mcqQuestions\">\n                        <label for=\"edit-task-score\">Score</label>\n                        <input ng-disabled=\"ctrl.selected.mcqQuestions\" type=\"number\" name=\"editTaskScore\" id=\"edit-task-score\"\n\n                               ng-model=\"ctrl.scores[participant.$id][ctrl.selected.$id]\"\n                               min=\"0\" step=\"1\"\n                               placeholder=\"Allocate task score\"\n\n                        />\n                        <div ng-messages=\"editTask.editTaskScore.$error\">\n                            <div ng-message=\"number\">The priority should be a positive number.</div>\n                        </div>\n                    </md-input-container>\n                    <md-button ng-show=\"!ctrl.selected.mcqQuestions\" class=\"md-raised md-primary\"\n                               aria-label=\"Save Score\"\n                               ng-click=\"ctrl.saveAllocatedPoints(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.scores[participant.$id][ctrl.selected.$id])\"\n                    >\n                        Save\n                    </md-button>\n                </td>\n            </tr>\n\n            <tr ng-if=\"ctrl.participantsView | spfEmpty\">\n                <td>No<span ng-if=\"ctrl.ctrl.currentUserParticipant\"> other</span> participants</td>\n            </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOptions\" class=\"md-padding\"></clm-pager>\n</div>";eventTaskFormTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editTask\" ng-submit=\"ctrl.saveTask(ctrl.event, ctrl.taskId, ctrl.task, ctrl.taskType, ctrl.isOpen, editTask)\">\n        <div>\n            <div layout=\"row\">\n                <md-input-container flex>\n                    <label for=\"edit-task-name\">Name</label>\n                    <input type=\"text\" name=\"editTaskTitle\" id=\"edit-task-name\"\n\n                        ng-model=\"ctrl.task.title\"\n                        required=\"required\" ng-minLength=\"3\" md-maxLength=\"30\"\n                        placeholder=\"Challenge name\" value=\"{{ctrl.task.title}}\"\n\n                    />\n\n                    <div ng-messages=\"editTask.editTaskTitle.$error\">\n                        <div ng-message=\"required\">A challenge needs a name.</div>\n                        <div ng-message=\"minlength\">The name is too short.</div>\n                        <div ng-message=\"md-maxlength\">The name is too long.</div>\n                    </div>\n                </md-input-container>\n                <md-input-container flex>\n                    <label for=\"edit-task-priority\">Priority</label>\n                    <input type=\"number\" name=\"editTaskPriority\" id=\"edit-task-priority\"\n\n                        ng-model=\"ctrl.task.priority\"\n                        min=\"0\" step=\"1\"\n                        placeholer=\"Challenge priority\" value=\"{{ctrl.task.priority}}\"\n\n                    />\n                    <div ng-messages=\"editTask.editTaskPriority.$error\">\n                        <div ng-message=\"number\">The priority should be a positive number.</div>\n                    </div>\n                </md-input-container>\n            </div>\n        </div>\n\n        <div>\n            <md-input-container class=\"md-block\" flex>\n                <label for=\"edit-task-desc\">Description</label>\n                <textarea name=\"editTaskDesc\" id=\"edit-task-desc\"\n                    ng-model=\"ctrl.task.description\"\n                    required=\"required\" ng-minLength=\"3\" md-maxLength=\"200\"\n                    placeholder=\"Challenge description\"\n                >{{ctrl.task.description}}</textarea>\n\n\n                <div ng-messages=\"editTask.editTaskDesc.$error\">\n                    <div ng-message=\"required\">A challenge needs a description.</div>\n                    <div ng-message=\"minlength\">The description is too short.</div>\n                    <div ng-message=\"md-maxlength\">The description is too long.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div>\n            <md-input-container>\n                <label for=\"edit-task-link\">Help Link</label>\n                <input type=\"text\" name=\"editTaskLink\" id=\"edit-task-link\"\n\n                    ng-model=\"ctrl.task.link\"\n                    pattern=\"^(https?://.+|#/).+$\"\n                    placeholder=\"URL to a challenge help page\" value=\"{{ctrl.task.link}}\"\n\n                />\n                <div ng-messages=\"editTask.editTaskLink.$error\">\n                    <div ng-message=\"pattern\">Wrong format for an absolute or relative URL.</div>\n                </div>\n            </md-input-container>\n        </div>\n            <md-switch class=\"md-primary\" ng-model=\"ctrl.enableBeta\" aria-label=\"closed?\">\n                *Enable BETA functions (WARNING: MAY BREAK STUFF)\n            </md-switch>\n        <div>\n            <h3>options</h3>\n            <p>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.isOpen\" aria-label=\"closed?\">\n                    Open\n                </md-switch>\n            </p>\n            <p>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.hidden\" aria-label=\"hidden?\">\n                    Hide\n                </md-switch>\n            </p>\n\n            <p>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.archived\" aria-label=\"Archived?\">\n                    Archived\n                </md-switch>\n            </p>\n\n            <p>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.showProgress\" aria-label=\"show progress?\">\n                    Show all participant progress.\n                </md-switch>\n            </p>\n\n            <p>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.showLinks\" aria-label=\"closed?\">\n                    Show all participant solutions.\n                </md-switch>\n            </p>\n\n        </div>\n\n        <div>\n            <h3>Task type <small ng-if=\"!ctrl.taskType\">(Required)</small></h3>\n            <md-radio-group ng-model=\"ctrl.taskType\">\n                <table>\n                    <tr>\n                        <td style=' padding-bottom:80px;'>\n                            <md-radio-button value=\"service\" class=\"md-primary\">Service / Badge / Problem</md-radio-button>\n                            <md-radio-button value=\"linkPattern\" class=\"md-primary\">Link pattern</md-radio-button>\n                            <md-radio-button value=\"textResponse\" class=\"md-primary\">Text Response</md-radio-button>\n                            <md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"multipleChoice\" class=\"md-primary\">Multiple Choice*</md-radio-button>\n                            <md-radio-button value=\"code\" class=\"md-primary\">Code</md-radio-button>\n                        </td>\n                        <td style='padding-left:30px; padding-bottom:80px;'>\n                            <md-radio-button value=\"profileEdit\" class=\"md-primary\">Profile Update</md-radio-button>\n                            <md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"video\" class=\"md-primary\">Video*</md-radio-button>\n                            <md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"journalling\" class=\"md-primary\">Journalling*</md-radio-button>\n                            <md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"survey\" class=\"md-primary\">Survey*</md-radio-button>\n                            <md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"teamActivity\" class=\"md-primary\">Team Activity*</md-radio-button>\n                        </td>\n                    </tr>\n                </table>\n            </md-radio-group>\n        </div>\n        <div layout=\"row\" ng-if=\"ctrl.taskType == 'service'\">\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editTaskServiceId\"\n                           ng-model=\"ctrl.task.serviceId\" required placeholder=\"Select a Service\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ['codeSchool', 'codeCombat', 'treeHouse', 'singPath']\">\n                        {{opt}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskServiceId.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.serviceId &amp;&amp; ctrl.task.serviceId != 'singPath'\">\n                <md-select flex name=\"editTaskBadge\"\n                           ng-model=\"ctrl.task.badge\"\n                           placeholder=\"Select a badge (optional)\"\n                >\n                    <md-option ng-value=\"badge\" ng-repeat=\"badge in ctrl.badges[ctrl.task.serviceId]\">\n                        {{badge.name}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n        </div>\n\n        <div layout=\"row\" ng-if=\"ctrl.task.serviceId == 'singPath'\">\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editTaskSingPathPath\"\n                           ng-model=\"ctrl.task.singPathProblem.path\"\n                           placeholder=\"Select a Path (optional)\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.paths\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.singPathProblem.path\">\n                <md-select flex name=\"editTaskSingPathLevel\"\n                           ng-model=\"ctrl.task.singPathProblem.level\"\n                           required\n                           md-on-open=\"ctrl.loadLevels(ctrl.task.singPathProblem)\"\n                           placeholder=\"Select a Level\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.levels\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskSingPathLevel.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.singPathProblem.level\">\n                <md-select flex name=\"editTaskSingPathProblem\"\n                           ng-model=\"ctrl.task.singPathProblem.problem\"\n                           required\n                           md-on-open=\"ctrl.loadProblems(ctrl.task.singPathProblem)\"\n                           placeholder=\"Select a Problem\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.problems\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskSingPathProblem.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'linkPattern'\">\n            <md-input-container>\n                <label for=\"edit-link-pattern\">Link pattern</label>\n                <input type=\"text\" name=\"editTaskLink\" id=\"edit-link-pattern\"\n\n                    ng-model=\"ctrl.task.linkPattern\"\n                    required=\"true\"\n                    placeholer=\"Pattern\" value=\"{{ctrl.task.linkPattern}}\"\n\n                />\n\n                <div ng-messages=\"editTask.editTaskLink.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'textResponse'\">\n            <md-input-container>\n\n                <label for=\"edit-text-response\">Question</label>\n                <input type=\"text\" name=\"editTextResponse\" id=\"edit-text-response\"\n                    ng-model=\"ctrl.task.textResponse\"\n                    required=\"true\"\n                    placeholer=\"Question\" value=\"{{ctrl.task.textResponse}}\"\n\n                />\n\n                <div ng-messages=\"editTask.editTextResponse.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'indexCard'\">\n            <md-input-container flex>\n                <label for=\"edit-max-cards\">Maximum cards allowed</label>\n                <input type=\"number\" name=\"editMaxCards\" id=\"edit-max-cards\"\n                       ng-model=\"ctrl.task.cards\"\n                       min=\"0\" step=\"1\"\n                       placeholer=\"index Cards\" value=\"{{ctrl.task.cards}}\"\n                />\n                <div ng-messages=\"editTask.editTaskPriority.$error\">\n                    <div ng-message=\"number\">The max cards allowed should be a positive number.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n\n        <div ng-if=\"ctrl.taskType == 'code'\">\n            <md-input-container>\n                <label for=\"edit-text-response\">Question</label>\n                <input type=\"text\" name=\"editCodeQuestion\" id=\"edit-code-question\"\n                       ng-model=\"ctrl.task.textResponse\"\n                       required\n                       placeholder=\"Question\" value=\"{{ctrl.task.textResponse}}\"\n                />\n\n                <div ng-messages=\"editTask.editCodeQuestion.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editCodeLang\"\n                           ng-model=\"ctrl.task.lang\" required placeholder=\"Select a Language\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ['Java', 'Javascript', 'HTML', 'Python']\">\n                        {{opt}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'video'\">\n            <md-input-container>\n                Video\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'journalling'\">\n            <md-input-container>\n                Journalling\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'profileEdit'\">\n            Select fields for participants to edit:\n            <md-list  ng-repeat=\"metaData in ['Year of Birth', 'School']\">\n                <md-checkbox ng-checked=\"ctrl.exists(metaData, ctrl.selectedMetaData)\" ng-click=\"ctrl.toggle(metaData, ctrl.selectedMetaData)\">\n                    {{metaData}}</br>\n                </md-checkbox>\n            </md-list>\n        </div>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <!--TODO: 1. Create continue button controller to route to other views depending on challenge type-->\n\n            <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"editTask.$invalid || !ctrl.taskType ||ctrl.savingTask\">{{ ctrl.challengeRouteProvider(ctrl.taskType, ctrl.task, ctrl.isOpen)}}</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.discardChanges($event)\">Back</md-button>\n\n        </div>\n    </form>\n</md-content>\n\n";eventTmpl="<md-content flex class=\"md-padding\">\n    <h3>\n        {{ctrl.event.message.comment}}\n    </h3>\n    <div ng-hide=\"ctrl.profile.joinedEvents[ctrl.event.$id]\">\n        Click +JOIN from the menu above to join this event. \n        <span ng-if=\"ctrl.event.message.password\">\n            The password is <b>{{ctrl.event.message.password}}</b>.\n        </span>\n    </div>\n    <!-- Users must finish registering before joining events -->\n    <md-content ng-if=\"ctrl.currentUser &amp;&amp; !ctrl.profile\" layout-padding>\n        <md-divider></md-divider>\n        <p>To join this event, you first need to finish registering:</p>\n\n        <form name=\"registerForm\" ng-submit=\"ctrl.register(ctrl.currentUser, registerForm)\">\n            <spf-sign-form current-user=\"ctrl.currentUser\"></spf-sign-form>\n\n            <div layout=\"row\" layout-align=\"center center\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"registerForm.$invalid\">\n                    Save\n                </md-button>\n            </div>\n        </form>\n    </md-content>\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\">\n\n        <md-tab label=\"Ranking\">\n            <md-content layout-padding>\n                <clm-event-rank-table\n                    event=\"ctrl.event\"\n                    profile=\"ctrl.profile\"\n                    assistants=\"ctrl.asstArr\"\n                ></clm-event-rank-table>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Challenges\" ng-disabled=\"!ctrl.participants\">\n            <md-content layout-padding>\n                <clm-event-table\n                    ng-if=\"ctrl.canView\"\n                    event=\"ctrl.event\"\n                    participants=\"ctrl.participants\"\n                    tasks=\"ctrl.tasks\"\n                    progress=\"ctrl.progress\"\n                    solutions=\"ctrl.solutions\"\n                    profile=\"ctrl.profile\"\n                >\n                </clm-event-table>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Results\" ng-disabled=\"!ctrl.participants || !ctrl.isReviewSuperUser\">\n            <md-content layout-padding>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.viewArchived\" aria-label=\"ViewArchived?\">\n                    View archived challenges\n                </md-switch>\n                <md-input-container flex layout=\"column\">\n                    <md-select flex name=\"selectChallengeResult\"\n                               ng-model=\"ctrl.selected\" required placeholder=\"Select a challenge to view results\">\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.startIRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived)\">\n                            {{task.title}} (IRAT)\n                        </md-option>\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.startTRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived)\">\n                            {{task.title}} (TRAT)\n                        </md-option>\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"!task.startTRAT && !task.startIRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived)\">\n                            {{task.title}}\n                        </md-option>\n                    </md-select>\n                </md-input-container>\n                <div ng-show=\"ctrl.selected\">\n                    <h2 align=\"center\">Showing Results for {{ctrl.selected.title}}</h2>\n                    <div align=\"center\">Description: {{ctrl.selected.description}}</div></br>\n                    <div ng-if=\"ctrl.selected.textResponse\" align=\"center\">Question: {{ctrl.selected.textResponse}}</div>\n                    </br></br>\n                    Event Answers:\n                </div>\n                <div ng-show=\"ctrl.selected\">\n                    <md-content layout-padding>\n                        <clm-event-results-table\n                                ng-if=\"ctrl.canView\"\n                                event=\"ctrl.event\"\n                                participants=\"ctrl.participants\"\n                                tasks=\"ctrl.tasks\"\n                                progress=\"ctrl.progress\"\n                                solutions=\"ctrl.solutions\"\n                                profile=\"ctrl.profile\"\n                                selected=\"ctrl.selected\"\n                                scores=\"ctrl.scores\"\n                        >\n                        </clm-event-results-table>\n                    </md-content>\n                </div>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n\n</md-content>";listTmpl="<md-content flex class=\"md-padding\">\n\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\">\n        <md-tab label=\"Featured Events\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.events.length }} featured event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"e in (ctrl.events | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{e.owner.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n        \n        <md-tab label=\"Created Events\" ng-disabled=\"!ctrl.currentUser\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.createdEvents.length }} created event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"e in (ctrl.createdEvents | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{ctrl.currentUser.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Joined Events\" ng-disabled=\"!ctrl.currentUser\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.joinedEvents.length }} joined event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"e in (ctrl.joinedEvents | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{e.owner.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n    </md-tabs>\n\n</md-content>\n";newTmpl="<md-content class=\"md-padding\">\n    <form name=\"newEventForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.newEvent.data, ctrl.newEvent.password, newEventForm)\">\n        <spf-sign-form current-user=\"ctrl.currentUser\" ng-if=\"ctrl.profileNeedsUpdate\"></spf-sign-form>\n\n        <md-input-container>\n            <label for=\"event-title\">Event Name</label>\n            <input name=\"eventTitle\" type=\"text\" id=\"event-title\" ng-model=\"ctrl.newEvent.data.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required=\"true\"/>\n            <div ng-messages=\"newEventForm.eventTitle.$error\">\n                <div ng-message=\"required\">An event should have a name.</div>\n                <div ng-message=\"minlength\">An event name shouldn't be shorten than 3 characters.</div>\n                <div ng-message=\"maxlength\">An event name shouldn't be longer than 60 characters.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container>\n            <label for=\"event-pw\">Event Password</label>\n            <input name=\"eventPw\" type=\"text\" id=\"event-pw\" required ng-model=\"ctrl.newEvent.password\" />\n            <div ng-messages=\"newEventForm.eventPw.$error\">\n                <div ng-message=\"required\">An event should have a password.</div>\n            </div>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.creatingEvent\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-primary\" ng-disabled=\"newEventForm.$invalid || ctrl.creatingEvent\">Create</md-button>\n            <md-button type=\"reset\" ng-click=\"ctrl.reset(newEventForm)\" ng-disabled=\"ctrl.creatingEvent || newEventForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n</md-content>\n";pagerTmpl="<md-content layout=\"row\" layout-align=\"start center\">\n    <span flex></span>\n    \n    <span class=\"label md-padding\">Row per page: </span>\n    <md-select ng-model=\"ctrl.rowPerPage.value\" ng-change=\"ctrl.rowPerPage.set(ctrl.rowPerPage.value)\" aria-label=\"row per page\">\n        <md-option value=\"{{opt}}\" ng-repeat=\"opt in ctrl.rowPerPage.options\">{{opt}}</md-option>\n    </md-select>\n\n    <span class=\"md-padding\">\n        {{ ctrl.options.range.start }} - {{ ctrl.options.range.end }} of\n        {{ ctrl.options.rowCount }}\n    </span>\n\n    <md-button title=\"First page\" aria-label=\"first page\" class=\"md-icon-button\" ng-click=\"ctrl.firstPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.start == 0\">\n        <md-icon md-svg-icon=\"arrow-back\"></md-icon>\n    </md-button>\n\n    <md-button title=\"Previous page\" aria-label=\"previous page\" class=\"md-icon-button\" ng-click=\"ctrl.prevPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.start == 0\">\n        <md-icon md-svg-icon=\"keyboard-arrow-left\"></md-icon>\n    </md-button>\n    \n    <md-button title=\"Next page\" aria-label=\"next page\" class=\"md-icon-button\" ng-click=\"ctrl.nextPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.end >= ctrl.options.rowCount\">\n        <md-icon md-svg-icon=\"keyboard-arrow-right\"></md-icon>\n    </md-button>\n\n    <md-button title=\"Last page\" aria-label=\"last page\" class=\"md-icon-button\" ng-click=\"ctrl.lastPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.end >= ctrl.options.rowCount\">\n        <md-icon md-svg-icon=\"arrow-forward\"></md-icon>\n    </md-button>\n</md-content>";passwordTmpl="<md-dialog aria-label=\"Prompt password\">\n    <form name=\"promptPassword\" ng-submit=\"ctrl.join(ctrl.pw)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">Event password</md-subheader>\n            <div>\n                <md-input-container>\n                    <label for=\"edit-task-name\">Password</label>\n                    <input type=\"password\" name=\"editTaskTitle\" id=\"edit-task-name\"\n                        ng-model=\"ctrl.pw\"\n                        required=\"required\"\n                        placeholer=\"Event password\"\n                        />\n                </md-input-container>\n            </div>\n    \n            <div class=\"md-dialog-actions\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\">\n                    Ok\n                </md-button>\n                <md-button ng-click=\"ctrl.closeDialog()\" type=\"button\" class=\"md-accent\">\n                    Cancel\n                </md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";linkTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" ng-class=\"{false:'enlarged-dialog', true:'link-dialog'}[!ctrl.review]\">\n    <form name=\"provideLinkForm\" ng-submit=\"ctrl.save(ctrl.solution)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div ng-if=\"!ctrl.review\">\n                <p>{{ctrl.task.description}}</p>\n                <md-input-container class=\"md-block\" flex>\n                    <label for=\"edit-solution-link\">Solution Link</label>\n                    <input type=\"text\" name=\"linkSolution\" id=\"edit-solution-link\"\n                        ng-model=\"ctrl.solution\"\n                        required\n                        cm-contains=\"ctrl.task.linkPattern\"\n                        placeholder=\"URL to provide\"\n                    >\n                    <div ng-messages=\"provideLinkForm.linkSolution.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                        <div ng-message=\"cmContains\">Invalid pattern.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div ng-if=\"ctrl.review\" layout-align=\"center\">\n                Submitted Link by {{ctrl.participant.user.displayName}}: <br>\n                <a href={{ctrl.solution}}>{{ctrl.solution}}</a>\n                <div class=\"box\" flex>\n                <iframe ng-src=\"{{ctrl.solution}}\" target=\"_parent\" width = \"800px\" height = \"700px\"></iframe>\n                </div>\n            </div>\n            <div class=\"md-dialog-actions\" layout=\"row\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-if=\"!ctrl.review\" ng-disabled=\"!provideLinkForm.$valid\">\n                    Save\n                </md-button>\n                <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";responseTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"provideResponseForm\" ng-submit=\"ctrl.save(ctrl.solution)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div>\n                <p>{{ctrl.task.description}}</p>\n                <md-input-container class=\"md-block\" ng-show=\"!ctrl.viewOnly\">\n                    <label for=\"edit-solution-response\">{{ctrl.task.textResponse}}</label>\n                    <textarea name=\"solution\" id=\"edit-solution-response\"\n                              ng-model=\"ctrl.solution\"\n                              required md-select-on-focus>\n                    </textarea>\n                    <div ng-messages=\"provideResponseForm.linkSolution.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div ng-show=\"ctrl.viewOnly\">\n                <md-divider></md-divider>\n                <!--<md-input-container class=\"md-block\">-->\n                    <!--<label for=\"view-solution-response\">{{ctrl.task.textResponse}}</label><br><br>-->\n                    <!--<textarea name=\"linkSolution\" id=\"view-solution-response\"-->\n                              <!--ng-model=\"ctrl.solution\"-->\n                              <!--required rows=\"3\" readonly>-->\n                    <!--</textarea>-->\n                <!--</md-input-container>-->\n                <div style=\"white-space: pre-wrap;\">{{ctrl.solution}}</div>\n                <md-divider></md-divider>\n            </div>\n            <div class=\"md-dialog-actions\" layout=\"row\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!provideResponseForm.$valid\">\n                    Save\n                </md-button>\n                <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n\n    </form>\n</md-dialog>\n";editProfileTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"editProfileForm\" ng-submit=\"ctrl.save()\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <p>{{ctrl.task.description}}</p>\n            <!--<div ng-repeat=\"toEdit in ctrl.task.toEdit\" ng-if=\"!ctrl.participantInfo[ctrl.camelText(toEdit)]\">-->\n            <div ng-repeat=\"toEdit in ctrl.task.toEdit\">\n                Please input your {{toEdit}}\n                <div ng-if=\"ctrl.camelText(toEdit)==='yearOfBirth'\">\n                    <md-select ng-model=\"ctrl.userData.yearOfBirth\" aria-label=\"select_yob\" required placeholder=\"Select your year of birth\">\n                        <md-option ng-value=\"year\" ng-repeat=\"year in ctrl.yearOpts\">\n                            {{year}}\n                        </md-option>\n                    </md-select>\n                </div>\n                <!--<div ng-if=\"ctrl.camelText(toEdit)==='country'\">-->\n                    <!--Editing Country.-->\n                <!--</div>-->\n                <div ng-if=\"ctrl.camelText(toEdit)==='school'\">\n                    <md-select ng-model=\"ctrl.userData.school\" aria-label=\"select_school\" required placeholder=\"Select your school\">\n                        <md-option ng-value=\"school\" ng-repeat=\"school in ctrl.schools\">\n                            {{school.name}}\n                        </md-option>\n                    </md-select>\n                </div>\n            </div>\n            <md-dialog-actions layout=\"row\" layout-align=\"center end\">\n                <div>\n                    <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!editProfileForm.$valid\">\n                        Save\n                    </md-button>\n                </div>\n                <div>\n                    <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n                </div>\n            </md-dialog-actions>\n        </md-dialog-content>\n    </form>\n</md-dialog>";codeTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"provideResponseForm\" ng-submit=\"ctrl.save()\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div>\n                <p>{{ctrl.task.description}}</p>\n                <p>{{ctrl.task.textResponse}}</p>\n                <p>Language: {{ctrl.task.lang}}</p>\n                <div layout=\"row\" layout-sm=\"column\" layout-align=\"space-around\" ng-if=\"ctrl.checkEditor()\">\n                    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n                </div>\n                <div id=\"editor\" ng-show=\"!ctrl.checkEditor()\">{{ctrl.solution}}</div>\n            </div>\n            <md-dialog-actions layout=\"row\" layout-align=\"center end\">\n                <div>\n                    <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!provideResponseForm.$valid\">\n                        Save\n                    </md-button>\n                </div>\n                <div>\n                    <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n                </div>\n            </md-dialog-actions>\n        </md-dialog-content>\n    </form>\n</md-dialog>";mcqTmpl$1="<md-dialog flex layout-padding aria-label=\"{{ctrl.task.title}}\">\n    <md-dialog-content>\n        <div layout='column' align=\"center\">\n    <h3>Multiple Choice</h3>\n    <h4>Title: {{ctrl.task.title}}</h4>\n    <h4>Description: {{ctrl.task.description}}</h4>\n    <br>\n  </div>\n\n  <form name=\"startMcq\" ng-submit=\"ctrl.submit()\">\n  <div layout-align=\"column\">\n\n      <!------------------starting of questions--------------------------------------------->\n      <div flex ng-repeat=\"question in ctrl.questions\">\n        <div align=\"start\" layout=\"column\" >\n          <label><h2>Question {{$index + 1}}</h2></label>\n          <md-divider></md-divider>\n          <label><h4>{{question.text}}</h4></label>\n        </div>\n\n        <!--answer's options-->\n        <div ng-show=\"!ctrl.show(question.answers)\">\n          <md-radio-group ng-model=\"question.answers\">\n            <div layout=\"column\" ng-repeat=\"option in question.options\">\n              <div layout=\"row\">\n                <div flex=\"80\">\n                  <label>{{$index + 1}}) {{option.text}}</label>\n                </div>\n                <div flex=\"20\">\n                  <md-radio-button ng-disabled=\"true\" value={{$index}} ng-checked=\"ctrl.isChecked(question.answers, $index)\"></md-radio-button>\n                </div>\n              </div>\n              <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n            </div>\n          </md-radio-group>\n        </div>\n\n        <div ng-show=\"ctrl.show(question.answers)\">\n          <div layout=\"column\" ng-repeat=\"option in question.options\">\n            <div layout=\"row\">\n              <div flex=\"80\">\n                <label>{{$index + 1}}) {{option.text}}</label>\n              </div>\n              <div flex=\"20\">\n                <md-checkbox ng-disabled=\"true\" ng-checked=\"ctrl.isChecked(question.answers, $index)\"></md-checkbox>\n              </div>\n            </div>\n            <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n          </div>\n        </div>\n        <!--<div align=\"center\" layout=\"row\" ng-repeat=\"option in question.options\" >-->\n          <!--&lt;!&ndash;single answer or no?&ndash;&gt;-->\n          <!--<div flex align=\"left\">-->\n            <!--<h4>{{option.text}}</h4>-->\n          <!--</div>-->\n          <!--<div flex=\"20\">-->\n          <!--<md-button ng-model=\"question.answers\" ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"-->\n                     <!--ng-click=\"ctrl.toggleOption(question, $index)\">Answer</md-button>-->\n          <!--</div>-->\n          <!--<div flex=\"20\" ng-show=\"ctrl.multipleAns[$parent.$index]\">-->\n\n          <!--</div>-->\n          <!--<div flex=\"20\" ng-show=\"!ctrl.multipleAns[$parent.$index]\">-->\n            <!--<input type=\"radio\" name=\"answer\" value=\"$index\"/>-->\n          <!--</div>-->\n            <!--<md-divider ng-if=\"!$last\"></md-divider>-->\n        <!--</div>-->\n      </div>\n\n\n  </div>\n  <br/>\n  <div layout=\"row\" layout-align=\"center center\">\n    <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.cancel()\">Cancel</md-button>\n  </div>\n  </form>\n    </md-dialog-content>\n</md-dialog>\n";schEngageScaleTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"ctrl.submitSchEngageResponse(ctrl.schEngageResp)\">\n        <div>\n            <h1>School Engagement Scale</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale</h3>\n        </div>\n\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <md-input container flex>\n            <table ng-repeat=\"(key, value) in ctrl.questions[2]\" width=\"100%\">\n                <tr ng-if=\"key == 1\">\n                    <td>\n                        <h3>Behavioural Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 5\">\n                    <td>\n                        <h3>Emotional Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 11\">\n                    <td>\n                        <h3>Cognitive Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <td ng-if=\"key != '0'\" style=\"width: 600px\">\n                        {{key}}. {{value}}\n                    </td>\n                    <td ng-if=\"key != '0'\">\n                        <md-radio-group layout=\"row\" ng-model=\"$parent.ans\" ng-change=\"ctrl.schEngageResp[key] = ans\" required>\n                            <div ng-repeat=\"(key2, value2) in ctrl.responseRating\">\n                                <md-radio-button style=\"margin-right:20px\" class=\"md-primary\"\n                                                 ng-value=\"value2.option\">\n                                    {{value2.option}}\n                                </md-radio-button>\n                            </div>\n                        </md-radio-group>\n                    </td>\n                    <!--<td ng-if=\"key != '0'\">-->\n                    <!--<md-button class=\"md-raised md-primary\" data-id=\"{{key}}\"-->\n                    <!--ng-click=\"ctrl.saveSurveyResponse(ans , $event, task.$id)\">-->\n                    <!--Save-->\n                    <!--</md-button>-->\n                    <!--</td>-->\n                </tr>\n\n            </table>\n\n\n            <br>\n\n            <table>\n                <tr>\n                    <td>\n                        <md-button type=\"submit\" ng-disabled=\"surveyForm.$invalid\" class=\"md-raised md-primary\" style=\"width: 150px;\">Submit</md-button>\n\n                    </td>\n                    <td>\n                        <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-raised md-primary\" style=\"width: 150px;\">\n                            Discard\n                        </md-button>\n                    </td>\n                </tr>\n\n            </table>\n\n        </md-input>\n    </form>\n</md-content>";motiStratLearnTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"ctrl.submitMotiStratResponse(ctrl.motiResp)\">\n\n        <div>\n            <h1>Motivated Strategies for Learning</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale:</h3>\n        </div>\n        <div><b>1= not at all true of me</b></div>\n        <div><b>7=very true of me</b></div>\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <br>\n        <md-input container flex>\n\n            <table ng-repeat=\"question in ctrl.questionsArr\" width=\"100%\">\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height: 50px\">\n                    <!--<div  style=\"height: 80px\">-->\n                    <td style=\"width:50px\">\n                        {{question.qnid}}.\n                    </td>\n                    <td style=\"width:700px\">\n                        {{question.name}}\n                    </td>\n                    <!--ng-change=\"ctrl.motiResp.push(ans)\"-->\n                    <td align=\"right\">\n                        <md-radio-group layout=\"row\" ng-model=\"ans\" ng-change=\"ctrl.motiResp[question.qnid] = ans\" required>\n                            <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                                <md-radio-button style=\"margin-right:60px\" class=\"md-primary\"\n                                                 ng-value=\"ratingOption.id\">\n                                    {{ratingOption.id}}\n                                </md-radio-button>\n                            </div>\n                        </md-radio-group>\n                    </td>\n                </tr>\n            </table>\n            <!--<clm-pager options=\"ctrl.pagerOpts\" class=\"md-padding\"></clm-pager>-->\n            <!--<pagination-->\n            <!--ng-model=\"currentPage\"-->\n            <!--total-items=\"questions.length\"-->\n            <!--max-size=\"maxSize\"-->\n            <!--boundary-links=\"true\">-->\n            <!--</pagination>-->\n            <table>\n                <tr>\n                    <td>\n                        <md-button type=\"submit\" ng-disabled=\"surveyForm.$invalid\" class=\"md-primary md-raised\">Submit</md-button>\n                    </td>\n                    <td>\n                        <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-raised md-primary\" style=\"width: 150px;\">\n                            Discard\n                        </md-button>\n                    </td>\n                </tr>\n            </table>\n\n        </md-input>\n\n        <!--<hr style=\"background: #808080; border: 0; height: 3px\"/>-->\n    </form>\n\n</md-content>\n";eduDisLearnTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\"\n          ng-submit=\"ctrl.submitEduDissResponse(ctrl.eduDissResp, ctrl.selectedFamily, ctrl.selectedRaceEthnicity)\">\n        <div>\n            <h1>Education vs Dissatisfaction with learning</h1>\n        </div>\n\n\n        <table ng-repeat=\"(key, value) in ctrl.questions[0]\" width=\"100%\">\n            <tr>\n                <td><h3>{{value.title}}</h3></td>\n            </tr>\n\n            <tr ng-if=\"key =='11'\">\n                <td>\n                    <textarea placeholder=\"Share some of your most exciting moments here!\" type=\"text\" cols=\"80\"\n                              rows=\"5\" style=\"max-width:500px; max-height: 200px\"\n                              ng-model=\"$parent.$parent.bestResponse\"\n                              ng-change=\"ctrl.eduDissResp[value.title] = bestResponse\" required></textarea>\n\n                    <!--<md-button class=\"md-raised md-primary\" data-id=\"1\"-->\n                    <!--ng-click=\"ctrl.saveEduDisResponse(ansResp , age, $event, task.$id, sib, selectedMonth, country, spokenLanguage, value.title, bestResponse)\">-->\n\n                    <!--Save-->\n                    <!--</md-button>-->\n                </td>\n            </tr>\n\n            <!--to generate questions-->\n            <tr ng-if=\"key2 != 'title'\" ng-repeat=\"(key2, value2) in value\"\n                ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height:50px\">\n                <td style=\"width:800px\">\n                    {{value2}}\n                </td>\n\n                <td>\n                    <!--to generate radio button-->\n                    <md-radio-group ng-if=\"key != '6'\" layout=\"row\" ng-model=\"$parent.ansResp\"\n                                    ng-change=\"ctrl.eduDissResp[value.title][key2] = ansResp\" required>\n                        <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                            <md-radio-button style=\"margin-right:60px\" class=\"md-primary\" ng-value=\"ratingOption.id\">\n                                {{ratingOption.id}}\n                            </md-radio-button>\n                        </div>\n                    </md-radio-group>\n                    <div ng-if=\"key == '6'\">\n                        <div ng-if=\"key2 == '1'\">\n                            <input placeholder=\"State a valid age\" ng-model=\"$parent.$parent.age\" type=\"number\" min=\"3\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = age\" required /> years old\n                        </div>\n                        <div ng-if=\"key2 == '2'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <td ng-repeat=\"family in ctrl.familyMembers track by $index\">\n                                        <md-checkbox value=\"{{family.name}}\"\n                                                     ng-click=\"ctrl.toggle(family, ctrl.selectedFamily)\"\n                                                     ng-checked=\"ctrl.exists(family, ctrl.selectedFamily)\" required>\n                                            {{family.name}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '3'\">\n                            <input placeholder=\"Number of siblings\" ng-model=\"$parent.$parent.sib\" type=\"number\" min=\"0\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = sib\" required/>\n                        </div>\n                        <div ng-if=\"key2 == '4'\">\n                            <md-input-container flex>\n                                <label>Month</label>\n                                <md-select ng-model=\"$parent.$parent.selectedMonth\"\n                                           ng-change=\"ctrl.eduDissResp[value.title][key2] = selectedMonth\" required>\n                                    <md-option ng-repeat=\"bday in ctrl.bdayMonth\" value=\"{{bday.month}}\">\n                                        {{bday.month}}\n                                    </md-option>\n                                </md-select>\n                            </md-input-container>\n                        </div>\n                        <div ng-if=\"key2 == '5'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <td ng-if=\"ethnic.firstRow\" ng-repeat=\"ethnic in ctrl.ethnicity track by $index\">\n                                        <md-checkbox ng-click=\"ctrl.toggle(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     ng-checked=\"ctrl.exists(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     value=\"{{ethnic.firstRow}}\">\n                                            {{ethnic.firstRow}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                                <tr>\n                                    <td ng-if=\"ethnic.secondRow\" ng-repeat=\"ethnic in ctrl.ethnicity track by $index\">\n                                        <md-checkbox ng-click=\"ctrl.toggle(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     ng-checked=\"ctrl.exists(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     value=\"{{ethnic.secondRow}}\">\n                                            {{ethnic.secondRow}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '6'\">\n                            <input type=\"text\" placeholder=\"State a valid country\" ng-model=\"$parent.$parent.country\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = country\" required/>\n\n                        </div>\n                        <div ng-if=\"key2 == '7'\">\n                            <input type=\"text\" placeholder=\"State a valid language\"\n                                   ng-model=\"$parent.$parent.spokenLanguage\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = spokenLanguage\" required />\n                            for multiple languages, separate by a comma (,)\n                        </div>\n\n                    </div>\n                </td>\n\n                <!--<td align=\"center\">-->\n                <!--<md-button ng-if=\"(key =='6' && key2 != '2') && (key == '6' && key2 != '5')\" class=\"md-raised md-primary\" data-id=\"{{key2}}\"-->\n                <!--ng-click=\"ctrl.saveEduDisResponse(ansResp , age, $event, task.$id, sib, selectedMonth, country, spokenLanguage, value.title)\">-->\n                <!--Save-->\n                <!--</md-button>-->\n\n                <!--<md-button ng-if=\"key !='6'\" class=\"md-raised md-primary\" data-id=\"{{key2}}\"-->\n                <!--ng-click=\"ctrl.saveEduDisResponse(ansResp , age, $event, task.$id, sib, selectedMonth, country, spokenLanguage, value.title)\">-->\n                <!--Save-->\n                <!--</md-button>-->\n\n                <!--<md-button ng-if=\"(key == '6' && key2 == '2')\" class=\"md-raised md-primary\" data-id=\"{{key2}}\"-->\n                <!--ng-click=\"ctrl.saveEduDisMultiResponse(ctrl.selectedFamily, $event, task.$id, value.title)\">-->\n                <!--Save-->\n                <!--</md-button>-->\n\n                <!--<md-button ng-if=\"(key=='6' && key2 == '5')\" class=\"md-raised md-primary\" data-id=\"{{key2}}\"-->\n                <!--ng-click=\"ctrl.saveEduDisMultiResponse(ctrl.selectedRaceEthnicity, $event, task.$id, value.title)\">-->\n                <!--Save-->\n                <!--</md-button>-->\n\n\n                <!--</td>-->\n            </tr>\n\n            <md-divider></md-divider>\n\n        </table>\n\n        <table>\n            <tr>\n                <td>\n                    <md-button ng-disabled=\"surveyForm.$invalid || ctrl.selectedRaceEthnicity.length == 0 || ctrl.selectedFamily.length == 0\" type=\"submit\" class=\"md-raised md-primary\"\n                               style=\"width: 150px;\">Submit\n                    </md-button>\n                </td>\n                <td>\n                    <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-raised md-primary\" style=\"width: 150px;\">\n                        Discard\n                    </md-button>\n                </td>\n            </tr>\n        </table>\n\n\n    </form>\n</md-content>";noop$6=function noop(){return undefined;};TIMESTAMP$1={'.sv':'timestamp'};configRoute$3.$inject=['$routeProvider','routes'];eventServiceFactory.$inject=['$q','$route','spfAuthData','clmDataStore','$log','spfAlert'];classMentorsEventResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];ClmListEvent.$inject=['initialData','spfNavBarService','urlFor'];newEventCtrlInitialData.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];NewEventCtrl.$inject=['$q','$location','initialData','urlFor','spfAuthData','spfAlert','spfNavBarService','clmDataStore'];viewEventCtrlInitialData.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ViewEventCtrl.$inject=['$scope','initialData','$document','$mdDialog','$route','spfAlert','urlFor','spfAuthData','spfNavBarService','clmDataStore'];editEventCtrllInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditEventCtrl.$inject=['initialData','spfNavBarService','urlFor','spfAlert','clmDataStore'];addEventTaskCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];AddEventTaskCtrl.$inject=['initialData','$location','$log','spfAlert','urlFor','spfNavBarService','clmDataStore','$mdDialog','$scope','eventService','clmSurvey'];editEventTaskCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditEventTaskCtrl.$inject=['initialData','spfAlert','urlFor','spfNavBarService','clmDataStore','eventService','$location','$mdDialog','$location','eventService'];ClmEventTableCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','urlFor','spfAlert','clmServicesUrl','clmDataStore','clmPagerOption','eventService','$location','routes','$route','spfAuthData','authFirebaseApp','firebaseApp','$firebaseArray','$firebaseObject'];addSurveyEventTaskCtrlInitialData.$inject=['$q','$route','firebaseApp','$firebaseArray','spfAuthData','clmDataStore'];SurveyFormFillCtrl.$inject=['spfNavBarService','$location','urlFor','initialData','$routeParams','clmDataStore','clmPagerOption','spfAlert','$scope','firebase'];ClmEventRankTableCtrl.$inject=['$scope','$log','firebaseApp','$firebaseObject','$firebaseArray','clmDataStore','clmPagerOption'];ClmEventResultsTableCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','urlFor','spfAlert','clmServicesUrl','clmDataStore','clmPagerOption','$sce'];clmRowPerPageFactory.$inject=['$log'];clmPagerOptionFactory.$inject=['$log','clmRowPerPage'];ClmPagerCtrl.$inject=['clmRowPerPage'];events=Object.freeze({configRoute:configRoute$3,eventServiceFactory:eventServiceFactory,clmSurveyTaskFactory:clmSurveyTaskFactory,clmEventTableFactory:clmEventTableFactory,clmEventRankTableFactory:clmEventRankTableFactory,clmEventResultsTableFactory:clmEventResultsTableFactory,clmPagerFactory:clmPagerFactory,clmRowPerPageFactory:clmRowPerPageFactory,clmPagerOptionFactory:clmPagerOptionFactory});editTmpl$1="<md-content flex class=\"md-padding\">\n\n    <div ng-if=\"!ctrl.profile || ctrl.profileNeedsUpdate\">\n        <h1>Profile Setup</h1>\n\n        <form name=\"publicIdForm\" ng-submit=\"ctrl.setPublicId(ctrl.currentUser)\">\n            <spf-sign-form current-user=\"ctrl.currentUser\"></spf-sign-form>\n\n            <div layout=\"row\" layout-align=\"center center\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"publicIdForm.$invalid || ctrl.settingPublicId\">\n                    Save\n                </md-button>\n                <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.goBack()\">\n                    Back\n                </md-button>\n            </div>\n\n        </form>\n    </div>\n\n    <div ng-if=\"ctrl.profile && !ctrl.profileNeedsUpdate\" layout=\"row\" layout-wrap>\n        <div class=\"profile\" flex=\"33\" flex-sm=\"100\">\n            <div class=\"md-whiteframe-z1 avatar\">\n                <img ng-src=\"{{ctrl.profile.user.gravatar}}?s=200&amp;r=g&amp;d=mm\" alt=\"user avatar\">\n                <h2>\n                    {{ctrl.profile.user.displayName}}\n                </h2>\n                <h3 ng-if=\"ctrl.profile.user.school &amp;&amp; ctrl.profile.user.school.type != 'Other'\" layout=\"row\" layout-wrap layout-align=\"center center\">\n                    <span flex-gt-md=\"33\" flex=\"100\" ng-if=\"ctrl.profile.user.school.iconUrl\">\n                        <img ng-src=\"{{ctrl.profile.user.school.iconUrl}}\" alt=\"user school crest\">\n                    </span>\n                    <span flex-gt-md=\"66\" flex=\"100\">{{ctrl.profile.user.school.name}}</span>\n                </h3>\n            </div>\n        </div>\n\n        <div flex=\"66\" flex-sm=\"100\">\n\n            <clm-service-card service-id=\"freeCodeCamp\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://www.freecodecamp.com/{{name}}\"\n            >\n                <clm-description>\n                    <a href=\"https://www.freecodecamp.com\" target=\"_blank\">FreeCodeCamp</a>\n                    is an open source community of busy people who learn to code and help nonprofits.\n                </clm-description>\n            </clm-service-card>\n\n            <clm-service-card service-id=\"pivotalExpert\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://pivotal-expert.firebaseapp.com/#/profile/{{name}}\"\n            >\n                <clm-description>\n                   <a href=\"https://pivotal-expert.firebaseapp.com\" target=\"_blank\">Pivotal Expert</a>\n                   helps you to learn just enough programming to make yourself a more productive professional.\n                </clm-description>\n            </clm-service-card>\n\n            <clm-service-card service-id=\"codeCombat\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://codecombat.com/user/{{name}}\"\n            >\n                <clm-description>\n                    <a href=\"http://codecombat.com/\" target=\"_blank\">Code Combat</a>,\n                    learn to Code JavaScript by Playing a Game.\n                </clm-description>\n            </clm-service-card>\n\n        </div>\n    </div>\n\n</md-content>\n\n";showTmpl="<md-content flex class=\"md-padding\" layout=\"row\">\n    <div class=\"profile\" flex=\"33\">\n        <div class=\"md-whiteframe-z1 avatar\">\n            <img ng-src=\"{{ctrl.profile.user.gravatar}}?s=200&amp;r=g&amp;d=mm\" alt=\"user avatar\">\n            <h2>\n                {{ctrl.profile.user.displayName}}\n            </h2>\n            <h3 ng-if=\"ctrl.profile.user.school\" layout=\"row\" layout-align=\"center center\">\n                <span flex=\"33\"><img ng-src=\"{{ctrl.profile.user.school.iconUrl}}\" alt=\"user school crest\"></span>\n                <span flex=\"66\">{{ctrl.profile.user.school.name}}</span>\n            </h3>\n        </div>\n    </div>\n\n    <div flex=\"66\">\n\n        <clm-service-card service-id=\"freeCodeCamp\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://www.freecodecamp.com/{{name}}\"\n        >\n            <clm-description>\n                <a href=\"https://www.freecodecamp.com\" target=\"_blank\">FreeCodeCamp</a>\n                is an open source community of busy people who learn to code and help nonprofits.\n            </clm-description>\n        </clm-service-card>\n\n        <clm-service-card service-id=\"pivotalExpert\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n          profile-template=\"https://pivotal-expert.firebaseapp.com/#/profile/{{name}}\"\n        >\n            <clm-description>\n                <a href=\"https://pivotal-expert.firebaseapp.com\" target=\"_blank\">Pivotal Expert</a>\n                helps you to learn just enough programming to make yourself a more productive professional.\n            </clm-description>\n        </clm-service-card>\n\n        <clm-service-card service-id=\"codeCombat\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n          profile-template=\"https://codecombat.com/user/{{name}}\"\n        >\n            <clm-description>\n                <a href=\"http://codecombat.com/\" target=\"_blank\">Code Combat</a>,\n                learn to Code JavaScript by Playing a Game.\n            </clm-description>\n        </clm-service-card>\n\n    </div>\n\n</md-content>\n\n";noop$7=function noop(){return undefined;};configServices.$inject=['clmServices'];configRoute$4.$inject=['$routeProvider','routes'];clmEditProfileInitialDataResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];clmShowProfileInitialDataResolver.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ClmProfileCtrl.$inject=['$log','$q','$timeout','$route','spfAuthData','spfNavBarService','initialData','clmDataStore','spfAlert','clmRefreshTimout'];profiles=Object.freeze({configServices:configServices,configRoute:configRoute$4});template$1="<md-content flex layout-padding>\n\n    <p ng-if=\"$ctrl.loading\">Loading...</p>\n\n    <div ng-messages=\"$ctrl.errors\" role=\"alert\">\n    <p ng-message=\"login\">You need to be logged in to edit the application settings.</p>\n    <p ng-message=\"register\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"admin\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"admin\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"loading\">Failed to load this view.</p>\n  </div>\n\n    <div id=\"settings\" ng-if=\"$ctrl.loaded\">\n\n        <div id=\"settings-switches\">\n            <h2 class=\"md-title\">Switches</h2>\n\n            <p ng-if=\"$ctrl.switches.length == 0\">No setting to switch.</p>\n          \n          <md-switch\n              ng-repeat=\"setting in $ctrl.switches track by setting.$id\"\n              ng-model=\"setting.value\"\n              ng-disabled=\"!$ctrl.currentUser.isAdmin\"\n              ng-change=\"$ctrl.settings.$save(setting)\"\n          >\n              {{setting.title}}.\n          </md-switch>\n        </div>\n\n        <div id=\"settings-input\">\n            <h2 class=\"md-title\">Other settings</h2>\n\n            <p ng-if=\"$ctrl.inputs.length == 0\">No setting to edit.</p>\n            \n            <md-input-container class=\"md-block\"\n                ng-repeat=\"setting in $ctrl.inputs track by setting.$id\"\n            >\n          <label>{{setting.title}}</label>\n          <input\n            ng-model=\"setting.value\"\n            ng-disabled=\"!$ctrl.currentUser.isAdmin\"\n            ng-change=\"$ctrl.settings.$save(setting)\"\n          />\n        </md-input-container>\n        </div>\n     </div>\n \n </md-content>";AdminCtrl=function(){function AdminCtrl($q,$log,spfNavBarService,spfCurrentUser,clmDataStore){var _this=this;_classCallCheck(this,AdminCtrl);this.$log=$log;this.$clmDataStore=clmDataStore;this.$watchers=[];this.errors={};this.loading=true;this.loaded=false;this.currentUser=spfCurrentUser;this.settings=this.$clmDataStore.settings.get();this.switches=[];this.inputs=[];spfNavBarService.update('Application Settings');$q.all([this.settings.$loaded(),this.currentUser.$loaded()]).then(function(){return _this.ready();}).catch(function(err){return _this.failed(err);});}_createClass(AdminCtrl,[{key:'ready',value:function ready(){var _this2=this;this.loading=false;this.loaded=true;this.checkAccess(this.currentUser);this.filterSettings();this.$watchers.push(this.currentUser.$watch(function(){return _this2.checkAccess(_this2.currentUser);}));this.$watchers.push(this.settings.$watch(function(){return _this2.filterSettings();}));}},{key:'failed',value:function failed(err){this.loading=false;this.loaded=false;this.errors.loading=true;this.$log.error(err);}},{key:'checkAccess',value:function checkAccess(user){this.errors.register=false;this.errors.admin=false;this.errors.login=user.uid===null;if(!user.uid){return;}this.errors.register=user.publicId===null;if(!user.publicId){return;}this.errors.admin=!user.isAdmin;}},{key:'filterSettings',value:function filterSettings(){var _this3=this;this.switches=[];this.inputs=[];this.settings.forEach(function(setting){if(setting.type==='boolean'){_this3.switches.push(setting);}else{_this3.inputs.push(setting);}});}},{key:'$onDestroy',value:function $onDestroy(){var _this4=this;this.$watchers.forEach(function(fn){try{fn();}catch(e){_this4.$log.error(e);}});}}]);return AdminCtrl;}();AdminCtrl.$inject=['$q','$log','spfNavBarService','spfCurrentUser','clmDataStore'];component$3={template:template$1,controller:AdminCtrl};configRoute$5.$inject=['$routeProvider','routes'];/**
 * Default export holds object to register with the Angular API.
 *
 * @type {Object}
 */admin={component:component$3,configRoute:configRoute$5};formTemplate="<md-dialog aria-label=\"Link service profile\" layout-padding style=\"min-width: 50%\">\n\n    <md-dialog-content>\n        <form name=\"service-dialog-form\" ng-submit=\"$ctrl.save($ctrl.name)\">\n\n            <h3 class=\"md-title\">Link your {{$ctrl.$card.service.name}} profile</h3>\n            <h4 class=\"md-subhead\"><a ng-href=\"{{$ctrl.profileUrl}}\">{{$ctrl.profileUrl}}</a></h4>\n\n            <div layout>\n                <md-input-container flex>\n                    <label>\n                        Your {{$ctrl.service.name}} username\n                    </label>\n                    <input name=\"userName\" ng-model=\"$ctrl.name\" required ng-change=\"$ctrl.onNameChanged()\">\n                </md-input-container>\n            </div>\n\n        </form>\n\n    </md-dialog-content>\n\n    <md-dialog-actions>\n        <md-button ng-click=\"$ctrl.save($ctrl.name)\" class=\"md-primary\">Save</md-button>\n        <md-button ng-click=\"$ctrl.close()\">Close</md-button>\n    </md-dialog-actions>\n\n</md-dialog>\n";template$2="<md-card ng=\"$ctrl.canEdit || $ctrl.data.details.id\" ng-attr-id=\"{{$ctrl.serviceId}}-service-card\">\n\n    <div ng-transclude=\"serviceForm\" style=\"visibility: hidden\">\n        <clm-service-form class=\"md-dialog-container\"></clm-service-form>\n    </div>\n\n    <md-card-header>\n        <md-card-header-text>\n            <span class=\"md-headline\">{{$ctrl.service.name}}</span>\n            <span class=\"md-subhead\" ng-if=\"$ctrl.data.details.id\">\n                Registered as\n                <a ng-href=\"{{$ctrl.profileUrl}}\" target=\"_blank\">{{$ctrl.data.details.name}}</a>\n            </span>\n        </md-card-header-text>\n    </md-card-header>\n\n    <md-card-content ng-if=\"$ctrl.canEdit && !$ctrl.data.details.id\">\n\n        <p ng-transclude=\"description\"><i>Service description...</i></p>\n\n    </md-card-content>\n\n    <md-card-content ng-if=\"$ctrl.data.details.id\">\n        <p>{{$ctrl.data.totalAchievements || 0}}  achievements</p>\n    </md-card-content>\n\n    <md-card-actions layout=\"row\" layout-align=\"end center\" ng-if=\"$ctrl.canEdit\">\n        <md-button  type=\"button\"\n            class=\"md-raised md-primary\"\n            ng-if=\"!$ctrl.data.details.id\"\n            ng-click=\" $ctrl.showAddDialog($event, '#' + $ctrl.serviceId + '-service-card .md-dialog-container')\"\n        >\n            Add My {{$ctrl.service.name}} profile\n        </md-button>\n        <md-button type=\"button\"\n            class=\"md-primary\"\n            ng-if=\"$ctrl.data.details.id\"\n            ng-click=\"$ctrl.refresh()\"\n            ng-disabled=\"!$ctrl.canRefresh\"\n            ng-switch=\"$ctrl.canRefresh\"\n            aria-label=\"Refresh Achievements\"\n        >\n            <!--\n                We allow to send a refresh request even if the service data is\n                still updating (the last request might have been lost).\n            -->\n            <span ng-switch-when=\"true\">Refresh Achievements</span>\n            <span ng-switch-default ng-switch=\"$ctrl.updating\">\n                <span ng-switch-when=\"true\">Updating...</span>\n                <span ng-switch-default>Wait to refresh again...</span>\n            </span>\n        </md-button>\n        <md-button type=\"button\" class=\"md-warn\" ng-if=\"$ctrl.data.details.id\" ng-click=\"$ctrl.remove()\">Remove</md-button>\n    </md-card-actions>\n\n</md-card>\n";noop$8=function noop(){return undefined;};ServiceCardCtrl=function(){/**
   * clm-service-card controller constructor
   *
   * @param {$compile.directive.Attributes} $attrs Controllers normalized DOM element attributes .
   * @param {jqLite}   $document       JqLite wrapper for the window document.
   * @param {function} $firebaseObject AngularFire sync. object factory
   * @param {function} $interpolate    Angular template compiler.
   * @param {object}   $log            Angular logging service.
   * @param {object}   $mdDialog       Angular Material dialog service.
   * @param {function} $q              Angular promise service.
   * @param {function} $timeout        Angular timeout service.
   * @param {object}   clmServices     List 3rd party services.
   * @param {object}   spfAlert        singpath-core alert service.
   * @param {object}   spfCurrentUser  currentUser data.
   */function ServiceCardCtrl($attrs,$document,$firebaseObject,$interpolate,$log,$mdDialog,$q,$timeout,clmServices,spfAlert,spfCurrentUser,clmRefreshTimout){var _this=this;_classCallCheck(this,ServiceCardCtrl);/**
     * singpath-core alert service.
     * @type {object}
     * @private
     */this.$alert=spfAlert;/**
     * Angular Material dialog service.
     * @type {object}
     * @private
     */this.$dialog=$mdDialog;/**
     * jqLite reference to the `document`.
     * @type {array}
     * @private
     */this.$document=$document;/**
     * AngularFire synchronized object service.
     * @type {function(ref: firebase.database.Reference)}
     * @private
     */this.$firebaseObject=$firebaseObject;/**
     * Angular logger service.
     * @type {object}
     * @private
     */this.$log=$log;/**
     * Angular promise service.
     * @type {function}
     * @private
     */this.$q=$q;/**
     * List of 3rd party service manager.
     * @type {Map<string,Service>}
     * @private
     */this.$services=clmServices;/**
     * Angular timeout service.
     * @type {function}
     */this.$timeout=$timeout;/**
     * Current user service
     * @type {{publicId: string, $watch: function(handler: function): function(): void}}
     */this.currentUser=spfCurrentUser;/**
     * The ctrl will stop watching for user changes when this function is called.
     *
     * Should be called when the component is destroyed.
     *
     * @type {function}
     * @private
     */this.$unwatchUser=this.currentUser.$watch(function(){return _this.watchData();});/**
     * Third party service "service" - used to interact with the user data for
     * that service.
     *
     * @type {?{
     *         dataRef: function(publicId: string): firebase.database.Reference,
     *         requestUpdate: function(publicId: string): Promise<void, Error>,
     *         saveDetails: function(publicId: string, data: {id: string, name: string}): Promise<void, Error>
     *       }}
     */this.service=undefined;/**
     * The user service data.
     *
     * @type {?{
     *         lastUpdate: number,
     *         lastUpdateRequest: number,
     *         details: {id: string, name: string, registeredBefore: string},
     *         totalAchievements: number
     *       }}
     */this.data=undefined;/**
     * The ctrl will stop watching for data when this function is called.
     *
     * Should be called on a publicId or serviceId changes
     * @type {function}
     * @private
     */this.$unwatchData=noop$8;/**
     * URL to the user profile for that service
     * @type {?string}
     */this.profileUrl=undefined;/**
     * Build a profile url using the user service details.
     *
     * We retrieve the URL template from the component "profile-template" html
     * attribute before Angular interpolate it. We need to interpolate it
     * ourself and provide the user service details.
     *
     * @type {function(scope: object): string}
     */this.$profileUrlTemplate=$interpolate($attrs.profileTemplate,false,undefined,true);// flags
/**
     * Should set true while the controller is loading resources.
     * @type {Boolean}
     */this.loading=false;/**
     * Should set the true if the profile owner is the current user.
     *
     * @todo should admin or premium users be allowed to edit
     * @type {Boolean}
     */this.canEdit=false;/**
     * Should be set to true during a pending refresh request.
     * @type {Boolean}
     */this.updating=false;/**
     * Should be set false while the last refresh request is too recent.
     * @type {Boolean}
     */this.canRefresh=false;/**
     * Timer for the resfresh button
     * @type {?Promise<void,Error>}
     */this.$disableRefresh=undefined;/**
     * Timer delay
     * @type {number}
     */this.$timoutDelay=clmRefreshTimout;}/* Angular Controller hooks *//* see https://docs.angularjs.org/api/ng/service/$compile#life-cycle-hooks *//**
   * Called by angular when component bindings changes.
   *
   * Should reset flags, `service` and `data` related properties.
   *
   * @param {object} changes list of changes.
   */_createClass(ServiceCardCtrl,[{key:'$onChanges',value:function $onChanges(changes){if(changes.publicId||changes.serviceId){this.watchData();}if(changes.disableRefresh){this.setCanRefresh();}}/**
   * Called when the componet is getting removed from the DOM.
   *
   * Should stop watching for current user or profile user service data changes,
   * and release the data synchronized object.
   */},{key:'$onDestroy',value:function $onDestroy(){this.$unwatchData();this.$unwatchUser();if(this.data&&this.data.$destroy){this.data.$destroy();}if(this.$disableRefresh){this.$timeout.cancel(this.$disableRefresh);this.$disableRefresh=undefined;}}/* private methodes *//**
   * Create the service profile synchronized object and listen for changes.
   *
   * Changes should update flag properties.
   *
   * @private
   */},{key:'watchData',value:function watchData(){var _this2=this;this.service=this.$services[this.serviceId];this.loading=true;this.updating=false;this.profileUrl=undefined;this.canEdit=Boolean(this.currentUser.publicId&&this.publicId===this.currentUser.publicId);this.$unwatchData();if(this.data&&this.data.$destroy){this.data.$destroy();}var ref=this.service.dataRef(this.publicId);this.data=this.$firebaseObject(ref);this.$unwatchData=this.data.$watch(function(){return _this2.onDataChanged();});}/**
   * Service data change (details, lastUpdate or lastUpdateRequest) handler.
   *
   * @private
   */},{key:'onDataChanged',value:function onDataChanged(){this.loading=false;if(!this.data||this.data.$value===null||!this.data.details){this.updating=false;this.profileUrl=undefined;return;}this.setProfileUrl();this.setUpdating();}/**
   * Update `canRefresh` propety.
   *
   * @private
   * @return {Promise<void>}
   */},{key:'setCanRefresh',value:function setCanRefresh(){var _this3=this;var timers=[this.disableRefresh,this.$disableRefresh].filter(function(t){return t&&t.then!==undefined;});this.canRefresh=false;return this.$q.all(timers).then(function(){_this3.canRefresh=true;_this3.$disableRefresh=undefined;});}/**
   * Update 'updating' property.
   *
   * Service data are updating they have no lastUpdate property of it's lower
   * than the lastUpdateRequest.
   *
   * @private
   */},{key:'setUpdating',value:function setUpdating(){var lastUpdateRequest=this.data.lastUpdateRequest||0;var lastUpdate=this.data.lastUpdate||0;this.updating=lastUpdate<lastUpdateRequest;}/**
   * Update profileUrl property.
   *
   * @private
   */},{key:'setProfileUrl',value:function setProfileUrl(){this.profileUrl=this.$profileUrlTemplate(this.data&&this.data.details);}/* public methodes *//**
   * Show the form to add a user's service user name.
   *
   * @param  {Object} $event   Click event.
   * @param  {string} selector Selector to find the the dialog form.
   * @return {Promise<void, any>}
   */},{key:'showAddDialog',value:function showAddDialog($event,selector){return this.$dialog.show({targetEvent:$event,contentElement:selector,parent:this.$document.find('body'),clickOutsideToClose:true});}/**
   * Request a service profile update.
   *
   * @return {Promise<void>}
   */},{key:'refresh',value:function refresh(){var _this4=this;if(!this.canRefresh){return Promise.reject(new Error('Refresh is currently disable.'));}this.canRefresh=false;return this.service.requestUpdate(this.publicId).then(function(){_this4.$disableRefresh=_this4.$timeout(_this4.$timoutDelay);_this4.setCanRefresh();}).catch(function(err){_this4.canRefresh=true;_this4.$log.error(err);_this4.$alert.error('Failed to request a '+_this4.service.name+' profile update.');});}/**
   * Removed the user service profile.
   *
   * @return {Promise<void>}
   */},{key:'remove',value:function remove(){var _this5=this;return this.service.removeDetails(this.publicId).then(function(){return _this5.$alert.success('Unliked '+_this5.service.name+' profile.');}).catch(function(err){_this5.$log.error(err);_this5.$alert.error('Failed to unlink your '+_this5.service.name+' profile.');});}}]);return ServiceCardCtrl;}();ServiceCardCtrl.$inject=['$attrs','$document','$firebaseObject','$interpolate','$log','$mdDialog','$q','$timeout','clmServices','spfAlert','spfCurrentUser','clmRefreshTimout'];/**
 * "clm-service-card" component settings.
 *
 * @example
 * <!-- using default form -->
 * <clm-service-card public-id="$ctrl.publicId" service-id="myService" disable-refresh="$ctrl.refreshTimeout">
 *   <clm-description>myService let you gain achievements...</clm-description>
 * </clm-service-card>
 *
 * @example
 *  <!-- using custom dialog form -->
 *  <clm-service-card public-id="$ctrl.publicId" service-id="myService" disable-refresh="$ctrl.refreshTimeout">
 *    <clm-description>myService let you gain achievements...</clm-description>
 *    <clm-service-form>
 *      <md-dialog aria-label="Link service profile" layout-padding style="min-width: 50%">
 *        <md-dialog-content>
 *          <form name="service-dialog-form" ng-submit="$ctrl.save($ctrl.newName)">
 *            <md-input-container flex>
 *              <label>
 *                Your username
 *              </label>
 *              <input name="userName" ng-model="$ctrl.newName" required">
 *            </md-input-container>
 *          </form>
 *        </md-dialog-content>
 *        <md-dialog-actions>
 *          <md-button ng-click="$ctrl.createService($ctrl.newName)" class="md-primary">Save</md-button>
 *          <md-button ng-click="$ctrl.closeDialog()">Close</md-button>
 *        </md-dialog-actions>
 *      </md-dialog>
 *    </clm-service-form>
 *  </clm-service-card>
 *
 * @type {Object}
 */component$4={template:template$2,// `transclude` allows to pass some HTML content which the component can
// include in its internal DOM. Note that the  HTML content will be
// interpolated using the outer scope, not the component scope.
transclude:{// angular will clone the child "clm-description" element to insert
// it inside the component (using
// `<div ng-transclude-slot="description"></div>` in the service-card
// template).
description:'clmDescription',// angular will clone the child "clm-service-form" element to insert
// it inside the component (using
// `<div ng-transclude-slot="serviceForm"></div>` in the service-card
// template).
serviceForm:'?clmServiceForm'},// component attributes (`public-id` and `service-id`) bound and synchronized
// to the component controller instance as (`publicId` and `serviceId`
// properties).
bindings:{publicId:'<',serviceId:'@',disableRefresh:'<'},// controller which an instance will accessible as `$ctrl` in the component
// template.
controller:ServiceCardCtrl};GenericServiceFormCtrl=function(){/**
   * clm-service-form controller contructor.
   *
   * Expect a $card property referencing the parent "clm-service-card"
   * controller instance.
   *
   * @param  {object} $log       Angular logging service.
   * @param  {object} $mdDialog  Angular Material dialog service.
   * @param  {object} spfAlert   singpath-core alert service.
   */function GenericServiceFormCtrl($log,$mdDialog,spfAlert){_classCallCheck(this,GenericServiceFormCtrl);/**
     * Angular logging service.
     * @type {{error: function(msg: string): void}}
     * @private
     */this.$log=$log;/**
     * Angular Material dialog service.
     * @type {{hide: function(result: any): Promise}, cancel: function(result: any): Promise}}
     * @private
     */this.$dialog=$mdDialog;/**
     * Singpath Core alert service
     * @type {{sucess: function(msg: string): void, error: function(msg: string): void}}
     * @private
     */this.$alert=spfAlert;/**
     * The user name for that service
     * @type {?string}
     */this.name=undefined;/**
     * The URL to that profile
     * @type {string}
     */this.profileUrl=undefined;}/* Angular Controller hook(s) *//* see https://docs.angularjs.org/api/ng/service/$compile#life-cycle-hooks *//**
   * Called once bindings are setup.
   *
   * Should set the default profileUrl.
   */_createClass(GenericServiceFormCtrl,[{key:'$onInit',value:function $onInit(){this.setProfileUrl();}/* private method(s) */},{key:'setProfileUrl',value:function setProfileUrl(){this.profileUrl=this.$card.$profileUrlTemplate({id:this.name||'<user-name>',name:this.name||'<user-name>'});}/* public methods *//**
   * Update the ctrl state after changes to the name property.
   *
   * Should update the default profileUrl.
   */},{key:'onNameChanged',value:function onNameChanged(){this.setProfileUrl();}/**
   * Save the user details for that service.
   *
   * @param  {string} name The user name for that service.
   * @return {Promise<void, Error>}
   */},{key:'save',value:function save(name){var _this6=this;return this.$card.service.saveDetails(this.$card.publicId,{id:name,name:name}).then(function(){_this6.$alert.success(_this6.$card.service.name+' profile linked.');return _this6.$dialog.hide();},function(err){_this6.$alert.error('Failed to link your '+_this6.$card.service.name+' profile.');return Promise.reject(err);}).catch(function(err){_this6.$log.error(err);return Promise.reject(err);});}/**
   * Close the dialog without saving the details.
   *
   * @return {Promise<void>}
   */},{key:'close',value:function close(){return this.$dialog.cancel();}}]);return GenericServiceFormCtrl;}();GenericServiceFormCtrl.$inject=['$log','$mdDialog','spfAlert'];/**
 * "clm-service-form" component definition.
 *
 * Used for the default service name form dialog. Can be used as an example
 * or a base for more advance linking process.
 *
 * @type {Object}
 */serviceForm={template:formTemplate,// The parent clm-service-card controller will be added as a "$card" property
// to this component controller.
require:{$card:'^^clmServiceCard'},controller:GenericServiceFormCtrl};serviceCard={component:component$4,serviceForm:{component:serviceForm}};components$1={ace:ace$2,admin:admin,challenges:challenges,classmentors:classmentors,cohorts:cohorts,events:events,profiles:profiles,serviceCard:serviceCard};_export('module',module$1=angular$1.module('clm',['angular-loading-bar','firebase','ngAnimate','ngMessages','ngRoute','timer',spfShared.name]));module$1.value('clmServicesUrl',{backend:'http://api.singpath.com/',singPath:'http://www.singpath.com/',codeCombat:'https://codecombat.com',codeSchool:'https://www.codeschool.com'});// module.component('challenges', components.challenges.component);
module$1.component('ace',components$1.ace.component);module$1.component('classmentors',components$1.classmentors.component);module$1.component('clmAdmin',components$1.admin.component);module$1.component('clmServiceCard',components$1.serviceCard.component);module$1.component('clmServiceForm',components$1.serviceCard.serviceForm.component);module$1.config(components$1.ace.configRoute);module$1.config(components$1.admin.configRoute);module$1.constant('aceStatsUrl',components$1.ace.ACE_STATS_URL);module$1.constant('clmRefreshTimout',60000);module$1.constant('spfProfilesPath','classMentors/userProfiles');module$1.directive('clmCohortsRankingPage',components$1.cohorts.clmCohortRankPageFactory);module$1.directive('clmCohortsStatsPage',components$1.cohorts.clmCohortsStatsPageFactory);module$1.directive('clmEventRankTable',components$1.events.clmEventRankTableFactory);module$1.directive('clmEventResultsTable',components$1.events.clmEventResultsTableFactory);module$1.directive('clmEventTable',components$1.events.clmEventTableFactory);module$1.directive('clmPager',components$1.events.clmPagerFactory);module$1.directive('cmContains',cmContainsFactory);module$1.directive('scrollBottom',components$1.challenges.scrollBottom);module$1.factory('aceStats',components$1.ace.factory);module$1.factory('challengeService',components$1.challenges.challengeServiceFactory);module$1.factory('clmDataStore',clmDataStoreFactory);module$1.factory('clmPagerOption',components$1.events.clmPagerOptionFactory);module$1.factory('clmRowPerPage',components$1.events.clmRowPerPageFactory);module$1.factory('clmServices',clmServicesFactory);module$1.factory('eventService',components$1.events.eventServiceFactory);module$1.filter('cmTruncate',cmTruncateFilterFactory);module$1.filter('cmTruncated',cmTruncateFilterBooleanFactory);module$1.filter('showSchool',showSchoolFilterFactory);module$1.filter('showTeamMembers',showTeamMembersFilterFactory);// module.filter('reverseArray', filters.reverseArray);
//for page controls in trat
module$1.run(components$1.profiles.configServices);module$1.factory('quizFactory',components$1.challenges.tratQuestionFactory);// TODO: convert those view controller/template to component and move them above
module$1.config(components$1.cohorts.configRoute);module$1.config(components$1.events.configRoute);module$1.config(components$1.profiles.configRoute);module$1.config(components$1.challenges.configRoute);// module.config(components.challenges.teamActivity.configRoute);
// added new survey factory for tryout purpose
module$1.factory('clmSurvey',components$1.events.clmSurveyTaskFactory);/**
 * Label route paths.
 *
 * Required for singpath-core/services/routes.js and its "urlFor" service and
 * filter.
 *
 * Should be used to configure $routeProvider.
 *
 */module$1.constant('routes',{home:'/ace-of-coders',// The default route
aceOfCoders:'/ace-of-coders',admin:'/admin',events:'/events',newEvent:'/new-event',oneEvent:'/events/:eventId',editEvent:'/events/:eventId/edit',editEventTask:'/events/:eventId/task/:taskId',addEventTask:'/events/:eventId/new-task',profile:'/profile/:publicId',editProfile:'/profile/',cohorts:'/cohorts',newCohort:'/new-cohort',viewCohort:'/cohorts/:cohortId',editCohort:'/cohorts/:cohortId/edit',viewMcq:'/challenges/mcq',startMcq:'/events/:eventId/challenges/:taskId/mcq/start',editMcq:'/challenges/mcq/edit',viewSurvey:'/challenges/survey',createTeamActivity:'/challenges/team-activity/create',viewIRAT:'/challenges/IRAT',viewTRAT:'/events/:eventId/challenges/:taskId/TRAT/start'});_export('module',module$1);_export('bootstrap',bootstrap);}};});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[a](d.createTextNode(c));})
("/*! \n * angular-loading-bar v0.8.0\n * https://chieffancypants.github.io/angular-loading-bar\n * Copyright (c) 2015 Wes Cruver\n * License: MIT\n */#loading-bar,#loading-bar-spinner{pointer-events:none;-webkit-pointer-events:none;-webkit-transition:all .35s linear;transition:all .35s linear}#loading-bar-spinner.ng-enter,#loading-bar-spinner.ng-leave.ng-leave-active,#loading-bar.ng-enter,#loading-bar.ng-leave.ng-leave-active{opacity:0}#loading-bar-spinner.ng-enter.ng-enter-active,#loading-bar-spinner.ng-leave,#loading-bar.ng-enter.ng-enter-active,#loading-bar.ng-leave{opacity:1}#loading-bar .bar{-webkit-transition:width .35s;transition:width .35s;background:#29d;position:fixed;z-index:2;top:0;left:0;width:100%;height:2px;border-bottom-right-radius:1px;border-top-right-radius:1px}#loading-bar .peg{position:absolute;width:70px;right:0;top:0;height:2px;opacity:.45;-ms-box-shadow:#29d 1px 0 6px 1px;box-shadow:1px 0 6px 1px #29d;border-radius:100%}#loading-bar-spinner{display:block;position:fixed;z-index:2;top:10px;left:10px}#loading-bar-spinner .spinner-icon{width:14px;height:14px;border:2px solid transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:a .4s linear infinite;animation:a .4s linear infinite}@-webkit-keyframes a{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes a{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}body p,html p{line-height:1.25}#loading-bar .bar{background:#ffc107;height:5px;border-bottom-right-radius:2px;border-top-right-radius:2px}#loading-bar .peg{height:5px;-ms-box-shadow:#ffc107 1px 0 6px 1px;box-shadow:1px 0 6px 1px #ffc107}.md-button{margin:16px 8px;padding:0 8px;line-height:36px}.md-button.md-icon-button.small-icon{height:36px;width:36px;line-height:36px;margin:0}.small-icon md-icon{line-height:18px;height:18px;width:18px}.md-accent md-icon g{fill:rgba(0,0,0,.87)}md-sidenav md-list .md-button{color:inherit;font-weight:500;text-align:left;width:100%;padding:16px;margin:0;line-height:normal}md-toolbar .separator{width:48px;height:28px}md-icon:focus{outline:none}.even{background-color:#eee}table .md-button{margin:4px}@media (max-width:600px){.responsive-button{min-width:0;padding:0 12px}}thead th{vertical-align:top}spf-editor-container label{color:#000;color:rgba(0,0,0,.258824);cursor:default;padding:20px 0 5px 2px}spf-editor-container div[ng-message],spf-editor-container label{display:block;font-family:RobotoDraft,Roboto,Helvetica Neue,sans-serif}spf-editor-container div[ng-message]{color:#000;color:rgba(0,0,0,.870588);font-size:12px;height:24px;line-height:24px}spf-editor-container.is-invalid.had-focus div[ng-message],spf-editor-container.is-invalid.had-focus label,spf-editor-container.is-invalid.has-focus div[ng-message],spf-editor-container.is-invalid.has-focus label{color:#ff5722}spf-editor-container.has-focus label,spf-editor-container:not(.is-empty) label{-webkit-transition:-webkit-transform .25s cubic-bezier(.25,.8,.25,1);transition:-webkit-transform .25s cubic-bezier(.25,.8,.25,1);transition:transform .25s cubic-bezier(.25,.8,.25,1);transition:transform .25s cubic-bezier(.25,.8,.25,1),-webkit-transform .25s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate3d(0,4px,0) scale(.75);transform:translate3d(0,4px,0) scale(.75);-webkit-transform-origin:left bottom;transform-origin:left bottom}spf-editor-container.is-valid div[ng-message],spf-editor-container.is-valid label{color:#000;color:rgba(0,0,0,.541176)}.spf-ace-editor{height:200px}.nav-parent>*{font-size:inherit}.menu-item.ng-enter,.menu-item.ng-leave,.menu-item.ng-move{-webkit-transition:all .3s linear;transition:all .3s linear}.menu-item.ng-enter,.menu-item.ng-leave.ng-leave-active,.menu-item.ng-move{max-width:0;min-width:0;margin:16px 0;padding:0;overflow:hidden}.menu-item.ng-enter.ng-enter-active,.menu-item.ng-leave,.menu-item.ng-move.ng-move-active{margin:16px 8px;padding:0 8px;max-width:150px;min-width:24px}.md-hue-1{background:#795548;color:#fff}#vertical-container{height:292px;width:100%;max-width:400px}classmentors{height:100%;width:100%}md-sidenav.md-locked-open{width:250px;min-width:250px;max-width:250px}.c3 svg{font:10px sans-serif;-webkit-tap-highlight-color:transparent}.c3 line,.c3 path{fill:none;stroke:#000}.c3 text{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.c3-bars path,.c3-event-rect,.c3-legend-item-tile,.c3-xgrid-focus,.c3-ygrid{shape-rendering:crispEdges}.c3-chart-arc path{stroke:#fff}.c3-chart-arc text{fill:#fff;font-size:13px}.c3-grid line{stroke:#aaa}.c3-grid text{fill:#aaa}.c3-xgrid,.c3-ygrid{stroke-dasharray:3 3}.c3-text.c3-empty{fill:gray;font-size:2em}.c3-line{stroke-width:1px}.c3-circle._expanded_{stroke-width:1px;stroke:#fff}.c3-selected-circle{fill:#fff;stroke-width:2px}.c3-bar{stroke-width:0}.c3-bar._expanded_{fill-opacity:.75}.c3-target.c3-focused{opacity:1}.c3-target.c3-focused path.c3-line,.c3-target.c3-focused path.c3-step{stroke-width:2px}.c3-target.c3-defocused{opacity:.3!important}.c3-region{fill:#4682b4;fill-opacity:.1}.c3-brush .extent{fill-opacity:.1}.c3-legend-item{font-size:12px}.c3-legend-item-hidden{opacity:.15}.c3-legend-background{opacity:.75;fill:#fff;stroke:#d3d3d3;stroke-width:1}.c3-title{font:14px sans-serif}.c3-tooltip-container{z-index:1}.c3-tooltip{border-collapse:collapse;border-spacing:0;background-color:#fff;empty-cells:show;box-shadow:7px 7px 12px -9px #777;opacity:.9}.c3-tooltip tr{border:1px solid #ccc}.c3-tooltip th{background-color:#aaa;font-size:14px;padding:2px 5px;text-align:left;color:#fff}.c3-tooltip td{font-size:13px;padding:3px 6px;background-color:#fff;border-left:1px dotted #999}.c3-tooltip td>span{display:inline-block;width:10px;height:10px;margin-right:6px}.c3-tooltip td.value{text-align:right}.c3-area{stroke-width:0;opacity:.2}.c3-chart-arcs-title{dominant-baseline:middle;font-size:1.3em}.c3-chart-arcs .c3-chart-arcs-background{fill:#e0e0e0;stroke:none}.c3-chart-arcs .c3-chart-arcs-gauge-unit{fill:#000;font-size:16px}.c3-chart-arcs .c3-chart-arcs-gauge-max,.c3-chart-arcs .c3-chart-arcs-gauge-min{fill:#777}.c3-chart-arc .c3-gauge-value{fill:#000}div.subhead{font-style:italic;font-size:10px}div.information{font-style:italic;font-size:15px}md-dialog.announcement-dialog{max-width:70%;max-height:85%;width:70%;height:85%;border-radius:0}.selectdemoSelectHeader .demo-header-searchbox{border:none;outline:none;height:100%;width:100%;padding:0}.selectdemoSelectHeader .demo-select-header{box-shadow:0 1px 0 0 rgba(0,0,0,.1),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);padding-left:10.667px;height:48px;cursor:pointer;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:auto}.selectdemoSelectHeader md-content._md{max-height:240px}.events td,.events th{text-align:center;padding:0 10px}.tasks tbody th:first-child{text-align:left;padding-left:0}.reversed th.orderer .md-button:after,.secondaryReversed th.secondaryOrderer .md-button:after{content:\" \\25BC\";font-size:12px}th.orderer .md-button:after,th.secondaryOrderer .md-button:after{content:\" \\25B2\";font-size:12px}th.secondaryOrderer .md-button:after{color:#ddd}.name-button{text-align:left;width:100%}#editor{top:0;right:0;bottom:0;left:0;height:400px;width:15000px;max-height:90%;max-width:100%}md-dialog.enlarged-dialog{max-width:70%;max-height:90%;width:70%;height:90%;border-radius:0}md-dialog.link-dialog{max-width:70%;max-height:50%;width:70%;height:50%;border-radius:0}.profile{text-align:center}.profile,.profile .avatar{padding:8px}.badge img,.profile img{max-width:100%;height:auto;display:inline-block}.register-service,.service-card,.spf-card{padding:8px 16px;margin:16px 0}.badges img,.courses img,.language svg{text-align:center;position:relative;-webkit-box-reflect:below 0 -webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(70%,transparent),to(hsla(0,0%,100%,.2)));-webkit-transition:top .5s ease-out;-moz-transition:top .5s ease-out;-o-transition:top .5s ease-out}.badges{background-color:transparent;border:none;box-shadow:none}.badges img:hover{cursor:pointer;top:-5px;-webkit-box-reflect:below 10px -webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(70%,transparent),to(hsla(0,0%,100%,.2)))}.spf-card .language{margin:16px 0}.spf-card md-icon{height:30px;width:55px}\n/*# sourceMappingURL=__.css.map */");
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define(["angular-animate/angular-animate.js","angular-messages/angular-messages.js","angular-route/angular-route.js","angular/angular.js","angular-material/angular-material.js","angularfire","firebase","d3"], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory(require("angular-animate/angular-animate.js"), require("angular-messages/angular-messages.js"), require("angular-route/angular-route.js"), require("angular/angular.js"), require("angular-material/angular-material.js"), require("angularfire"), require("firebase"), require("d3"));
  else
    classmentors = factory(angular, angular, angular, angular, angular, angular, firebase, d3);
});